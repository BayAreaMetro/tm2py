{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-tm2py","title":"Welcome to tm2py","text":""},{"location":"#the-python-package-developed-to-run-travel-model-two","title":"The python package developed to run Travel Model Two","text":"<p>Currently a large pile of documentation exists for an earlier incarnation of this project, we need to port that documentation here.</p> <p>Travel Model Two runs with a CTRAMP household demand model and EMME skimming/assignment procedures.</p> <p>Important travel behavior enhancements in Travel Model Two include:</p> <ul> <li> <p>A much more detailed spatial representation of transportation system supply including an accurate all-streets network for entire 9-county Bay Area, pedestrian paths\\sidewalks from OpenStreetMap, bicycle facilities from MTC\u2019s BikeMapper, and transit networks from MTC\u2019s RTD network</p> </li> <li> <p>Land-use and demographic forecast integration with Bay Area UrbanSim Two represented at a 40,000 micro-analysis zone (MAZ) level</p> </li> <li> <p>Detailed transit access/egress based on actual origin/destinations at the MAZ level considering boarding and alighting at specific transit stops allowing for a more accurate representation of walk times</p> </li> <li> <p>More detailed temporal resolution using half-hourly time windows compared to hourly time windows in Travel Model One</p> </li> <li> <p>The effects of transit capacity and crowding</p> </li> <li> <p>More detailed auto assignments, most notably with the loading of short trips to local streets</p> </li> <li> <p>The inclusion of Taxis and Transportation Network Companies (TNCs) such as Uber and Lyft as a mode choice option</p> </li> <li>Representation of Automated Vehicles</li> </ul> <p>How do you create and update these pages? See Contributing/Documentation</p>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#setting-up-the-model-to-run","title":"Setting up the model to run","text":"<p>Main operational interface for setup model process.</p> Source code in <code>tm2py/setup_model/setup.py</code> <pre><code>class SetupModel:\n    \"\"\"\n    Main operational interface for setup model process.\n    \"\"\"\n\n    def __init__(self, config_file: pathlib.Path, model_dir: pathlib.Path):\n        \"\"\"Initializes an instance of the SetupModel class.\n\n        Args:\n            config_file (pathlib.Path): The TOML file with the model setup attributes.\n            model_dir (pathlib.Path): The directory which to setup for a TM2 model run.\n        \"\"\"\n        self.config_file = config_file\n        self.setup_config = SetupConfig(dict())\n        self.model_dir = model_dir\n\n    def _setup_logging(self, log_file: pathlib.Path):\n        \"\"\"\n        Setup a logger that logs to both the console and to the given log file.\n        \"\"\"\n        self.logger = logging.getLogger()\n        self.logger.setLevel(logging.DEBUG)\n        # console handler\n        ch = logging.StreamHandler()\n        ch.setLevel(logging.INFO)\n        ch.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p'))\n        self.logger.addHandler(ch)\n\n        # file handler\n        fh = logging.FileHandler(log_file, mode='w')\n        fh.setLevel(logging.DEBUG)\n        fh.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p'))\n        self.logger.addHandler(fh)\n\n    def _load_toml(self):\n        \"\"\"\n        Load SetupConfig from toml file.\n\n        Args:\n            toml_path: path for toml file to read\n        \"\"\"\n        with open(self.config_file, \"r\", encoding=\"utf-8\") as toml_file:\n            data = toml.load(toml_file)\n        return data\n\n    def run_setup(self):\n        \"\"\"\n        Does the work of setting up the model.  \n\n        This step will do the following within the model directory.\n\n        1. Intialize logging to write to `setup.log`\n        2. Copy the setup config file to `setupmodel_config.toml`\n        3. Create the required folder structure\n        4. Copy the input from the locations specified:\n           a. hwy and trn networks\n           b. popsyn and landuse inputs\n           c. nonres inputs\n           d. warmstart demand matrices\n           e. warmstart skims\n        5. Copy the Emme template project and Emme network databases \n           (based on the EMME version in sys.path)\n        6. Download the travel model CTRAMP core code (runtime, uec) from the \n           [travel-model-two repository](https://github.com/BayAreaMetro/travel-model-two)\n        7. Updates the IP address in the CTRAMP runtime properties files\n        8. Creates `RunModel.py` for running the model\n\n        Raises:\n            FileExistsError: If the model directory to setup already exists.\n        \"\"\"\n        # Read setup setup_config\n        config_dict = self._load_toml()\n        self.setup_config = SetupConfig(config_dict)\n        self.setup_config.validate()\n\n        # if the directory already exists - error and quit\n        if self.model_dir.exists():\n            raise FileExistsError(f\"{self.model_dir.resolve()} already exists! Setup terminated.\")\n        else:\n            self.model_dir.mkdir()\n\n        # Initialize logging\n        log_file = self.model_dir / \"setup.log\"\n        self._setup_logging(log_file)\n\n        self.logger.info(f\"Starting process to setup MTC model in directory: {self.model_dir.resolve()}\")\n\n        # Save setup config into model dir as setupmodel_config.toml\n        shutil.copy(self.config_file, self.model_dir / \"setupmodel_config.toml\")\n        self.logger.info(f\"Copied {self.config_file} to {self.model_dir / 'setupmodel_config.toml'}\")\n\n        # List of folders to create\n        folders_to_create = [\n            \"acceptance\",\n            \"CTRAMP\",\n            \"ctramp_output\",\n            \"demand_matrices\",\n            \"demand_matrices/highway\",\n            \"demand_matrices/highway/air_passenger\",\n            \"demand_matrices/highway/household\",\n            \"demand_matrices/highway/maz_demand\",\n            \"demand_matrices/highway/internal_external\",\n            \"demand_matrices/highway/commercial\",\n            \"demand_matrices/transit\",\n            \"emme_project\",\n            \"inputs\",\n            \"logs\",\n            \"notebooks\",\n            \"output_summaries\",\n            \"skim_matrices\",\n            \"skim_matrices/highway\",\n            \"skim_matrices/transit\",\n            \"skim_matrices/non_motorized\",\n        ]\n\n        # Create folder structure\n        self._create_folder_structure(folders_to_create)\n\n        # Copy model inputs\n        self._copy_model_inputs()\n\n        # Copy emme project and database\n        self._copy_emme_project_and_database()\n\n        # Download toml SetupConfig files from GitHub\n        config_files_list = [\n            \"observed_data.toml\",\n            \"canonical_crosswalk.toml\",\n            \"model_config.toml\",\n            \"scenario_config.toml\",\n        ]\n        acceptance_config_files_list = [\n            \"observed_data.toml\",\n            \"canonical_crosswalk.toml\",\n        ]\n\n        for file in config_files_list:\n            github_url = self.setup_config.CONFIGS_GITHUB_PATH + \"/\" + file\n\n            local_file = self.model_dir / file\n\n            self._download_file_from_github(github_url, local_file)\n\n        # Fetch required folders from travel model two github release (zip file)\n        org = \"BayAreaMetro\"\n        repo = \"travel-model-two\"\n        tag = self.setup_config.TRAVEL_MODEL_TWO_RELEASE_TAG\n        folders_to_extract = [\"runtime\", \"uec\"]\n\n        self._download_github_release(\n            org,\n            repo,\n            tag,\n            folders_to_extract,\n            self.model_dir / \"CTRAMP\"\n        )\n\n        # Rename 'uec' folder to 'model'\n        old_path = self.model_dir / \"CTRAMP\" / \"uec\"\n        old_path.rename(self.model_dir / \"CTRAMP\" / \"model\")\n\n        self._create_run_model_batch()\n\n        # update IP addresses in config files\n        ips_here = socket.gethostbyname_ex(socket.gethostname())[-1]\n        self.logger.info(f\"Found the following IPs for this server: {ips_here}; using the first one: {ips_here[0]}\")\n\n        # add IP address to mtctm2.properties\n        self._replace_in_file(\n            self.model_dir / 'CTRAMP' / 'runtime' / 'mtctm2.properties', {\n                \"(\\nRunModel.MatrixServerAddress[ \\t]*=[ \\t]*)(\\S*)\": f\"\\g&lt;1&gt;{ips_here[0]}\",\n                \"(\\nRunModel.HouseholdServerAddress[ \\t]*=[ \\t]*)(\\S*)\": f\"\\g&lt;1&gt;{ips_here[0]}\"\n            }\n        )\n        # add IP address to logsum.properties\n        self._replace_in_file(\n            self.model_dir / 'CTRAMP' / 'runtime' / 'logsum.properties', {\n                \"(\\nRunModel.MatrixServerAddress[ \\t]*=[ \\t]*)(\\S*)\": f\"\\g&lt;1&gt;{ips_here[0]}\",\n                \"(\\nRunModel.HouseholdServerAddress[ \\t]*=[ \\t]*)(\\S*)\": f\"\\g&lt;1&gt;{ips_here[0]}\"\n            }\n        )\n        self.logger.info(f\"Setup process completed successfully!\")\n\n        # Close logging\n        logging.shutdown()\n\n\n    def _create_run_model_batch(self):\n        \"\"\"\n        Creates the RunModel.bat and RunModel.py in the root directory\n        \"\"\"\n\n        if not self.model_dir.exists():\n            self.logger.error(f\"Directory {self.model_dir} does not exists.\")\n            raise FileNotFoundError(f\"Directory {self.model_dir} does not exists.\")\n\n        # create RunModel.py\n        with open(self.model_dir / 'RunModel.py', 'w') as file:\n            self.logger.info(f\"Creating RunModel.py in directory {self.model_dir}\")\n            file.write(_RUN_MODEL_PY_CONTENT)\n\n\n    def _create_folder_structure(self, folder_names: list[str]):\n        \"\"\"\n        Creates empty folder structure in the root directory\n\n        Args:\n            folder_names: list of folders to create\n            self.model_dir: root directory for the model\n        \"\"\"\n\n        self.logger.info(f\"Creating folder structure in directory {self.model_dir.resolve()}\")\n\n        if not self.model_dir.exists():\n            error_str = f\"Directory {self.model_dir} does not exist.\"\n            self.logger.error(error_str)\n            raise FileNotFoundError(error_str)\n\n        for folder in folder_names:\n            path = self.model_dir / folder\n            path.mkdir()\n            self.logger.info(f\"  Created Empty Folder: {path}\")\n\n    def _copy_folder(self, src_dir: pathlib.Path, dest_dir: pathlib.Path):\n        \"\"\"\n        Copies a folder from the source directory to the destination directory.\n\n        Args:\n            src: source folder\n            dest: destination folder\n        \"\"\"\n\n        if not src_dir.exists():\n            error_str = f\"Source directory {src_dir} to copy from does not exist\"\n            self.logger.error(error_str)\n            raise FileNotFoundError(error_str)\n\n        # Copy the entire folder and its contents\n        try:\n            # Check if the destination directory exists\n            if dest_dir.exists():\n                # delete the existing destination directory\n                # Newer versions supports `dirs_exist_ok` but with this version,\n                # the destination directory must not already exist\n                shutil.rmtree(dest_dir)\n\n            shutil.copytree(src_dir, dest_dir)\n\n            self.logger.info(f\"Copied folder from {src_dir} to {dest_dir}\")\n        except Exception as e:\n            error_str = f\"Failed to copy {src_dir} to {dest_dir}: {str(e)}\"\n            self.logger.error(error_str)\n            raise Exception(error_str)\n\n\n    def _download_file_from_github(self, github_url: str, local_file: pathlib.Path):\n        \"\"\"\n        Downloads a file from a GitHub URL.\n\n        Args:\n            github_url: raw github link for the file to download\n            local_file: local path for the file to download\n        \"\"\"\n        try:\n            response = requests.get(github_url)\n            response.raise_for_status()\n            self.logger.debug(f\"Downloading file from {github_url} to {local_file.resolve()}\")\n\n            with open(local_file, \"wb\") as f:\n                # write the content of the response (file content) to the local file\n                f.write(response.content)\n        except Exception as e:\n            error_str = f\"Failed to download file {github_url} from GitHub to {local_file.resolve()}: {str(e)}\"\n            self.logger.error(error_str)\n            raise Exception(error_str)\n\n    def _download_github_release(\n        self, org_name: str, repo_name: str, release_tag: str, folders_to_extract: list[str], local_dir: pathlib.Path\n    ):\n        \"\"\"\n        download a release ZIP from a GitHub repository and extract specified sub-folders to a local directory.\n\n        Args:\n            org_name: github organization name\n            repo_name: github repository name\n            release_tag: release tag\n            folders_to_extract: list of sub-folders to extract from the ZIP file\n            local_dir: local directory to save extracted folders\n        \"\"\"\n        release_url = f\"https://github.com/{org_name}/{repo_name}/archive/refs/tags/{release_tag}.zip\"\n\n        try:\n            response = requests.get(release_url)\n            response.raise_for_status()\n\n            root_folder = f\"{repo_name}-{release_tag}\"\n            copied_folder = set([])\n\n            z = zipfile.ZipFile(io.BytesIO(response.content))\n            for file_info in z.infolist():\n                if not file_info.is_dir():\n                    if file_info.filename.startswith(root_folder):\n                        file_path = file_info.filename[len(root_folder) + 1 :]\n                    else:\n                        file_path = file_info.filename\n\n                    if any(\n                        file_path.startswith(folder) for folder in folders_to_extract\n                    ):\n                        # create the local path to extract the file\n                        extract_path = local_dir / file_path\n\n                        # ensure the directory exists\n                        os.makedirs(os.path.dirname(extract_path), exist_ok=True)\n\n                        # extract the file\n                        with z.open(file_info.filename) as source, open(\n                            extract_path, \"wb\"\n                        ) as target:\n                            target.write(source.read())\n\n                        copied_folder.add(file_path.split(\"/\")[0])\n\n            if copied_folder is not None:\n                self.logger.info(\n                    f\"Extracted folders {copied_folder} from GitHub release {release_url} and to directory {local_dir}\"\n                )\n\n        except Exception as e:\n            error_str = f\"Failed to download GitHub release {release_url}: {str(e)}\"\n            self.logger.error(error_str)\n            raise Exception(error_str)\n\n    def _copy_model_inputs(self):\n        \"\"\"\n        copy required model inputs into their respective directories.\n        \"\"\"\n        # Copy hwy and trn networks\n        self._copy_folder(\n            self.setup_config.INPUT_NETWORK_DIR / \"hwy\",\n            self.model_dir / \"inputs\" / \"hwy\"\n        )\n        self._copy_folder(\n            self.setup_config.INPUT_NETWORK_DIR / \"trn\",\n            self.model_dir / \"inputs\" / \"trn\"\n        )\n\n        # Copy popsyn and landuse inputs\n        self._copy_folder(\n            self.setup_config.INPUT_POPLU_DIR / \"popsyn\",\n            self.model_dir / \"inputs\" / \"popsyn\"\n        )\n        self._copy_folder(\n            self.setup_config.INPUT_POPLU_DIR /\"landuse\",\n            self.model_dir / \"inputs\" / \"landuse\"\n        )\n\n        # Copy nonres inputs\n        self._copy_folder(\n            self.setup_config.INPUT_NONRES_DIR / \"nonres\",\n            self.model_dir / \"inputs\" / \"nonres\"\n        )\n\n        # Copy warmstart demand if exists\n        warmstart_demand = self.setup_config.WARMSTART_FILES_DIR / \"demand_matrices\"\n        if warmstart_demand.exists():\n            self._copy_folder(\n                warmstart_demand, \n                self.model_dir / \"demand_matrices\"\n            )\n\n        # Copy warmstart skims\n        warmstart_skims = self.setup_config.WARMSTART_FILES_DIR / \"skim_matrices\"\n        if warmstart_skims.exists():\n            self._copy_folder(\n                warmstart_skims, \n                self.model_dir /\"skim_matrices\"\n            )\n\n    def _copy_emme_project_and_database(self):\n        \"\"\"\n        Copy EMME project from template project and then copy the emme networks databases based\n        on the EMME version found in the sys.path.\n        \"\"\"\n        # copy template emme project\n        self._copy_folder(\n            self.setup_config.EMME_TEMPLATE_PROJECT_DIR,\n            self.model_dir / \"emme_project\"\n        )\n\n        # get emme version from sys.path\n        sys_paths = sys.path\n        emme_path = None\n        for sys_path in sys_paths:\n            if sys_path.find(\"EMME\") &gt;=0 and sys_path.find(\"Bentley\") &gt;= 0:\n                emme_path = pathlib.Path(sys_path)\n                self.logger.info(f\"Found EMME path: {emme_path}\")\n                break\n        if emme_path is None:\n            error_str = f\"emme_path not found in sys.path {sys_paths}. Please run setup from EMME command prompt\"\n            self.logger.error(error_str)\n            raise ValueError(error_str) \n\n        EMME_VERSION = None\n        for part in emme_path.parts:\n            if part.startswith(\"EMME\"):\n                EMME_VERSION = part.replace(\" \",\"_\")  # replace spaces with underscores\n                self.logger.info(f\"Found EMME version in emme_path: {EMME_VERSION}\")\n                break\n\n        if EMME_VERSION is None:\n            error_str = f\"EMME version not found in emme_path {emme_path}. Please run setup from EMME command prompt\"\n            self.logger.error(error_str)\n            raise ValueError(error_str) \n\n        # copy versioned, zipped emme network database, falling back to unversioned if necessary\n        DATABASE_TO_SOURCE = {\n            'highway': 'emme_drive_network',\n            'transit': 'emme_taz_transit_network',\n            'active_north': 'emme_maz_active_modes_network_subregion_north',\n            'active_south': 'emme_maz_active_modes_network_subregion_south'\n        }\n        for network_type in DATABASE_TO_SOURCE.keys():\n            source_file = self.setup_config.INPUT_EMME_NETWORK_DIR / f\"Database_{network_type}_{EMME_VERSION}.zip\"\n            dest_dir = self.model_dir / \"emme_project\" / f\"Database_{network_type}\"\n            if source_file.exists():\n                # remove what was there before\n                shutil.rmtree(dest_dir)\n                # unzip the EMME version of the ntework\n                with zipfile.ZipFile(source_file, 'r') as zf:\n                    zf.extractall(dest_dir.parent)\n                self.logger.info(f\"Unzipped {source_file} to {dest_dir}\")\n\n            # otherwise, copy folder\n            else:\n                self._copy_folder(\n                    self.setup_config.INPUT_EMME_NETWORK_DIR / DATABASE_TO_SOURCE[network_type] / \"Database\",\n                    dest_dir\n                )\n\n    def _replace_in_file(self, filepath: pathlib.Path, regex_dict: dict[str, str]):\n        \"\"\"\n        Copies `filepath` to `filepath.original`\n        Opens `filepath.original` and reads it, writing a new version to `filepath`.\n        The new version is the same as the old, except that the regexes in the regex_dict keys\n        are replaced by the corresponding values.\n        \"\"\"\n        original_copy = pathlib.Path(f\"{str(filepath.absolute())}.original\")\n        shutil.move(filepath, original_copy)\n        self.logger.info(f\"_replace_in_file: Updating {filepath} via {original_copy}\")\n\n        # read the contents\n        myfile = open(original_copy, 'r')\n        file_contents = myfile.read()\n        myfile.close()\n\n        # do the regex subs\n        for pattern,newstr in regex_dict.items():\n            (file_contents, numsubs) = re.subn(pattern,newstr,file_contents,flags=re.IGNORECASE)\n            self.logger.info(f\"  Made {numsubs} sub for {newstr}\")\n\n           # Raise exception on failure\n            if numsubs &lt; 1:\n                error_str = f\"  SUBSITUTION FOR PATTERN {pattern} NOT MADE -- Fatal error\"\n                self.logger.fatal(error_str)\n                raise ValueError(error_str)\n\n        # write the result\n        myfile = open(filepath, 'w')\n        myfile.write(file_contents)\n        myfile.close()\n</code></pre>"},{"location":"api/#tm2py.SetupModel.__init__","title":"<code>__init__(config_file, model_dir)</code>","text":"<p>Initializes an instance of the SetupModel class.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The TOML file with the model setup attributes.</p> required <code>model_dir</code> <code>Path</code> <p>The directory which to setup for a TM2 model run.</p> required Source code in <code>tm2py/setup_model/setup.py</code> <pre><code>def __init__(self, config_file: pathlib.Path, model_dir: pathlib.Path):\n    \"\"\"Initializes an instance of the SetupModel class.\n\n    Args:\n        config_file (pathlib.Path): The TOML file with the model setup attributes.\n        model_dir (pathlib.Path): The directory which to setup for a TM2 model run.\n    \"\"\"\n    self.config_file = config_file\n    self.setup_config = SetupConfig(dict())\n    self.model_dir = model_dir\n</code></pre>"},{"location":"api/#tm2py.SetupModel.run_setup","title":"<code>run_setup()</code>","text":"<p>Does the work of setting up the model.  </p> <p>This step will do the following within the model directory.</p> <ol> <li>Intialize logging to write to <code>setup.log</code></li> <li>Copy the setup config file to <code>setupmodel_config.toml</code></li> <li>Create the required folder structure</li> <li>Copy the input from the locations specified:    a. hwy and trn networks    b. popsyn and landuse inputs    c. nonres inputs    d. warmstart demand matrices    e. warmstart skims</li> <li>Copy the Emme template project and Emme network databases     (based on the EMME version in sys.path)</li> <li>Download the travel model CTRAMP core code (runtime, uec) from the     travel-model-two repository</li> <li>Updates the IP address in the CTRAMP runtime properties files</li> <li>Creates <code>RunModel.py</code> for running the model</li> </ol> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the model directory to setup already exists.</p> Source code in <code>tm2py/setup_model/setup.py</code> <pre><code>def run_setup(self):\n    \"\"\"\n    Does the work of setting up the model.  \n\n    This step will do the following within the model directory.\n\n    1. Intialize logging to write to `setup.log`\n    2. Copy the setup config file to `setupmodel_config.toml`\n    3. Create the required folder structure\n    4. Copy the input from the locations specified:\n       a. hwy and trn networks\n       b. popsyn and landuse inputs\n       c. nonres inputs\n       d. warmstart demand matrices\n       e. warmstart skims\n    5. Copy the Emme template project and Emme network databases \n       (based on the EMME version in sys.path)\n    6. Download the travel model CTRAMP core code (runtime, uec) from the \n       [travel-model-two repository](https://github.com/BayAreaMetro/travel-model-two)\n    7. Updates the IP address in the CTRAMP runtime properties files\n    8. Creates `RunModel.py` for running the model\n\n    Raises:\n        FileExistsError: If the model directory to setup already exists.\n    \"\"\"\n    # Read setup setup_config\n    config_dict = self._load_toml()\n    self.setup_config = SetupConfig(config_dict)\n    self.setup_config.validate()\n\n    # if the directory already exists - error and quit\n    if self.model_dir.exists():\n        raise FileExistsError(f\"{self.model_dir.resolve()} already exists! Setup terminated.\")\n    else:\n        self.model_dir.mkdir()\n\n    # Initialize logging\n    log_file = self.model_dir / \"setup.log\"\n    self._setup_logging(log_file)\n\n    self.logger.info(f\"Starting process to setup MTC model in directory: {self.model_dir.resolve()}\")\n\n    # Save setup config into model dir as setupmodel_config.toml\n    shutil.copy(self.config_file, self.model_dir / \"setupmodel_config.toml\")\n    self.logger.info(f\"Copied {self.config_file} to {self.model_dir / 'setupmodel_config.toml'}\")\n\n    # List of folders to create\n    folders_to_create = [\n        \"acceptance\",\n        \"CTRAMP\",\n        \"ctramp_output\",\n        \"demand_matrices\",\n        \"demand_matrices/highway\",\n        \"demand_matrices/highway/air_passenger\",\n        \"demand_matrices/highway/household\",\n        \"demand_matrices/highway/maz_demand\",\n        \"demand_matrices/highway/internal_external\",\n        \"demand_matrices/highway/commercial\",\n        \"demand_matrices/transit\",\n        \"emme_project\",\n        \"inputs\",\n        \"logs\",\n        \"notebooks\",\n        \"output_summaries\",\n        \"skim_matrices\",\n        \"skim_matrices/highway\",\n        \"skim_matrices/transit\",\n        \"skim_matrices/non_motorized\",\n    ]\n\n    # Create folder structure\n    self._create_folder_structure(folders_to_create)\n\n    # Copy model inputs\n    self._copy_model_inputs()\n\n    # Copy emme project and database\n    self._copy_emme_project_and_database()\n\n    # Download toml SetupConfig files from GitHub\n    config_files_list = [\n        \"observed_data.toml\",\n        \"canonical_crosswalk.toml\",\n        \"model_config.toml\",\n        \"scenario_config.toml\",\n    ]\n    acceptance_config_files_list = [\n        \"observed_data.toml\",\n        \"canonical_crosswalk.toml\",\n    ]\n\n    for file in config_files_list:\n        github_url = self.setup_config.CONFIGS_GITHUB_PATH + \"/\" + file\n\n        local_file = self.model_dir / file\n\n        self._download_file_from_github(github_url, local_file)\n\n    # Fetch required folders from travel model two github release (zip file)\n    org = \"BayAreaMetro\"\n    repo = \"travel-model-two\"\n    tag = self.setup_config.TRAVEL_MODEL_TWO_RELEASE_TAG\n    folders_to_extract = [\"runtime\", \"uec\"]\n\n    self._download_github_release(\n        org,\n        repo,\n        tag,\n        folders_to_extract,\n        self.model_dir / \"CTRAMP\"\n    )\n\n    # Rename 'uec' folder to 'model'\n    old_path = self.model_dir / \"CTRAMP\" / \"uec\"\n    old_path.rename(self.model_dir / \"CTRAMP\" / \"model\")\n\n    self._create_run_model_batch()\n\n    # update IP addresses in config files\n    ips_here = socket.gethostbyname_ex(socket.gethostname())[-1]\n    self.logger.info(f\"Found the following IPs for this server: {ips_here}; using the first one: {ips_here[0]}\")\n\n    # add IP address to mtctm2.properties\n    self._replace_in_file(\n        self.model_dir / 'CTRAMP' / 'runtime' / 'mtctm2.properties', {\n            \"(\\nRunModel.MatrixServerAddress[ \\t]*=[ \\t]*)(\\S*)\": f\"\\g&lt;1&gt;{ips_here[0]}\",\n            \"(\\nRunModel.HouseholdServerAddress[ \\t]*=[ \\t]*)(\\S*)\": f\"\\g&lt;1&gt;{ips_here[0]}\"\n        }\n    )\n    # add IP address to logsum.properties\n    self._replace_in_file(\n        self.model_dir / 'CTRAMP' / 'runtime' / 'logsum.properties', {\n            \"(\\nRunModel.MatrixServerAddress[ \\t]*=[ \\t]*)(\\S*)\": f\"\\g&lt;1&gt;{ips_here[0]}\",\n            \"(\\nRunModel.HouseholdServerAddress[ \\t]*=[ \\t]*)(\\S*)\": f\"\\g&lt;1&gt;{ips_here[0]}\"\n        }\n    )\n    self.logger.info(f\"Setup process completed successfully!\")\n\n    # Close logging\n    logging.shutdown()\n</code></pre>"},{"location":"api/#controller","title":"Controller","text":"<p>RunController - model operation controller.</p> <p>Main interface to start a TM2PY model run. Provide one or more configuration files in .toml format (by convention a scenario.toml and a model.toml)</p> <p>Typical usage example:   from tm2py.controller import RunController   controller = RunController(     [\u201cscenario.toml\u201d, \u201cmodel.toml\u201d])   controller.run()</p> <p>Or from the command-line:   <code>python &lt;path&gt;/tm2py/tm2py/controller.py \u2013s scenario.toml \u2013m model.toml</code></p>"},{"location":"api/#tm2py.controller.RunController","title":"<code>RunController</code>","text":"<p>Main operational interface for model runs.</p> <p>Provide one or more config files in TOML (*.toml) format, and a run directory. If the run directory is not provided the root directory of the first config_file is used.</p> Properties Internal properties Source code in <code>tm2py/controller.py</code> <pre><code>class RunController:\n    \"\"\"Main operational interface for model runs.\n\n    Provide one or more config files in TOML (*.toml) format, and a run directory.\n    If the run directory is not provided the root directory of the first config_file is used.\n\n    Properties:\n        config: root Configuration object\n        logger: logger object\n        top_sheet: placeholder for top sheet functionality (not implemented yet)\n        trace: placeholder for trace functionality (not implemented yet)\n        run_dir: root run directory for the model run\n        iteration: current running (or last started) iteration\n        component: current running (or last started) Component object\n        emme_manager: EmmeManager object for centralized Emme-related (highway and\n            transit assignments and skims) utilities.\n        complete_components: list of components which have completed, tuple of\n            (iteration, name, Component object)\n\n    Internal properties:\n        _emme_manager: EmmeManager object, cached on first access\n        _iteration: current iteration\n        _component: current running / last run Component\n        _component_name: name of the current / last run component\n        _queued_components: list of iteration, name, Component\n    \"\"\"\n\n    def __init__(\n        self,\n        config_file: Union[Collection[Union[str, Path]], str, Path] = None,\n        run_dir: Union[Path, str] = None,\n        run_components: Collection[str] = component_cls_map.keys(),\n    ):\n        \"\"\"Constructor for RunController class.\n\n        Args:\n            config_file: Single or list of config file locations as strings or Path objects.\n                Defaults to None.\n            run_dir: Model run directory as a Path object or string. If not provided, defaults\n                to the directory of the first config_file.\n            run_components: List of component names to run. Defaults to all components.\n        \"\"\"\n        if run_dir is None:\n            run_dir = Path(os.path.abspath(os.path.dirname(config_file[0])))\n\n        self._run_dir = Path(run_dir)\n\n        self.config = Configuration.load_toml(config_file)\n        self.has_emme: bool = emme_context()\n        self.top_sheet = None\n        self.trace = None\n        self.completed_components = []\n\n        self._validated_components = set()\n        self._emme_manager = None\n        self._iteration = None\n        self._component = None\n        self._component_name = None\n        self._queued_components = deque()\n\n        # create logger before creating components so we can log if issues arise in the component creation\n        self.logger = Logger(self)\n        print(f\"initialize_log({self.runtime_log_file, self.runtime_log_headers, self.runtime_log_col_width})\")\n        initialize_log(\n            self.runtime_log_file, self.runtime_log_headers, self.runtime_log_col_width\n        )\n\n        # mapping from defined names referenced in config to Component objects\n        self._component_map = {\n            k: v(self) for k, v in component_cls_map.items() if k in run_components\n        }\n\n        self.logger.set_emme_manager(self.emme_manager)\n        self._queue_components(run_components=run_components)\n\n\n\n    def __repr__(self):\n        \"\"\"Legible representation.\"\"\"\n        _str = f\"\"\"RunController\n            Run Directory: {self.run_dir}\n            Iteration: {self.iteration} of {self.run_iterations}\n            Component: {self.component_name}\n            Completed: {self.completed_components}\n            Queued: {self._queued_components}\"\"\"\n        return _str\n\n    @property\n    def run_dir(self) -&gt; Path:\n        \"\"\"The root run directory of the model run.\"\"\"\n        return self._run_dir\n\n    @property\n    def run_iterations(self) -&gt; List[int]:\n        \"\"\"List of iterations for this model run.\"\"\"\n        return range(\n            max(1, self.config.run.start_iteration), self.config.run.end_iteration + 1\n        )\n\n    @property\n    def time_period_names(self) -&gt; List[str]:\n        \"\"\"Return input time_period name or names and return list of time_period names.\n\n        Implemented here for easy access for all components.\n\n        Returns: list of uppercased string names of time periods\n        \"\"\"\n        return [time.name.upper() for time in self.config.time_periods]\n\n    @property\n    def time_period_durations(self) -&gt; dict:\n        \"\"\"Return mapping of time periods to durations in hours.\"\"\"\n        return dict((p.name, p.length_hours) for p in self.config.time_periods)\n\n    @property\n    def congested_transit_assn_max_iteration(self) -&gt; dict:\n        \"\"\"Return mapping of time periods to max iteration in congested transit assignment.\"\"\"\n        return dict(\n            (p.name, p.congested_transit_assn_max_iteration)\n            for p in self.config.time_periods\n        )\n\n    @property\n    def num_processors(self) -&gt; int:\n        return self.emme_manager.num_processors\n\n    @property\n    def num_processors_transit_skim(self) -&gt; int:\n        return self.emme_manager.num_processors_transit_skim\n\n    @property\n    def iteration(self) -&gt; int:\n        \"\"\"Current iteration of model run.\"\"\"\n        return self._iteration\n\n    @property\n    def component_name(self) -&gt; str:\n        \"\"\"Name of current component of model run.\"\"\"\n        return self._component_name\n\n    @property\n    def iter_component(self) -&gt; Tuple[int, str]:\n        \"\"\"Tuple of the current iteration and component name.\"\"\"\n        return self._iteration, self._component_name\n\n    def component(self) -&gt; Component:\n        \"\"\"Current component of model.\"\"\"\n        return self._component\n\n    @property\n    def emme_manager(self) -&gt; EmmeManager:\n        \"\"\"Cached Emme Manager object.\"\"\"\n        if self._emme_manager is None:\n            if self.has_emme:\n                self._emme_manager = EmmeManager(self, self.config.emme)\n            else:\n                self.logger.log(\"Emme not found, skipping Emme-related components\")\n                # TODO: All of the Emme-related components need to be handled \"in place\" rather\n                # than skippping using a Mock\n                from unittest.mock import MagicMock\n\n                self._emme_manager = MagicMock()\n        return self._emme_manager\n\n    def get_abs_path(self, rel_path: Union[Path, str]) -&gt; Path:\n        \"\"\"Get the absolute path from the root run directory given a relative path.\"\"\"\n        if not isinstance(rel_path, Path):\n            rel_path = Path(rel_path)\n        return Path(os.path.join(self.run_dir, rel_path))\n\n    @property\n    def runtime_log_file(self):\n        return self.get_abs_path(\"logs/runtime_log.txt\").__str__()\n\n    @property\n    def runtime_log_headers(self):\n        return [\"LOOP\", \"STEP\", \"START_TIME\", \"END_TIME\", \"STEP_TIME (MINS)\"]\n\n    @property\n    def runtime_log_col_width(self):\n        return [8, 30, 25, 25, 10]\n\n    def run(self):\n        \"\"\"Main interface to run model.\n\n        Iterates through the self._queued_components and runs them.\n        \"\"\"\n        self._iteration = None\n\n        while self._queued_components:\n            self.run_next()\n\n    def run_next(self):\n        \"\"\"Run next component in the queue.\"\"\"\n        if not self._queued_components:\n            raise ValueError(\"No components in queue\")\n        iteration, name, component = self._queued_components.popleft()\n        if self._iteration != iteration:\n            self.logger.log(f\"Start iteration {iteration}\")\n        self._iteration = iteration\n\n        self.logger.debug(f\" Running iteration {iteration} component {name}\")\n        component_start_time = datetime.now()\n\n        # check wamrstart files exist\n        if iteration == 0:\n            if self.config.warmstart.warmstart:\n                if self.config.warmstart.use_warmstart_demand:\n                    for source in [\n                        \"household\",\n                        \"truck\",\n                        \"air_passenger\",\n                        \"internal_external\",\n                    ]:\n                        highway_demand_file = str(\n                            self.get_abs_path(self.config[source].highway_demand_file)\n                        )\n                        for time in self.config[\"time_periods\"]:\n                            path = highway_demand_file.format(\n                                period=time.name, iter=iteration\n                            )\n                            assert os.path.isfile(\n                                path\n                            ), f\"{path} required as warmstart demand does not exist\"\n                elif self.config.warmstart.use_warmstart_skim:\n                    highway_skim_file = str(\n                        self.get_abs_path(\n                            self.config[\"highway\"].output_skim_path\n                            / self.config[\"highway\"].output_skim_filename_tmpl\n                        )\n                    )\n                    for time in self.config[\"time_periods\"]:\n                        path = highway_skim_file.format(time_period=time.name)\n                        assert os.path.isfile(\n                            path\n                        ), f\"{path} required as warmstart skim does not exist\"\n                    transit_skim_file = str(\n                        self.get_abs_path(\n                            self.config[\"transit\"].output_skim_path\n                            / self.config[\"transit\"].output_skim_filename_tmpl\n                        )\n                    )\n                    for time in self.config[\"time_periods\"]:\n                        for tclass in self.config[\"transit\"][\"classes\"]:\n                            path = transit_skim_file.format(\n                                time_period=time.name, tclass=tclass.name\n                            )\n                            assert os.path.isfile(\n                                path\n                            ), f\"{path} required as warmstart skim does not exist\"\n\n        self._component = component\n        try:\n            component.run()\n            component_end_time = datetime.now()\n            add_run_log(\n                iteration,\n                name,\n                component_start_time,\n                component_end_time,\n                self.runtime_log_file,\n                self.runtime_log_col_width,\n            )\n        except:\n            # re-insert failed component on error\n            self._queued_components.insert(0, (iteration, name, component))\n            raise\n        self.completed_components.append((iteration, name, component))\n\n    def _queue_components(self, run_components: Collection[str] = None):\n        \"\"\"Add components per iteration to queue according to input Config.\n\n        Args:\n            run_components: if provided, only run these components\n        \"\"\"\n        try:\n            assert not self._queued_components\n        except AssertionError:\n            print(\"Components already queued, returning without re-queuing.\")\n            return\n\n        _initial_components = self.config.run.initial_components\n        _global_iter_components = self.config.run.global_iteration_components\n        _final_components = self.config.run.final_components\n\n        if run_components is not None:\n            _initial_components = [\n                c for c in _initial_components if c in run_components\n            ]\n            _global_iter_components = [\n                c for c in _global_iter_components if c in run_components\n            ]\n            _final_components = [c for c in _final_components if c in run_components]\n\n        if self.config.run.start_iteration == 0:\n            if self.config.warmstart.warmstart:\n                if self.config.warmstart.use_warmstart_skim:\n                    if \"highway\" in _initial_components:\n                        _initial_components.remove(\"highway\")\n                    if \"transit_assign\" in _initial_components:\n                        _initial_components.remove(\"transit_assign\")\n                    if \"transit_skim\" in _initial_components:\n                        _initial_components.remove(\"transit_skim\")\n            for _c_name in _initial_components:\n                self._add_component_to_queue(0, _c_name)\n\n        # Queue components which are run for each iteration\n\n        _iteration_x_components = itertools.product(\n            self.run_iterations, _global_iter_components\n        )\n\n        for _iteration, _c_name in _iteration_x_components:\n            self._add_component_to_queue(_iteration, _c_name)\n\n        # Queue components which are run after final iteration\n        _finalizer_iteration = self.config.run.end_iteration + 1\n\n        for _c_name in _final_components:\n            self._add_component_to_queue(_finalizer_iteration, _c_name)\n\n        # If start_component specified, remove things before its first occurance\n        if self.config.run.start_component:\n            _queued_c_names = [c.name for c in self._queued_components]\n            if self.config.run.start_component not in _queued_c_names:\n                raise ValueError(\n                    f\"Start component {self.config.run.start_component} not found in queued \\\n                    components {_queued_c_names}\"\n                )\n            _start_c_index = _queued_c_names.index(self.config.run.start_component)\n            self._queued_components = self._queued_components[_start_c_index:]\n\n        print(\"RUN COMPOMENTS:\")\n        for _queued_component in self._queued_components:\n            print(f\"Global iteration {_queued_component[0]}, {_queued_component[1]}\")\n\n    def _add_component_to_queue(self, iteration: int, component_name: str):\n        \"\"\"Add component to queue (self._queued_components), first validating its inputs.\n\n        Args:\n            iteration (int): iteration to add component to.\n            component_name (Component): Component to add to queue.\n        \"\"\"\n        _component = self._component_map[component_name]\n        if component_name not in self._validated_components:\n            _component.validate_inputs()\n            self._validated_components.add(component_name)\n        self._queued_components.append((iteration, component_name, _component))\n</code></pre>"},{"location":"api/#tm2py.controller.RunController.component_name","title":"<code>component_name: str</code>  <code>property</code>","text":"<p>Name of current component of model run.</p>"},{"location":"api/#tm2py.controller.RunController.congested_transit_assn_max_iteration","title":"<code>congested_transit_assn_max_iteration: dict</code>  <code>property</code>","text":"<p>Return mapping of time periods to max iteration in congested transit assignment.</p>"},{"location":"api/#tm2py.controller.RunController.emme_manager","title":"<code>emme_manager: EmmeManager</code>  <code>property</code>","text":"<p>Cached Emme Manager object.</p>"},{"location":"api/#tm2py.controller.RunController.iter_component","title":"<code>iter_component: Tuple[int, str]</code>  <code>property</code>","text":"<p>Tuple of the current iteration and component name.</p>"},{"location":"api/#tm2py.controller.RunController.iteration","title":"<code>iteration: int</code>  <code>property</code>","text":"<p>Current iteration of model run.</p>"},{"location":"api/#tm2py.controller.RunController.run_dir","title":"<code>run_dir: Path</code>  <code>property</code>","text":"<p>The root run directory of the model run.</p>"},{"location":"api/#tm2py.controller.RunController.run_iterations","title":"<code>run_iterations: List[int]</code>  <code>property</code>","text":"<p>List of iterations for this model run.</p>"},{"location":"api/#tm2py.controller.RunController.time_period_durations","title":"<code>time_period_durations: dict</code>  <code>property</code>","text":"<p>Return mapping of time periods to durations in hours.</p>"},{"location":"api/#tm2py.controller.RunController.time_period_names","title":"<code>time_period_names: List[str]</code>  <code>property</code>","text":"<p>Return input time_period name or names and return list of time_period names.</p> <p>Implemented here for easy access for all components.</p> <p>Returns: list of uppercased string names of time periods</p>"},{"location":"api/#tm2py.controller.RunController.__init__","title":"<code>__init__(config_file=None, run_dir=None, run_components=component_cls_map.keys())</code>","text":"<p>Constructor for RunController class.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Union[Collection[Union[str, Path]], str, Path]</code> <p>Single or list of config file locations as strings or Path objects. Defaults to None.</p> <code>None</code> <code>run_dir</code> <code>Union[Path, str]</code> <p>Model run directory as a Path object or string. If not provided, defaults to the directory of the first config_file.</p> <code>None</code> <code>run_components</code> <code>Collection[str]</code> <p>List of component names to run. Defaults to all components.</p> <code>keys()</code> Source code in <code>tm2py/controller.py</code> <pre><code>def __init__(\n    self,\n    config_file: Union[Collection[Union[str, Path]], str, Path] = None,\n    run_dir: Union[Path, str] = None,\n    run_components: Collection[str] = component_cls_map.keys(),\n):\n    \"\"\"Constructor for RunController class.\n\n    Args:\n        config_file: Single or list of config file locations as strings or Path objects.\n            Defaults to None.\n        run_dir: Model run directory as a Path object or string. If not provided, defaults\n            to the directory of the first config_file.\n        run_components: List of component names to run. Defaults to all components.\n    \"\"\"\n    if run_dir is None:\n        run_dir = Path(os.path.abspath(os.path.dirname(config_file[0])))\n\n    self._run_dir = Path(run_dir)\n\n    self.config = Configuration.load_toml(config_file)\n    self.has_emme: bool = emme_context()\n    self.top_sheet = None\n    self.trace = None\n    self.completed_components = []\n\n    self._validated_components = set()\n    self._emme_manager = None\n    self._iteration = None\n    self._component = None\n    self._component_name = None\n    self._queued_components = deque()\n\n    # create logger before creating components so we can log if issues arise in the component creation\n    self.logger = Logger(self)\n    print(f\"initialize_log({self.runtime_log_file, self.runtime_log_headers, self.runtime_log_col_width})\")\n    initialize_log(\n        self.runtime_log_file, self.runtime_log_headers, self.runtime_log_col_width\n    )\n\n    # mapping from defined names referenced in config to Component objects\n    self._component_map = {\n        k: v(self) for k, v in component_cls_map.items() if k in run_components\n    }\n\n    self.logger.set_emme_manager(self.emme_manager)\n    self._queue_components(run_components=run_components)\n</code></pre>"},{"location":"api/#tm2py.controller.RunController.__repr__","title":"<code>__repr__()</code>","text":"<p>Legible representation.</p> Source code in <code>tm2py/controller.py</code> <pre><code>def __repr__(self):\n    \"\"\"Legible representation.\"\"\"\n    _str = f\"\"\"RunController\n        Run Directory: {self.run_dir}\n        Iteration: {self.iteration} of {self.run_iterations}\n        Component: {self.component_name}\n        Completed: {self.completed_components}\n        Queued: {self._queued_components}\"\"\"\n    return _str\n</code></pre>"},{"location":"api/#tm2py.controller.RunController.component","title":"<code>component()</code>","text":"<p>Current component of model.</p> Source code in <code>tm2py/controller.py</code> <pre><code>def component(self) -&gt; Component:\n    \"\"\"Current component of model.\"\"\"\n    return self._component\n</code></pre>"},{"location":"api/#tm2py.controller.RunController.get_abs_path","title":"<code>get_abs_path(rel_path)</code>","text":"<p>Get the absolute path from the root run directory given a relative path.</p> Source code in <code>tm2py/controller.py</code> <pre><code>def get_abs_path(self, rel_path: Union[Path, str]) -&gt; Path:\n    \"\"\"Get the absolute path from the root run directory given a relative path.\"\"\"\n    if not isinstance(rel_path, Path):\n        rel_path = Path(rel_path)\n    return Path(os.path.join(self.run_dir, rel_path))\n</code></pre>"},{"location":"api/#tm2py.controller.RunController.run","title":"<code>run()</code>","text":"<p>Main interface to run model.</p> <p>Iterates through the self._queued_components and runs them.</p> Source code in <code>tm2py/controller.py</code> <pre><code>def run(self):\n    \"\"\"Main interface to run model.\n\n    Iterates through the self._queued_components and runs them.\n    \"\"\"\n    self._iteration = None\n\n    while self._queued_components:\n        self.run_next()\n</code></pre>"},{"location":"api/#tm2py.controller.RunController.run_next","title":"<code>run_next()</code>","text":"<p>Run next component in the queue.</p> Source code in <code>tm2py/controller.py</code> <pre><code>def run_next(self):\n    \"\"\"Run next component in the queue.\"\"\"\n    if not self._queued_components:\n        raise ValueError(\"No components in queue\")\n    iteration, name, component = self._queued_components.popleft()\n    if self._iteration != iteration:\n        self.logger.log(f\"Start iteration {iteration}\")\n    self._iteration = iteration\n\n    self.logger.debug(f\" Running iteration {iteration} component {name}\")\n    component_start_time = datetime.now()\n\n    # check wamrstart files exist\n    if iteration == 0:\n        if self.config.warmstart.warmstart:\n            if self.config.warmstart.use_warmstart_demand:\n                for source in [\n                    \"household\",\n                    \"truck\",\n                    \"air_passenger\",\n                    \"internal_external\",\n                ]:\n                    highway_demand_file = str(\n                        self.get_abs_path(self.config[source].highway_demand_file)\n                    )\n                    for time in self.config[\"time_periods\"]:\n                        path = highway_demand_file.format(\n                            period=time.name, iter=iteration\n                        )\n                        assert os.path.isfile(\n                            path\n                        ), f\"{path} required as warmstart demand does not exist\"\n            elif self.config.warmstart.use_warmstart_skim:\n                highway_skim_file = str(\n                    self.get_abs_path(\n                        self.config[\"highway\"].output_skim_path\n                        / self.config[\"highway\"].output_skim_filename_tmpl\n                    )\n                )\n                for time in self.config[\"time_periods\"]:\n                    path = highway_skim_file.format(time_period=time.name)\n                    assert os.path.isfile(\n                        path\n                    ), f\"{path} required as warmstart skim does not exist\"\n                transit_skim_file = str(\n                    self.get_abs_path(\n                        self.config[\"transit\"].output_skim_path\n                        / self.config[\"transit\"].output_skim_filename_tmpl\n                    )\n                )\n                for time in self.config[\"time_periods\"]:\n                    for tclass in self.config[\"transit\"][\"classes\"]:\n                        path = transit_skim_file.format(\n                            time_period=time.name, tclass=tclass.name\n                        )\n                        assert os.path.isfile(\n                            path\n                        ), f\"{path} required as warmstart skim does not exist\"\n\n    self._component = component\n    try:\n        component.run()\n        component_end_time = datetime.now()\n        add_run_log(\n            iteration,\n            name,\n            component_start_time,\n            component_end_time,\n            self.runtime_log_file,\n            self.runtime_log_col_width,\n        )\n    except:\n        # re-insert failed component on error\n        self._queued_components.insert(0, (iteration, name, component))\n        raise\n    self.completed_components.append((iteration, name, component))\n</code></pre>"},{"location":"api/#configuration","title":"Configuration","text":"<p>Config implementation and schema.</p> <p>Configurations for each component are listed with those components</p>"},{"location":"api/#tm2py.config.ActiveModeShortestPathSkimConfig","title":"<code>ActiveModeShortestPathSkimConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Active mode skim entry.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass ActiveModeShortestPathSkimConfig(ConfigItem):\n    \"\"\"Active mode skim entry.\"\"\"\n\n    mode: str\n    roots: str\n    leaves: str\n    output: str\n    max_dist_miles: float = None\n</code></pre>"},{"location":"api/#tm2py.config.ActiveModesConfig","title":"<code>ActiveModesConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Active Mode skim parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass ActiveModesConfig(ConfigItem):\n    \"\"\"Active Mode skim parameters.\"\"\"\n\n    emme_scenario_id: int\n    shortest_path_skims: Tuple[ActiveModeShortestPathSkimConfig, ...]\n</code></pre>"},{"location":"api/#tm2py.config.AirPassengerConfig","title":"<code>AirPassengerConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Air passenger model parameters.</p> <p>Properties</p> <p>highway_demand_file: output OMX file input_demand_folder: location to find the input demand csvs input_demand_filename_tmpl: filename template for input demand. Should have     {year}, {direction} and {airport} variables and end in \u2018.csv\u2019 reference_start_year: base start year for input demand tables     used to calculate the linear interpolation, as well as     in the file name template {year}{direction}{airport}.csv reference_end_year: end year for input demand tables     used to calculate the linear interpolation, as well as     in the file name template {year}{direction}{airport}.csv airport_names: list of one or more airport names / codes as used in     the input file names demand_aggregation: specification of aggregation of by-access mode     demand to highway class demand</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass AirPassengerConfig(ConfigItem):\n    \"\"\"Air passenger model parameters.\n\n    Properties\n\n    highway_demand_file: output OMX file\n    input_demand_folder: location to find the input demand csvs\n    input_demand_filename_tmpl: filename template for input demand. Should have\n        {year}, {direction} and {airport} variables and end in '.csv'\n    reference_start_year: base start year for input demand tables\n        used to calculate the linear interpolation, as well as\n        in the file name template {year}_{direction}{airport}.csv\n    reference_end_year: end year for input demand tables\n        used to calculate the linear interpolation, as well as\n        in the file name template {year}_{direction}{airport}.csv\n    airport_names: list of one or more airport names / codes as used in\n        the input file names\n    demand_aggregation: specification of aggregation of by-access mode\n        demand to highway class demand\n    \"\"\"\n\n    output_trip_table_directory: pathlib.Path\n    outfile_trip_table_tmp: str\n    input_demand_folder: pathlib.Path\n    input_demand_filename_tmpl: str\n    highway_demand_file: str\n    reference_start_year: str\n    reference_end_year: str\n    airport_names: List[str]\n    demand_aggregation: List[AirPassengerDemandAggregationConfig]\n\n    @validator(\"input_demand_filename_tmpl\")\n    def valid_input_demand_filename_tmpl(cls, value):\n        \"\"\"Validate skim matrix template has correct {}.\"\"\"\n\n        assert (\n            \"{year}\" in value\n        ), \"-&gt; 'output_skim_matrixname_tmpl must have {year}, found {value}.\"\n        assert (\n            \"{direction}\" in value\n        ), \"-&gt; 'output_skim_matrixname_tmpl must have {direction}, found {value}.\"\n        assert (\n            \"{airport}\" in value\n        ), \"-&gt; 'output_skim_matrixname_tmpl must have {airport}, found {value}.\"\n        return value\n</code></pre>"},{"location":"api/#tm2py.config.AirPassengerConfig.valid_input_demand_filename_tmpl","title":"<code>valid_input_demand_filename_tmpl(value)</code>","text":"<p>Validate skim matrix template has correct {}.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"input_demand_filename_tmpl\")\ndef valid_input_demand_filename_tmpl(cls, value):\n    \"\"\"Validate skim matrix template has correct {}.\"\"\"\n\n    assert (\n        \"{year}\" in value\n    ), \"-&gt; 'output_skim_matrixname_tmpl must have {year}, found {value}.\"\n    assert (\n        \"{direction}\" in value\n    ), \"-&gt; 'output_skim_matrixname_tmpl must have {direction}, found {value}.\"\n    assert (\n        \"{airport}\" in value\n    ), \"-&gt; 'output_skim_matrixname_tmpl must have {airport}, found {value}.\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.AirPassengerDemandAggregationConfig","title":"<code>AirPassengerDemandAggregationConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Air passenger demand aggregation input parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass AirPassengerDemandAggregationConfig(ConfigItem):\n    \"\"\"Air passenger demand aggregation input parameters.\n\n    Properties:\n        name: (src_group_name) name used for the class group in the input columns\n            for the trip tables,\n        mode: (result_class_name) name used in the output OMX matrix names, note\n            that this should match the expected naming convention in the\n            HighwayClassDemandConfig name(s)\n        access_modes: list of names used for the access modes in the input\n            columns for the trip tables\n    \"\"\"\n\n    name: str\n    mode: str\n    access_modes: Tuple[str, ...]\n</code></pre>"},{"location":"api/#tm2py.config.AssignmentStoppingCriteriaConfig","title":"<code>AssignmentStoppingCriteriaConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Assignment stop configuration parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass AssignmentStoppingCriteriaConfig(ConfigItem):\n    \"Assignment stop configuration parameters.\"\n\n    max_iterations: int\n    relative_difference: float\n    percent_segments_over_capacity: float\n</code></pre>"},{"location":"api/#tm2py.config.CcrWeightsConfig","title":"<code>CcrWeightsConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Weights for CCR Configuration.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass CcrWeightsConfig(ConfigItem):\n    \"Weights for CCR Configuration.\"\n\n    min_seat: float = Field(default=1.0)\n    max_seat: float = Field(default=1.4)\n    power_seat: float = Field(default=2.2)\n    min_stand: float = Field(default=1.4)\n    max_stand: float = Field(default=1.6)\n    power_stand: float = Field(default=3.4)\n</code></pre>"},{"location":"api/#tm2py.config.ChoiceClassConfig","title":"<code>ChoiceClassConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Choice class parameters.</p> Properties <p>The end value in the utility equation for class c and property p is:</p> <p>utility[p].coeff *    classes[c].property_factor[p] *    sum(skim(classes[c].skim_mode,skim_p) for skim_p in property_to_skim[p])</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass ChoiceClassConfig(ConfigItem):\n    \"\"\"Choice class parameters.\n\n    Properties:\n        property_to_skim_toll: Maps a property in the utility equation with a list of skim\n            properties. If more than one skim property is listed, they will be summed together\n            (e.g. cost if the sum of bridge toll and value toll). This defaults to a value in the\n            code.\n        property_to_skim_notoll: Maps a property in the utility equation with a list of skim\n            properties for no toll choice.If more than one skim property is listed, they will\n            be summed together  (e.g. cost if the sum of bridge toll and value toll). This\n            defaults to a value in the code.\n        property_factors: This will scale the property for this class. e.g. a shared ride cost\n            could be applied a factor assuming that the cost is shared among individuals.\n\n    The end value in the utility equation for class c and property p is:\n\n       utility[p].coeff *\n       classes[c].property_factor[p] *\n       sum(skim(classes[c].skim_mode,skim_p) for skim_p in property_to_skim[p])\n    \"\"\"\n\n    name: str\n    skim_mode: Optional[str] = Field(default=\"da\")\n    veh_group_name: Optional[str] = Field(default=\"\")\n    property_factors: Optional[List[CoefficientConfig]] = Field(default=None)\n</code></pre>"},{"location":"api/#tm2py.config.ClassDemandConfig","title":"<code>ClassDemandConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Input source for demand for highway or transit assignment class.</p> <p>Used to specify where to find related demand file for this highway or transit class.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass ClassDemandConfig(ConfigItem):\n    \"\"\"Input source for demand for highway or transit assignment class.\n\n    Used to specify where to find related demand file for this\n    highway or transit class.\n\n    Properties:\n        source: reference name of the component section for the\n                source \"highway_demand_file\" (for a highway class)\n                or \"transit_demand_file\" (for a transit class), one of:\n                \"household\", \"air_passenger\", \"internal_external\", \"truck\"\n        name: name of matrix in the OMX file, can include \"{period}\"\n                placeholder\n        factor: optional, multiplicative factor to generate PCEs from\n                trucks or convert person-trips to vehicle-trips for HOVs\n    \"\"\"\n\n    name: str = Field()\n    source: str = Literal[\"household\", \"air_passenger\", \"internal_external\", \"truck\"]\n    factor: float = Field(default=1.0, gt=0)\n</code></pre>"},{"location":"api/#tm2py.config.CoefficientConfig","title":"<code>CoefficientConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Coefficient and properties to be used in utility or regression.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass CoefficientConfig(ConfigItem):\n    \"\"\"Coefficient and properties to be used in utility or regression.\"\"\"\n\n    property: str\n    coeff: Optional[float] = Field(default=None)\n</code></pre>"},{"location":"api/#tm2py.config.ConfigItem","title":"<code>ConfigItem</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class to add partial dict-like interface to tm2py model configuration.</p> <p>Allow use of .items() [\u201cX\u201d] and .get(\u201cX\u201d) .to_dict() from configuration.</p> <p>Not to be constructed directly. To be used a mixin for dataclasses representing config schema. Do not use \u201cget\u201d \u201cto_dict\u201d, or \u201citems\u201d for key names.</p> Source code in <code>tm2py/config.py</code> <pre><code>class ConfigItem(ABC):\n    \"\"\"Base class to add partial dict-like interface to tm2py model configuration.\n\n    Allow use of .items() [\"X\"] and .get(\"X\") .to_dict() from configuration.\n\n    Not to be constructed directly. To be used a mixin for dataclasses\n    representing config schema.\n    Do not use \"get\" \"to_dict\", or \"items\" for key names.\n    \"\"\"\n\n    def __getitem__(self, key):\n        \"\"\"Get item for config. D[key] -&gt; D[key] if key in D, else raise KeyError.\"\"\"\n        return getattr(self, key)\n\n    def items(self):\n        \"\"\"The sub-config objects in config.\"\"\"\n        return self.__dict__.items()\n\n    def get(self, key, default=None):\n        \"\"\"Return the value for key if key is in the dictionary, else default.\"\"\"\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"api/#tm2py.config.ConfigItem.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get item for config. D[key] -&gt; D[key] if key in D, else raise KeyError.</p> Source code in <code>tm2py/config.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"Get item for config. D[key] -&gt; D[key] if key in D, else raise KeyError.\"\"\"\n    return getattr(self, key)\n</code></pre>"},{"location":"api/#tm2py.config.ConfigItem.get","title":"<code>get(key, default=None)</code>","text":"<p>Return the value for key if key is in the dictionary, else default.</p> Source code in <code>tm2py/config.py</code> <pre><code>def get(self, key, default=None):\n    \"\"\"Return the value for key if key is in the dictionary, else default.\"\"\"\n    return self.__dict__.get(key, default)\n</code></pre>"},{"location":"api/#tm2py.config.ConfigItem.items","title":"<code>items()</code>","text":"<p>The sub-config objects in config.</p> Source code in <code>tm2py/config.py</code> <pre><code>def items(self):\n    \"\"\"The sub-config objects in config.\"\"\"\n    return self.__dict__.items()\n</code></pre>"},{"location":"api/#tm2py.config.Configuration","title":"<code>Configuration</code>","text":"<p>               Bases: <code>ConfigItem</code></p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass Configuration(ConfigItem):\n    \"\"\"Configuration: root of the model configuration.\"\"\"\n\n    scenario: ScenarioConfig\n    run: RunConfig\n    warmstart: WarmStartConfig\n    time_periods: Tuple[TimePeriodConfig, ...]\n    household: HouseholdConfig\n    air_passenger: AirPassengerConfig\n    internal_external: InternalExternalConfig\n    truck: TruckConfig\n    active_modes: ActiveModesConfig\n    highway: HighwayConfig\n    transit: TransitConfig\n    post_processor: PostProcessorConfig\n    emme: EmmeConfig\n    logging: Optional[LoggingConfig] = Field(default_factory=LoggingConfig)\n\n    @classmethod\n    def load_toml(\n        cls,\n        toml_path: Union[List[Union[str, pathlib.Path]], str, pathlib.Path],\n    ) -&gt; \"Configuration\":\n        \"\"\"Load configuration from .toml files(s).\n\n        Normally the config is split into a scenario_config.toml file and a\n        model_config.toml file.\n\n        Args:\n            toml_path: a valid system path string or Path object to a TOML format config file or\n                list of paths of path objects to a set of TOML files.\n\n        Returns:\n            A Configuration object\n        \"\"\"\n        if not isinstance(toml_path, List):\n            toml_path = [toml_path]\n        toml_path = list(map(pathlib.Path, toml_path))\n\n        data = _load_toml(toml_path[0])\n        for path_item in toml_path[1:]:\n            _merge_dicts(data, _load_toml(path_item))\n        return cls(**data)\n\n    @validator(\"highway\")\n    def maz_skim_period_exists(cls, value, values):\n        \"\"\"Validate highway.maz_to_maz.skim_period refers to a valid period.\"\"\"\n        if \"time_periods\" in values:\n            time_period_names = set(time.name for time in values[\"time_periods\"])\n            assert (\n                value.maz_to_maz.skim_period in time_period_names\n            ), \"maz_to_maz -&gt; skim_period -&gt; name not found in time_periods list\"\n        return value\n\n    @validator(\"highway\", always=True)\n    def relative_gap_length(cls, value, values):\n        \"\"\"Validate highway.relative_gaps is a list of length greater or equal to global iterations.\"\"\"\n        if \"run\" in values:\n            assert len(value.relative_gaps) &gt;= (\n                values[\"run\"][\"end_iteration\"] + 1\n            ), f\"'highway.relative_gaps must be the same or greater length as end_iteration+1,\\\n                that includes global iteration 0 to {values['run']['end_iteration']}'\"\n        return value\n\n    @validator(\"transit\", always=True)\n    def transit_stop_criteria_length(cls, value, values):\n        \"\"\"Validate transit.congested.stop_criteria is a list of length greater or equal to global iterations.\"\"\"\n        if (\"run\" in values) &amp; (value.congested_transit_assignment):\n            assert len(value.congested.stop_criteria) &gt;= (\n                values[\"run\"][\"end_iteration\"]\n            ), f\"'transit.stop_criteria must be the same or greater length as end_iteration,\\\n                that includes global iteration 1 to {values['run']['end_iteration']}'\"\n        return value\n\n    @validator(\"household\", always=True)\n    def sample_rate_length(cls, value, values):\n        \"\"\"Validate highway.sample_rate_by_iteration is a list of length greater or equal to global iterations.\"\"\"\n        if \"run\" in values:\n            assert len(value.sample_rate_by_iteration) &gt;= (\n                values[\"run\"][\"end_iteration\"]\n            ), f\"'highway.sample_rate_by_iteration must be the same or greater length as end_iteration'\"\n        return value\n</code></pre>"},{"location":"api/#tm2py.config.Configuration.load_toml","title":"<code>load_toml(toml_path)</code>  <code>classmethod</code>","text":"<p>Load configuration from .toml files(s).</p> <p>Normally the config is split into a scenario_config.toml file and a model_config.toml file.</p> <p>Parameters:</p> Name Type Description Default <code>toml_path</code> <code>Union[List[Union[str, Path]], str, Path]</code> <p>a valid system path string or Path object to a TOML format config file or list of paths of path objects to a set of TOML files.</p> required <p>Returns:</p> Type Description <code>Configuration</code> <p>A Configuration object</p> Source code in <code>tm2py/config.py</code> <pre><code>@classmethod\ndef load_toml(\n    cls,\n    toml_path: Union[List[Union[str, pathlib.Path]], str, pathlib.Path],\n) -&gt; \"Configuration\":\n    \"\"\"Load configuration from .toml files(s).\n\n    Normally the config is split into a scenario_config.toml file and a\n    model_config.toml file.\n\n    Args:\n        toml_path: a valid system path string or Path object to a TOML format config file or\n            list of paths of path objects to a set of TOML files.\n\n    Returns:\n        A Configuration object\n    \"\"\"\n    if not isinstance(toml_path, List):\n        toml_path = [toml_path]\n    toml_path = list(map(pathlib.Path, toml_path))\n\n    data = _load_toml(toml_path[0])\n    for path_item in toml_path[1:]:\n        _merge_dicts(data, _load_toml(path_item))\n    return cls(**data)\n</code></pre>"},{"location":"api/#tm2py.config.Configuration.maz_skim_period_exists","title":"<code>maz_skim_period_exists(value, values)</code>","text":"<p>Validate highway.maz_to_maz.skim_period refers to a valid period.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"highway\")\ndef maz_skim_period_exists(cls, value, values):\n    \"\"\"Validate highway.maz_to_maz.skim_period refers to a valid period.\"\"\"\n    if \"time_periods\" in values:\n        time_period_names = set(time.name for time in values[\"time_periods\"])\n        assert (\n            value.maz_to_maz.skim_period in time_period_names\n        ), \"maz_to_maz -&gt; skim_period -&gt; name not found in time_periods list\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.Configuration.relative_gap_length","title":"<code>relative_gap_length(value, values)</code>","text":"<p>Validate highway.relative_gaps is a list of length greater or equal to global iterations.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"highway\", always=True)\ndef relative_gap_length(cls, value, values):\n    \"\"\"Validate highway.relative_gaps is a list of length greater or equal to global iterations.\"\"\"\n    if \"run\" in values:\n        assert len(value.relative_gaps) &gt;= (\n            values[\"run\"][\"end_iteration\"] + 1\n        ), f\"'highway.relative_gaps must be the same or greater length as end_iteration+1,\\\n            that includes global iteration 0 to {values['run']['end_iteration']}'\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.Configuration.sample_rate_length","title":"<code>sample_rate_length(value, values)</code>","text":"<p>Validate highway.sample_rate_by_iteration is a list of length greater or equal to global iterations.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"household\", always=True)\ndef sample_rate_length(cls, value, values):\n    \"\"\"Validate highway.sample_rate_by_iteration is a list of length greater or equal to global iterations.\"\"\"\n    if \"run\" in values:\n        assert len(value.sample_rate_by_iteration) &gt;= (\n            values[\"run\"][\"end_iteration\"]\n        ), f\"'highway.sample_rate_by_iteration must be the same or greater length as end_iteration'\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.Configuration.transit_stop_criteria_length","title":"<code>transit_stop_criteria_length(value, values)</code>","text":"<p>Validate transit.congested.stop_criteria is a list of length greater or equal to global iterations.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"transit\", always=True)\ndef transit_stop_criteria_length(cls, value, values):\n    \"\"\"Validate transit.congested.stop_criteria is a list of length greater or equal to global iterations.\"\"\"\n    if (\"run\" in values) &amp; (value.congested_transit_assignment):\n        assert len(value.congested.stop_criteria) &gt;= (\n            values[\"run\"][\"end_iteration\"]\n        ), f\"'transit.stop_criteria must be the same or greater length as end_iteration,\\\n            that includes global iteration 1 to {values['run']['end_iteration']}'\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.CongestedAssnConfig","title":"<code>CongestedAssnConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Congested transit assignment Configuration.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass CongestedAssnConfig(ConfigItem):\n    \"Congested transit assignment Configuration.\"\n\n    trim_demand_before_congested_transit_assignment: bool = False\n    output_trimmed_demand_report_path: str = Field(default=None)\n    stop_criteria: Tuple[CongestedTransitStopCriteria, ...] = Field()\n    use_peaking_factor: bool = False\n    am_peaking_factor: float = Field(default=1.219)\n    pm_peaking_factor: float = Field(default=1.262)\n</code></pre>"},{"location":"api/#tm2py.config.CongestedTransitMaxIteration","title":"<code>CongestedTransitMaxIteration</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Congested transit assignment time period specific max iteration parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass CongestedTransitMaxIteration(ConfigItem):\n    \"\"\"Congested transit assignment time period specific max iteration parameters.\n\n    Properties:\n        time_period: time period string\n        max_iteration: max iteration specific to time period. In the design of tm2py,\n            congested assignment is run only for AM and PM. For EA, MD, and EV, we run\n            extended assignment. See code here: tm2py/components/network/transit/transit_assign.py#L465-L466\n            Therefore, `max_iteration` here does not impact EA, MD, and EV, this setting\n            is only meaningful for AM and PM.\n    \"\"\"\n\n    time_period: str = Field(max_length=4)\n    max_iteration: int = Field(ge=1, default=1)\n</code></pre>"},{"location":"api/#tm2py.config.CongestedTransitStopCriteria","title":"<code>CongestedTransitStopCriteria</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Congested transit assignment stopping criteria parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass CongestedTransitStopCriteria(ConfigItem):\n    \"\"\"Congested transit assignment stopping criteria parameters.\n\n    Properties:\n        global_iteration: global iteration number\n        normalized_gap: normalized_gap\n        relative_gaps: relative gap\n        max_iterations: max iterations config, one for each time period\n    \"\"\"\n\n    global_iteration: int = Field(ge=0)\n    normalized_gap: float = Field(gt=0)\n    relative_gap: float = Field(gt=0)\n    max_iterations: Tuple[CongestedTransitMaxIteration, ...] = Field()\n</code></pre>"},{"location":"api/#tm2py.config.CongestedWeightsConfig","title":"<code>CongestedWeightsConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Weights for Congested Transit Assignment Configuration.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass CongestedWeightsConfig(ConfigItem):\n    \"Weights for Congested Transit Assignment Configuration.\"\n\n    min_seat: float = Field(default=1.0)\n    max_seat: float = Field(default=1.4)\n    power_seat: float = Field(default=2.2)\n    min_stand: float = Field(default=1.4)\n    max_stand: float = Field(default=1.6)\n    power_stand: float = Field(default=3.4)\n</code></pre>"},{"location":"api/#tm2py.config.DemandCountyGroupConfig","title":"<code>DemandCountyGroupConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Grouping of counties for assignment and demand files.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass DemandCountyGroupConfig(ConfigItem):\n    \"\"\"Grouping of counties for assignment and demand files.\n\n    Properties:\n        number: id number for this group, must be unique\n        counties: list of one or more county names\n    \"\"\"\n\n    number: int = Field()\n    counties: Tuple[COUNTY_NAMES, ...] = Field()\n</code></pre>"},{"location":"api/#tm2py.config.EawtWeightsConfig","title":"<code>EawtWeightsConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Weights for calculating extra added wait time Configuration.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass EawtWeightsConfig(ConfigItem):\n    \"Weights for calculating extra added wait time Configuration.\"\n\n    constant: float = Field(default=0.259625)\n    weight_inverse_headway: float = Field(default=1.612019)\n    vcr: float = Field(default=0.005274)\n    exit_proportion: float = Field(default=0.591765)\n    default_eawt_factor: float = Field(default=1)\n</code></pre>"},{"location":"api/#tm2py.config.EmmeConfig","title":"<code>EmmeConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Emme-specific parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass EmmeConfig(ConfigItem):\n    \"\"\"Emme-specific parameters.\n\n    Properties:\n        all_day_scenario_id: scenario ID to use for all day\n            (initial imported) scenario with all time period data\n        project_path: relative path from run_dir to Emme desktop project (.emp)\n        highway_database_path: relative path to highway Emmebank\n        active_north_database_path:  relative paths to active mode Emmebank for north bay\n        active_south_database_path:  relative paths to active mode Emmebank for south bay\n        transit_database_path: relative path to transit Emmebank\n        num_processors: the number of processors to use in Emme procedures,\n            either as an integer, or value MAX, MAX-N. Typically recommend\n            using MAX-1 (on desktop systems) or MAX-2 (on servers with many\n            logical processors) to leave capacity for background / other tasks.\n    \"\"\"\n\n    all_day_scenario_id: int\n    project_path: pathlib.Path\n    highway_database_path: pathlib.Path\n    active_north_database_path: pathlib.Path\n    active_south_database_path: pathlib.Path\n    transit_database_path: pathlib.Path\n    num_processors: str = Field(regex=r\"^MAX$|^MAX-\\d+$|^\\d+$|^MAX/\\d+$\")\n    num_processors_transit_skim: str = Field(regex=r\"^MAX$|^MAX-\\d+$|^\\d+$|^MAX/\\d+$\")\n    highway_distribution: Optional[List[HighwayDistribution]] = Field(default=None)\n</code></pre>"},{"location":"api/#tm2py.config.HighwayCapClassConfig","title":"<code>HighwayCapClassConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Highway link capacity and speed (\u2018capclass\u2019) index entry.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HighwayCapClassConfig(ConfigItem):\n    \"\"\"Highway link capacity and speed ('capclass') index entry.\n\n    Properties:\n        capclass: cross index for link @capclass lookup\n        capacity: value for link capacity, PCE / hour\n        free_flow_speed: value for link free flow speed, miles / hour\n        critical_speed: value for critical speed (Ja) used in Akcelik\n            type functions\n    \"\"\"\n\n    capclass: int = Field(ge=0)\n    capacity: float = Field(ge=0)\n    free_flow_speed: float = Field(ge=0)\n    critical_speed: float = Field(ge=0)\n</code></pre>"},{"location":"api/#tm2py.config.HighwayClassConfig","title":"<code>HighwayClassConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Highway assignment class definition.</p> <p>Note that excluded_links, skims and toll attribute names include vehicle groups (\u201c{vehicle}\u201d) which reference the list of highway.toll.dst_vehicle_group_names (see HighwayTollsConfig). The default example model config uses: \u201cda\u201d, \u201csr2\u201d, \u201csr3\u201d, \u201cvsm\u201d, sml\u201d, \u201cmed\u201d, \u201clrg\u201d</p> Example single class config <p>name = \u201cda\u201d description= \u201cdrive alone\u201d mode_code= \u201cd\u201d [[highway.classes.demand]]     source = \u201chousehold\u201d     name = \u201cSOV_GP_{period}\u201d [[highway.classes.demand]]     source = \u201cair_passenger\u201d     name = \u201cda\u201d [[highway.classes.demand]]     source = \u201cinternal_external\u201d     name = \u201cda\u201d excluded_links = [\u201cis_toll_da\u201d, \u201cis_sr2\u201d], value_of_time = 18.93,  # $ / hr operating_cost_per_mile = 17.23,  # cents / mile toll = [\u201c@bridgetoll_da\u201d] skims = [\u201ctime\u201d, \u201cdist\u201d, \u201cfreeflowtime\u201d, \u201cbridgetoll_da\u201d],</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HighwayClassConfig(ConfigItem):\n    \"\"\"Highway assignment class definition.\n\n    Note that excluded_links, skims and toll attribute names include\n    vehicle groups (\"{vehicle}\") which reference the list of\n    highway.toll.dst_vehicle_group_names (see HighwayTollsConfig).\n    The default example model config uses:\n    \"da\", \"sr2\", \"sr3\", \"vsm\", sml\", \"med\", \"lrg\"\n\n    Example single class config:\n        name = \"da\"\n        description= \"drive alone\"\n        mode_code= \"d\"\n        [[highway.classes.demand]]\n            source = \"household\"\n            name = \"SOV_GP_{period}\"\n        [[highway.classes.demand]]\n            source = \"air_passenger\"\n            name = \"da\"\n        [[highway.classes.demand]]\n            source = \"internal_external\"\n            name = \"da\"\n        excluded_links = [\"is_toll_da\", \"is_sr2\"],\n        value_of_time = 18.93,  # $ / hr\n        operating_cost_per_mile = 17.23,  # cents / mile\n        toll = [\"@bridgetoll_da\"]\n        skims = [\"time\", \"dist\", \"freeflowtime\", \"bridgetoll_da\"],\n\n    Properties:\n        name: short (up to 10 character) unique reference name for the class.\n            used in attribute and matrix names\n        description: longer text used in attribute and matrix descriptions\n        mode_code: single character mode, used to generate link.modes to\n            identify subnetwork, generated from \"excluded_links\" keywords.\n            Should be unique in list of :es, unless multiple classes\n            have identical excluded_links specification. Cannot be the\n            same as used for highway.maz_to_maz.mode_code.\n        value_of_time: value of time for this class in $ / hr\n        operating_cost_per_mile: vehicle operating cost in cents / mile\n        demand: list of OMX file and matrix keyname references,\n            see ClassDemandConfig\n        excluded_links: list of keywords to identify links to exclude from\n            this class' available subnetwork (generate link.modes)\n            Options are:\n                - \"is_sr\": is reserved for shared ride (@useclass in 2,3)\n                - \"is_sr2\": is reserved for shared ride 2+ (@useclass == 2)\n                - \"is_sr3\": is reserved for shared ride 3+ (@useclass == 3)\n                - \"is_auto_only\": is reserved for autos (non-truck) (@useclass != 1)\n                - \"is_toll_{vehicle}\": has a value (non-bridge) toll for the {vehicle} toll group\n        toll: list of additional toll cost link attribute (values stored in cents),\n            summed, one of \"@bridgetoll_{vehicle}\", \"@valuetoll_{vehicle}\"\n        toll_factor: optional, factor to apply to toll values in cost calculation\n        pce: optional, passenger car equivalent to convert assigned demand in\n            PCE units to vehicles for total assigned vehicle calculations\n        skims: list of skim matrices to generate\n            Options are:\n                \"time\": pure travel time in minutes\n                \"dist\": distance in miles\n                \"hovdist\": distance on HOV facilities (is_sr2 or is_sr3)\n                \"tolldist\": distance on toll facilities\n                    (@tollbooth &gt; highway.tolls.valuetoll_start_tollbooth_code)\n                \"freeflowtime\": free flow travel time in minutes\n                \"bridgetoll_{vehicle}\": bridge tolls, {vehicle} refers to toll group\n                \"valuetoll_{vehicle}\": other, non-bridge tolls, {vehicle} refers to toll group\n    \"\"\"\n\n    name: str = Field(min_length=1, max_length=10)\n    veh_group_name: str = Field(min_length=1, max_length=10)\n    description: Optional[str] = Field(default=\"\")\n    mode_code: str = Field(min_length=1, max_length=1)\n    value_of_time: float = Field(gt=0)\n    operating_cost_per_mile: float = Field(ge=0)\n    pce: Optional[float] = Field(default=1.0, gt=0)\n    # Note that excluded_links, skims, and tolls validated under HighwayConfig to include\n    # highway.toll.dst_vehicle_group_names names\n    excluded_links: Tuple[str, ...] = Field()\n    skims: Tuple[str, ...] = Field()\n    toll: Tuple[str, ...] = Field()\n    toll_factor: Optional[float] = Field(default=None, gt=0)\n    demand: Tuple[ClassDemandConfig, ...] = Field()\n</code></pre>"},{"location":"api/#tm2py.config.HighwayConfig","title":"<code>HighwayConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Highway assignment and skims parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HighwayConfig(ConfigItem):\n    \"\"\"Highway assignment and skims parameters.\n\n    Properties:\n        generic_highway_mode_code: single character unique mode ID for entire\n            highway network (no excluded_links)\n        relative_gaps: relative gaps for assignment convergence, specific to global iteration, see HighwayRelativeGapConfig\n        max_iterations: maximum iterations stopping criteria\n        area_type_buffer_dist_miles: used to in calculation to categorize link @areatype\n            The area type is determined based on the average density of nearby\n            (within this buffer distance) MAZs, using (pop+jobs*2.5)/acres\n        drive_access_output_skim_path: relative path for drive access to transit skims\n        output_skim_path: relative path template from run dir for OMX output skims\n        output_skim_filename_tmpl: template for OMX filename for a time period. Must include\n            {time_period} in the string and end in '.omx'.\n        output_skim_matrixname_tmpl: template for matrix names within OMX output skims.\n            Should include {time_period}, {mode}, and {property}\n        tolls: input toll specification, see HighwayTollsConfig\n        maz_to_maz: maz-to-maz shortest path assignment and skim specification,\n            see HighwayMazToMazConfig\n        classes: highway assignment multi-class setup and skim specification,\n            see HighwayClassConfig\n        capclass_lookup: index cross-reference table from the link @capclass value\n            to the free-flow speed, capacity, and critical speed values\n        interchange_nodes_file: relative path to the interchange nodes file, this is\n            used for calculating highway reliability\n        apply_msa_demand: average highway demand with previous iterations'. Default to True.\n        reliability: bool to skim highway reliability. Default to true. If true, assignment\n            will be run twice in global iterations 0 (warmstart) and 1, to calculate reliability,\n            assignment will be run only once in global iterations 2 and 3,\n            reliability skim will stay the same as global iteration 1.\n            If false, reliability will not be calculated nor skimmed in all global\n            iterations, and the resulting reliability skims will be 0.\n    \"\"\"\n\n    generic_highway_mode_code: str = Field(min_length=1, max_length=1)\n    relative_gaps: Tuple[HighwayRelativeGapConfig, ...] = Field()\n    max_iterations: int = Field(ge=0)\n    network_acceleration: bool = Field()\n    area_type_buffer_dist_miles: float = Field(gt=0)\n    drive_access_output_skim_path: Optional[str] = Field(default=None)\n    output_skim_path: pathlib.Path = Field()\n    output_skim_filename_tmpl: str = Field()\n    output_skim_matrixname_tmpl: str = Field()\n    tolls: HighwayTollsConfig = Field()\n    maz_to_maz: HighwayMazToMazConfig = Field()\n    classes: Tuple[HighwayClassConfig, ...] = Field()\n    capclass_lookup: Tuple[HighwayCapClassConfig, ...] = Field()\n    interchange_nodes_file: str = Field()\n    apply_msa_demand: bool = True\n    reliability: bool = Field(default=True)\n\n    @validator(\"output_skim_filename_tmpl\")\n    def valid_skim_template(value):\n        \"\"\"Validate skim template has correct {} and extension.\"\"\"\n        assert (\n            \"{time_period\" in value\n        ), f\"-&gt; output_skim_filename_tmpl must have {{time_period}}', found {value}.\"\n        assert (\n            value[-4:].lower() == \".omx\"\n        ), f\"-&gt; 'output_skim_filename_tmpl must end in '.omx', found {value[-4:].lower() }\"\n        return value\n\n    @validator(\"output_skim_matrixname_tmpl\")\n    def valid_skim_matrix_name_template(value):\n        \"\"\"Validate skim matrix template has correct {}.\"\"\"\n        assert (\n            \"{time_period\" in value\n        ), \"-&gt; 'output_skim_matrixname_tmpl must have {time_period}, found {value}.\"\n        assert (\n            \"{property\" in value\n        ), \"-&gt; 'output_skim_matrixname_tmpl must have {property}, found {value}.\"\n        assert (\n            \"{mode\" in value\n        ), \"-&gt; 'output_skim_matrixname_tmpl must have {mode}, found {value}.\"\n        return value\n\n    @validator(\"capclass_lookup\")\n    def unique_capclass_numbers(cls, value):\n        \"\"\"Validate list of capclass_lookup has unique .capclass values.\"\"\"\n        capclass_ids = [i.capclass for i in value]\n        error_msg = \"-&gt; capclass value must be unique in list\"\n        assert len(capclass_ids) == len(set(capclass_ids)), error_msg\n        return value\n\n    @validator(\"classes\", pre=True)\n    def unique_class_names(cls, value):\n        \"\"\"Validate list of classes has unique .name values.\"\"\"\n        class_names = [highway_class[\"name\"] for highway_class in value]\n        error_msg = \"-&gt; name value must be unique in list\"\n        assert len(class_names) == len(set(class_names)), error_msg\n        return value\n\n    @validator(\"classes\")\n    def validate_class_mode_excluded_links(cls, value, values):\n        \"\"\"Validate list of classes has unique .mode_code or .excluded_links match.\"\"\"\n        # validate if any mode IDs are used twice, that they have the same excluded links sets\n        mode_excluded_links = {}\n        for i, highway_class in enumerate(value):\n            # maz_to_maz.mode_code must be unique\n            if \"maz_to_maz\" in values:\n                assert (\n                    highway_class[\"mode_code\"] != values[\"maz_to_maz\"][\"mode_code\"]\n                ), f\"-&gt; {i} -&gt; mode_code: cannot be the same as the highway.maz_to_maz.mode_code\"\n            # make sure that if any mode IDs are used twice, they have the same excluded links sets\n            if highway_class.mode_code in mode_excluded_links:\n                ex_links1 = highway_class[\"excluded_links\"]\n                ex_links2 = mode_excluded_links[highway_class[\"mode_code\"]]\n                error_msg = (\n                    f\"-&gt; {i}: duplicated mode codes ('{highway_class['mode_code']}') \"\n                    f\"with different excluded links: {ex_links1} and {ex_links2}\"\n                )\n                assert ex_links1 == ex_links2, error_msg\n            mode_excluded_links[highway_class.mode_code] = highway_class.excluded_links\n        return value\n\n    @validator(\"classes\")\n    def validate_class_keyword_lists(cls, value, values):\n        \"\"\"Validate classes .skims, .toll, and .excluded_links values.\"\"\"\n        if \"tolls\" not in values:\n            return value\n        avail_skims = [\n            \"time\",\n            \"dist\",\n            \"hovdist\",\n            \"tolldist\",\n            \"freeflowtime\",\n            \"rlbty\",\n            \"autotime\",\n        ]\n        available_link_sets = [\"is_sr\", \"is_sr2\", \"is_sr3\", \"is_auto_only\"]\n        avail_toll_attrs = []\n        for name in values[\"tolls\"].dst_vehicle_group_names:\n            toll_types = [f\"bridgetoll_{name}\", f\"valuetoll_{name}\"]\n            avail_skims.extend(toll_types)\n            avail_toll_attrs.extend([\"@\" + name for name in toll_types])\n            available_link_sets.append(f\"is_toll_{name}\")\n\n        # validate class skim name list and toll attribute against toll setup\n        def check_keywords(class_num, key, val, available):\n            extra_keys = set(val) - set(available)\n            error_msg = (\n                f\" -&gt; {class_num} -&gt; {key}: unrecognized {key} name(s): \"\n                f\"{','.join(extra_keys)}.  Available names are: {', '.join(available)}\"\n            )\n            assert not extra_keys, error_msg\n\n        for i, highway_class in enumerate(value):\n            check_keywords(i, \"skim\", highway_class[\"skims\"], avail_skims)\n            check_keywords(i, \"toll\", highway_class[\"toll\"], avail_toll_attrs)\n            check_keywords(\n                i,\n                \"excluded_links\",\n                highway_class[\"excluded_links\"],\n                available_link_sets,\n            )\n        return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayConfig.unique_capclass_numbers","title":"<code>unique_capclass_numbers(value)</code>","text":"<p>Validate list of capclass_lookup has unique .capclass values.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"capclass_lookup\")\ndef unique_capclass_numbers(cls, value):\n    \"\"\"Validate list of capclass_lookup has unique .capclass values.\"\"\"\n    capclass_ids = [i.capclass for i in value]\n    error_msg = \"-&gt; capclass value must be unique in list\"\n    assert len(capclass_ids) == len(set(capclass_ids)), error_msg\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayConfig.unique_class_names","title":"<code>unique_class_names(value)</code>","text":"<p>Validate list of classes has unique .name values.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"classes\", pre=True)\ndef unique_class_names(cls, value):\n    \"\"\"Validate list of classes has unique .name values.\"\"\"\n    class_names = [highway_class[\"name\"] for highway_class in value]\n    error_msg = \"-&gt; name value must be unique in list\"\n    assert len(class_names) == len(set(class_names)), error_msg\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayConfig.valid_skim_matrix_name_template","title":"<code>valid_skim_matrix_name_template(value)</code>","text":"<p>Validate skim matrix template has correct {}.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"output_skim_matrixname_tmpl\")\ndef valid_skim_matrix_name_template(value):\n    \"\"\"Validate skim matrix template has correct {}.\"\"\"\n    assert (\n        \"{time_period\" in value\n    ), \"-&gt; 'output_skim_matrixname_tmpl must have {time_period}, found {value}.\"\n    assert (\n        \"{property\" in value\n    ), \"-&gt; 'output_skim_matrixname_tmpl must have {property}, found {value}.\"\n    assert (\n        \"{mode\" in value\n    ), \"-&gt; 'output_skim_matrixname_tmpl must have {mode}, found {value}.\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayConfig.valid_skim_template","title":"<code>valid_skim_template(value)</code>","text":"<p>Validate skim template has correct {} and extension.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"output_skim_filename_tmpl\")\ndef valid_skim_template(value):\n    \"\"\"Validate skim template has correct {} and extension.\"\"\"\n    assert (\n        \"{time_period\" in value\n    ), f\"-&gt; output_skim_filename_tmpl must have {{time_period}}', found {value}.\"\n    assert (\n        value[-4:].lower() == \".omx\"\n    ), f\"-&gt; 'output_skim_filename_tmpl must end in '.omx', found {value[-4:].lower() }\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayConfig.validate_class_keyword_lists","title":"<code>validate_class_keyword_lists(value, values)</code>","text":"<p>Validate classes .skims, .toll, and .excluded_links values.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"classes\")\ndef validate_class_keyword_lists(cls, value, values):\n    \"\"\"Validate classes .skims, .toll, and .excluded_links values.\"\"\"\n    if \"tolls\" not in values:\n        return value\n    avail_skims = [\n        \"time\",\n        \"dist\",\n        \"hovdist\",\n        \"tolldist\",\n        \"freeflowtime\",\n        \"rlbty\",\n        \"autotime\",\n    ]\n    available_link_sets = [\"is_sr\", \"is_sr2\", \"is_sr3\", \"is_auto_only\"]\n    avail_toll_attrs = []\n    for name in values[\"tolls\"].dst_vehicle_group_names:\n        toll_types = [f\"bridgetoll_{name}\", f\"valuetoll_{name}\"]\n        avail_skims.extend(toll_types)\n        avail_toll_attrs.extend([\"@\" + name for name in toll_types])\n        available_link_sets.append(f\"is_toll_{name}\")\n\n    # validate class skim name list and toll attribute against toll setup\n    def check_keywords(class_num, key, val, available):\n        extra_keys = set(val) - set(available)\n        error_msg = (\n            f\" -&gt; {class_num} -&gt; {key}: unrecognized {key} name(s): \"\n            f\"{','.join(extra_keys)}.  Available names are: {', '.join(available)}\"\n        )\n        assert not extra_keys, error_msg\n\n    for i, highway_class in enumerate(value):\n        check_keywords(i, \"skim\", highway_class[\"skims\"], avail_skims)\n        check_keywords(i, \"toll\", highway_class[\"toll\"], avail_toll_attrs)\n        check_keywords(\n            i,\n            \"excluded_links\",\n            highway_class[\"excluded_links\"],\n            available_link_sets,\n        )\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayConfig.validate_class_mode_excluded_links","title":"<code>validate_class_mode_excluded_links(value, values)</code>","text":"<p>Validate list of classes has unique .mode_code or .excluded_links match.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"classes\")\ndef validate_class_mode_excluded_links(cls, value, values):\n    \"\"\"Validate list of classes has unique .mode_code or .excluded_links match.\"\"\"\n    # validate if any mode IDs are used twice, that they have the same excluded links sets\n    mode_excluded_links = {}\n    for i, highway_class in enumerate(value):\n        # maz_to_maz.mode_code must be unique\n        if \"maz_to_maz\" in values:\n            assert (\n                highway_class[\"mode_code\"] != values[\"maz_to_maz\"][\"mode_code\"]\n            ), f\"-&gt; {i} -&gt; mode_code: cannot be the same as the highway.maz_to_maz.mode_code\"\n        # make sure that if any mode IDs are used twice, they have the same excluded links sets\n        if highway_class.mode_code in mode_excluded_links:\n            ex_links1 = highway_class[\"excluded_links\"]\n            ex_links2 = mode_excluded_links[highway_class[\"mode_code\"]]\n            error_msg = (\n                f\"-&gt; {i}: duplicated mode codes ('{highway_class['mode_code']}') \"\n                f\"with different excluded links: {ex_links1} and {ex_links2}\"\n            )\n            assert ex_links1 == ex_links2, error_msg\n        mode_excluded_links[highway_class.mode_code] = highway_class.excluded_links\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayDistribution","title":"<code>HighwayDistribution</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Highway distribution run configuration. Use to enable distributing the    assignment (running time periods in parallel).</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HighwayDistribution(ConfigItem):\n    \"\"\"Highway distribution run configuration. Use to enable distributing the\n       assignment (running time periods in parallel).\n\n    Properties:\n        periods: list of the names of the periods to use.\n        num_processors: the number of processors to use as an integer, MAX-N or MAX/N\n    \"\"\"\n\n    time_periods: List[str]\n    num_processors: str = Field(regex=r\"^MAX$|^MAX-\\d+$|^\\d+$|^MAX/\\d+$\")\n</code></pre>"},{"location":"api/#tm2py.config.HighwayMazToMazConfig","title":"<code>HighwayMazToMazConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Highway MAZ to MAZ shortest path assignment and skim parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HighwayMazToMazConfig(ConfigItem):\n    \"\"\"Highway MAZ to MAZ shortest path assignment and skim parameters.\n\n    Properties:\n        mode_code: single character mode, used to generate link.modes to\n            identify subnetwork, generated from \"excluded_links\" keywords,\n            plus including MAZ connectors.\n        value_of_time: value of time for this class in $ / hr\n        operating_cost_per_mile: vehicle operating cost in cents / mile\n        max_skim_cost: max shortest path distance to search for MAZ-to-MAZ\n            skims, in generized costs units (includes operating cost\n            converted to minutes)\n        excluded_links: list of keywords to identify links to exclude from\n            MAZ-to-MAZ paths, see HighwayClassConfig.excluded_links\n        demand_file: relative path to find the input demand files\n            can have use a placeholder for {period} and {number}, where the\n            {period} is the time_period.name (see TimePeriodConfig)\n            and {number} is the demand_count_groups[].number\n            (see DemandCountyGroupConfig)\n            e.g.: auto_{period}_MAZ_AUTO_{number}_{period}.omx\n        demand_county_groups: List of demand county names and\n        skim_period: period name to use for the shotest path skims, must\n            match one of the names listed in the time_periods\n        output_skim_file: relative path to resulting MAZ-to-MAZ skims\n    \"\"\"\n\n    mode_code: str = Field(min_length=1, max_length=1)\n    value_of_time: float = Field(gt=0)\n    operating_cost_per_mile: float = Field(ge=0)\n    max_distance: float = Field(gt=0)\n    max_skim_cost: float = Field(gt=0)\n    excluded_links: Tuple[str, ...] = Field()\n    demand_file: pathlib.Path = Field()\n    demand_county_groups: Tuple[DemandCountyGroupConfig, ...] = Field()\n    skim_period: str = Field()\n    output_skim_file: pathlib.Path = Field()\n\n    @validator(\"demand_county_groups\")\n    def unique_group_numbers(cls, value):\n        \"\"\"Validate list of demand_county_groups has unique .number values.\"\"\"\n        group_ids = [group.number for group in value]\n        assert len(group_ids) == len(set(group_ids)), \"-&gt; number value must be unique\"\n        return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayMazToMazConfig.unique_group_numbers","title":"<code>unique_group_numbers(value)</code>","text":"<p>Validate list of demand_county_groups has unique .number values.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"demand_county_groups\")\ndef unique_group_numbers(cls, value):\n    \"\"\"Validate list of demand_county_groups has unique .number values.\"\"\"\n    group_ids = [group.number for group in value]\n    assert len(group_ids) == len(set(group_ids)), \"-&gt; number value must be unique\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayRelativeGapConfig","title":"<code>HighwayRelativeGapConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Highway assignment relative gap parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HighwayRelativeGapConfig(ConfigItem):\n    \"\"\"Highway assignment relative gap parameters.\n\n    Properties:\n        global_iteration: global iteration number\n        relative_gap: relative gap\n    \"\"\"\n\n    global_iteration: int = Field(ge=0)\n    relative_gap: float = Field(gt=0)\n</code></pre>"},{"location":"api/#tm2py.config.HighwayTollsConfig","title":"<code>HighwayTollsConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Highway assignment and skim input tolls and related parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HighwayTollsConfig(ConfigItem):\n    \"\"\"Highway assignment and skim input tolls and related parameters.\n\n    Properties:\n        file_path: source relative file path for the highway tolls index CSV\n        valuetoll_start_tollbooth_code: tollbooth separates links with \"bridge\" tolls\n            (index &lt; this value) vs. \"value\" tolls. These toll attributes\n            can then be referenced separately in the highway.classes[].tolls\n            list\n        src_vehicle_group_names: name used for the vehicle toll CSV column IDs,\n            of the form \"toll{period}_{vehicle}\"\n        dst_vehicle_group_names: list of names used in destination network\n            for the corresponding vehicle group. Length of list must be the same\n            as src_vehicle_group_names. Used for toll related attributes and\n            resulting skim matrices. Cross-referenced in list of highway.classes[],\n            valid keywords for:\n                excluded_links: \"is_toll_{vehicle}\"\n                tolls: \"@bridgetoll_{vehicle}\", \"@valuetoll_{vehicle}\"\n                skims: \"bridgetoll_{vehicle}\", \"valuetoll_{vehicle}\"\n    \"\"\"\n\n    file_path: pathlib.Path = Field()\n    valuetoll_start_tollbooth_code: int = Field(gt=1)\n    src_vehicle_group_names: Tuple[str, ...] = Field()\n    dst_vehicle_group_names: Tuple[str, ...] = Field()\n\n    @validator(\"dst_vehicle_group_names\", always=True)\n    def dst_vehicle_group_names_length(cls, value, values):\n        \"\"\"Validate dst_vehicle_group_names has same length as src_vehicle_group_names.\"\"\"\n        if \"src_vehicle_group_names\" in values:\n            assert len(value) == len(\n                values[\"src_vehicle_group_names\"]\n            ), \"dst_vehicle_group_names must be same length as src_vehicle_group_names\"\n            assert all(\n                [len(v) &lt;= 4 for v in value]\n            ), \"dst_vehicle_group_names must be 4 characters or less\"\n        return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayTollsConfig.dst_vehicle_group_names_length","title":"<code>dst_vehicle_group_names_length(value, values)</code>","text":"<p>Validate dst_vehicle_group_names has same length as src_vehicle_group_names.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"dst_vehicle_group_names\", always=True)\ndef dst_vehicle_group_names_length(cls, value, values):\n    \"\"\"Validate dst_vehicle_group_names has same length as src_vehicle_group_names.\"\"\"\n    if \"src_vehicle_group_names\" in values:\n        assert len(value) == len(\n            values[\"src_vehicle_group_names\"]\n        ), \"dst_vehicle_group_names must be same length as src_vehicle_group_names\"\n        assert all(\n            [len(v) &lt;= 4 for v in value]\n        ), \"dst_vehicle_group_names must be 4 characters or less\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HouseholdConfig","title":"<code>HouseholdConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Household (residents) model parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HouseholdConfig(ConfigItem):\n    \"\"\"Household (residents) model parameters.\"\"\"\n\n    highway_demand_file: pathlib.Path\n    transit_demand_file: pathlib.Path\n    active_demand_file: pathlib.Path\n    highway_maz_ctramp_output_file: pathlib.Path\n    OwnedAV_ZPV_factor: float\n    TNC_ZPV_factor: float\n    ctramp_indiv_trip_file: str\n    ctramp_joint_trip_file: str\n    ctramp_run_dir: pathlib.Path\n    rideshare_mode_split: Dict[str, float]\n    taxi_split: Dict[str, float]\n    single_tnc_split: Dict[str, float]\n    shared_tnc_split: Dict[str, float]\n    ctramp_mode_names: Dict[float, str]\n    income_segment: Dict[str, Union[float, str, list]]\n    ctramp_hh_file: str\n    sample_rate_by_iteration: List[float]\n</code></pre>"},{"location":"api/#tm2py.config.HouseholdModeAgg","title":"<code>HouseholdModeAgg</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>household trip mode aggregation input parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HouseholdModeAgg(ConfigItem):\n    \"\"\"household trip mode aggregation input parameters.\n\n    Properties:\n        name: aggregate name used for the class group in the input columns\n            for the trip tables,\n        modes: list of mode choice mode names used for the trip tables\n    \"\"\"\n\n    name: str\n    modes: Tuple[str, ...]\n</code></pre>"},{"location":"api/#tm2py.config.ImpedanceConfig","title":"<code>ImpedanceConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Blended skims used for accessibility/friction calculations.</p> <p>Properties:I     name: name to store it as, referred to in TripDistribution config     skim_mode: name of the mode to use for the blended skim     time_blend: blend of time periods to use; mapped to the factors (which should sum to 1)</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass ImpedanceConfig(ConfigItem):\n    \"\"\"Blended skims used for accessibility/friction calculations.\n\n    Properties:I\n        name: name to store it as, referred to in TripDistribution config\n        skim_mode: name of the mode to use for the blended skim\n        time_blend: blend of time periods to use; mapped to the factors (which should sum to 1)\n    \"\"\"\n\n    name: str\n    skim_mode: str\n    time_blend: Dict[str, float]\n\n    @validator(\"time_blend\", allow_reuse=True)\n    def sums_to_one(value):\n        \"\"\"Validate highway.maz_to_maz.skim_period refers to a valid period.\"\"\"\n        assert sum(value.values()) - 1 &lt; 0.0001, \"blend factors must sum to 1\"\n        return value\n</code></pre>"},{"location":"api/#tm2py.config.ImpedanceConfig.sums_to_one","title":"<code>sums_to_one(value)</code>","text":"<p>Validate highway.maz_to_maz.skim_period refers to a valid period.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"time_blend\", allow_reuse=True)\ndef sums_to_one(value):\n    \"\"\"Validate highway.maz_to_maz.skim_period refers to a valid period.\"\"\"\n    assert sum(value.values()) - 1 &lt; 0.0001, \"blend factors must sum to 1\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.InternalExternalConfig","title":"<code>InternalExternalConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Internal &lt;-&gt; External model parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass InternalExternalConfig(ConfigItem):\n    \"\"\"Internal &lt;-&gt; External model parameters.\"\"\"\n\n    output_trip_table_directory: pathlib.Path\n    outfile_trip_table_tmp: str\n    highway_demand_file: str\n    modes: List[str]\n    demand: DemandGrowth\n    time_of_day: TimeOfDayConfig\n    toll_choice: TollChoiceConfig\n</code></pre>"},{"location":"api/#tm2py.config.LoggingConfig","title":"<code>LoggingConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Logging parameters. TODO.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass LoggingConfig(ConfigItem):\n    \"\"\"Logging parameters. TODO.\n\n    Properties:\n        display_level: filter level for messages to show in console, default\n            is STATUS\n        run_file_path: relative path to high-level log file for the model run,\n            default is tm2py_run_[%Y%m%d_%H%M].log\n        run_file_level: filter level for messages recorded in the run log,\n            default is INFO\n        log_file_path: relative path to general log file with more detail\n            than the run_file, default is tm2py_detail_[%Y%m%d_%H%M].log\n        log_file_level: optional, filter level for messages recorded in the\n            standard log, default is DETAIL\n        log_on_error_file_path: relative path to use for fallback log message cache\n            on error, default is tm2py_error_[%Y%m%d_%H%M].log\n        notify_slack: if true notify_slack messages will be sent, default is False\n        use_emme_logbook: if True log messages recorded in the standard log file will\n            also be recorded in the Emme logbook, default is True\n        iter_component_level: tuple of tuples of iteration, component name, log level.\n            Used to override log levels (log_file_level) for debugging and recording\n            more detail in the log_file_path.\n            Example: [ [2, \"highway\", \"TRACE\"] ] to record all messages\n            during the highway component run at iteration 2.\n    \"\"\"\n\n    display_level: Optional[LogLevel] = Field(default=\"STATUS\")\n    run_file_path: Optional[str] = Field(\n        default=\"tm2py_run_{}.log\".format(\n            datetime.datetime.now().strftime(\"%Y%m%d_%H%M\")\n        )\n    )\n    run_file_level: Optional[LogLevel] = Field(default=\"INFO\")\n    log_file_path: Optional[str] = Field(\n        default=\"tm2py_debug_{}.log\".format(\n            datetime.datetime.now().strftime(\"%Y%m%d_%H%M\")\n        )\n    )\n    log_file_level: Optional[LogLevel] = Field(default=\"DEBUG\")\n    log_on_error_file_path: Optional[str] = Field(\n        default=\"tm2py_error_{}.log\".format(\n            datetime.datetime.now().strftime(\"%Y%m%d_%H%M\")\n        )\n    )\n\n    notify_slack: Optional[bool] = Field(default=False)\n    use_emme_logbook: Optional[bool] = Field(default=True)\n    iter_component_level: Optional[Tuple[Tuple[int, ComponentNames, LogLevel], ...]] = (\n        Field(default=None)\n    )\n</code></pre>"},{"location":"api/#tm2py.config.ManualJourneyLevelsConfig","title":"<code>ManualJourneyLevelsConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Manual Journey Level Specification</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass ManualJourneyLevelsConfig(ConfigItem):\n    \"\"\"Manual Journey Level Specification\"\"\"\n\n    level_id: int\n    group_fare_systems: Tuple[int, ...]\n</code></pre>"},{"location":"api/#tm2py.config.MatrixFactorConfig","title":"<code>MatrixFactorConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Mapping of zone or list of zones to factor value.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass MatrixFactorConfig(ConfigItem):\n    \"\"\"Mapping of zone or list of zones to factor value.\"\"\"\n\n    zone_index: Optional[Union[int, List[int]]]\n    factor: Optional[float] = Field(default=None)\n    i_factor: Optional[float] = Field(default=None)\n    j_factor: Optional[float] = Field(default=None)\n    as_growth_rate: Optional[bool] = Field(default=False)\n\n    @validator(\"zone_index\", allow_reuse=True)\n    def valid_zone_index(value):\n        \"\"\"Validate zone index and turn to list if isn't one.\"\"\"\n        if isinstance(value, str):\n            value = int(value)\n        if isinstance(value, int):\n            value = [value]\n        assert all([x &gt;= 0 for x in value]), \"Zone_index must be greater or equal to 0\"\n        return value\n\n    @validator(\"factor\", allow_reuse=True)\n    def valid_factor(value, values):\n        assert (\n            \"i_factor\" not in values.keys()\n        ), \"Found both `factor` and\\\n            `i_factor` in MatrixFactorConfig. Should be one or the other.\"\n\n        assert (\n            \"j_factor\" not in values.keys()\n        ), \"Found both `factor` and\\\n            `j_factor` in MatrixFactorConfig. Should be one or the other.\"\n        return value\n</code></pre>"},{"location":"api/#tm2py.config.MatrixFactorConfig.valid_zone_index","title":"<code>valid_zone_index(value)</code>","text":"<p>Validate zone index and turn to list if isn\u2019t one.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"zone_index\", allow_reuse=True)\ndef valid_zone_index(value):\n    \"\"\"Validate zone index and turn to list if isn't one.\"\"\"\n    if isinstance(value, str):\n        value = int(value)\n    if isinstance(value, int):\n        value = [value]\n    assert all([x &gt;= 0 for x in value]), \"Zone_index must be greater or equal to 0\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.PostProcessorConfig","title":"<code>PostProcessorConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Post Processor Configuration.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass PostProcessorConfig(ConfigItem):\n    \"Post Processor Configuration.\"\n    network_shapefile_path: str = Field(default=None)\n    boardings_by_segment_file_path: str = Field(default=None)\n    boardings_by_segment_geofile_path: str = Field(default=None)\n</code></pre>"},{"location":"api/#tm2py.config.RunConfig","title":"<code>RunConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Model run parameters.</p> <p>Note that the components will be executed in the order listed.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass RunConfig(ConfigItem):\n    \"\"\"Model run parameters.\n\n    Note that the components will be executed in the order listed.\n\n    Properties:\n        start_iteration: start iteration number, 0 to include initial_components\n        end_iteration: final iteration number\n        start_component: name of component to start with, will skip components\n            list prior to this component\n        initial_components: list of components to run as initial (0) iteration, in order\n        global_iteration_components: list of component to run at every subsequent\n            iteration (max(1, start_iteration) to end_iteration), in order.\n        final_components: list of components to run after final iteration, in order\n    \"\"\"\n\n    initial_components: Tuple[ComponentNames, ...]\n    global_iteration_components: Tuple[ComponentNames, ...]\n    final_components: Tuple[ComponentNames, ...]\n    start_iteration: int = Field(ge=0)\n    end_iteration: int = Field(gt=0)\n    start_component: Optional[Union[ComponentNames, EmptyString]] = Field(default=\"\")\n\n    @validator(\"end_iteration\", allow_reuse=True)\n    def end_iteration_gt_start(cls, value, values):\n        \"\"\"Validate end_iteration greater than start_iteration.\"\"\"\n        if values.get(\"start_iteration\"):\n            assert (\n                value &gt;= values[\"start_iteration\"]\n            ), f\"'end_iteration' ({value}) must be greater than 'start_iteration'\\\n                ({values['start_iteration']})\"\n        return value\n\n    @validator(\"start_component\", allow_reuse=True)\n    def start_component_used(cls, value, values):\n        \"\"\"Validate start_component is listed in *_components.\"\"\"\n        if not values.get(\"start_component\") or not value:\n            return value\n\n        if \"start_iteration\" in values:\n            if values.get(\"start_iteration\") == 0:\n                assert value in values.get(\n                    \"initial_components\", [value]\n                ), f\"'start_component' ({value}) must be one of the components listed in\\\n                    initial_components if 'start_iteration = 0'\"\n            else:\n                assert value in values.get(\n                    \"global_iteration_components\", [values]\n                ), f\"'start_component' ({value}) must be one of the components listed in\\\n                    global_iteration_components if 'start_iteration &gt; 0'\"\n        return value\n</code></pre>"},{"location":"api/#tm2py.config.RunConfig.end_iteration_gt_start","title":"<code>end_iteration_gt_start(value, values)</code>","text":"<p>Validate end_iteration greater than start_iteration.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"end_iteration\", allow_reuse=True)\ndef end_iteration_gt_start(cls, value, values):\n    \"\"\"Validate end_iteration greater than start_iteration.\"\"\"\n    if values.get(\"start_iteration\"):\n        assert (\n            value &gt;= values[\"start_iteration\"]\n        ), f\"'end_iteration' ({value}) must be greater than 'start_iteration'\\\n            ({values['start_iteration']})\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.RunConfig.start_component_used","title":"<code>start_component_used(value, values)</code>","text":"<p>Validate start_component is listed in *_components.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"start_component\", allow_reuse=True)\ndef start_component_used(cls, value, values):\n    \"\"\"Validate start_component is listed in *_components.\"\"\"\n    if not values.get(\"start_component\") or not value:\n        return value\n\n    if \"start_iteration\" in values:\n        if values.get(\"start_iteration\") == 0:\n            assert value in values.get(\n                \"initial_components\", [value]\n            ), f\"'start_component' ({value}) must be one of the components listed in\\\n                initial_components if 'start_iteration = 0'\"\n        else:\n            assert value in values.get(\n                \"global_iteration_components\", [values]\n            ), f\"'start_component' ({value}) must be one of the components listed in\\\n                global_iteration_components if 'start_iteration &gt; 0'\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.ScenarioConfig","title":"<code>ScenarioConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Scenario related parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass ScenarioConfig(ConfigItem):\n    \"\"\"Scenario related parameters.\n\n    Properties:\n        verify: optional, default False if specified as True components will run\n            additional post-process verify step to validate results / outputs\n            (not implemented yet)\n        maz_landuse_file: relative path to maz_landuse_file used by multiple\n            components\n        name: scenario name string\n        year: model year, must be at least 2005\n        landuse_file: TAZ file\n    \"\"\"\n\n    maz_landuse_file: pathlib.Path\n    zone_seq_file: pathlib.Path\n    landuse_file: pathlib.Path\n    landuse_index_column: str\n    name: str\n    year: int = Field(ge=2005)\n    verify: Optional[bool] = Field(default=False)\n</code></pre>"},{"location":"api/#tm2py.config.TimeOfDayClassConfig","title":"<code>TimeOfDayClassConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Configuration for a class of time of day model.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TimeOfDayClassConfig(ConfigItem):\n    \"\"\"Configuration for a class of time of day model.\"\"\"\n\n    name: str\n    time_period_split: List[TimeSplitConfig]\n</code></pre>"},{"location":"api/#tm2py.config.TimeOfDayConfig","title":"<code>TimeOfDayConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Configuration for time of day model.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TimeOfDayConfig(ConfigItem):\n    \"\"\"Configuration for time of day model.\"\"\"\n\n    classes: List[TimeOfDayClassConfig]\n</code></pre>"},{"location":"api/#tm2py.config.TimePeriodConfig","title":"<code>TimePeriodConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Time time period entry.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TimePeriodConfig(ConfigItem):\n    \"\"\"Time time period entry.\n\n    Properties:\n        name: name of the time period, up to four characters\n        length_hours: length of the time period in hours\n        highway_capacity_factor: factor to use to multiple the per-hour\n            capacites in the highway network\n        emme_scenario_id: scenario ID to use for Emme per-period\n            assignment (highway and transit) scenarios\n    \"\"\"\n\n    name: str = Field(max_length=4)\n    start_period: float = Field(gt=0)\n    length_hours: float = Field(gt=0)\n    highway_capacity_factor: float = Field(gt=0)\n    emme_scenario_id: int = Field(ge=1)\n    description: Optional[str] = Field(default=\"\")\n</code></pre>"},{"location":"api/#tm2py.config.TimeSplitConfig","title":"<code>TimeSplitConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Split matrix i and j.</p> <p>i.e. for time of day splits.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TimeSplitConfig(ConfigItem):\n    \"\"\"Split matrix i and j.\n\n    i.e. for time of day splits.\n    \"\"\"\n\n    time_period: str\n    production: Optional[NonNegativeFloat] = None\n    attraction: Optional[NonNegativeFloat] = None\n    od: Optional[NonNegativeFloat] = None\n\n    @validator(\"production\", \"attraction\", \"od\", allow_reuse=True)\n    def less_than_equal_one(cls, v):\n        if v:\n            assert v &lt;= 1.0, \"Value should be less than or equal to 1\"\n        return v\n\n    def __post_init__(self):\n        if self.od and any([self.production, self.attraction]):\n            raise ValueError(\n                f\"TimeSplitConfig: Must either specifify an od or any of\\\n            production/attraction - not both.\\n{self}\"\n            )\n\n        if not all([self.production, self.attraction]) and any(\n            [self.production, self.attraction]\n        ):\n            raise ValueError(\n                f\"TimeSplitConfig: Must have both production AND attraction\\\n            if one of them is specified.\"\n            )\n</code></pre>"},{"location":"api/#tm2py.config.TollChoiceConfig","title":"<code>TollChoiceConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Toll choice parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TollChoiceConfig(ConfigItem):\n    \"\"\"Toll choice parameters.\n\n    Properties:\n        property_to_skim_toll: Maps a property in the utility equation with a list of skim\n            properties. If more than one skim property is listed, they will be summed together\n            (e.g. cost if the sum of bridge toll and value toll). This defaults to a value in the\n            code.\n        property_to_skim_notoll: Maps a property in the utility equation with a list of skim\n            properties for no toll choice.If more than one skim property is listed, they will\n            be summed together  (e.g. cost if the sum of bridge toll and value toll). This\n            defaults to a value in the code.\n    \"\"\"\n\n    classes: List[ChoiceClassConfig]\n    value_of_time: float\n    operating_cost_per_mile: float\n    property_to_skim_toll: Optional[Dict[str, List[str]]] = Field(default_factory=dict)\n    property_to_skim_notoll: Optional[Dict[str, List[str]]] = Field(\n        default_factory=dict\n    )\n    utility: Optional[List[CoefficientConfig]] = Field(default_factory=dict)\n</code></pre>"},{"location":"api/#tm2py.config.TransitClassConfig","title":"<code>TransitClassConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Transit demand class definition.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TransitClassConfig(ConfigItem):\n    \"\"\"Transit demand class definition.\"\"\"\n\n    skim_set_id: str\n    name: str\n    description: str\n    mode_types: Tuple[str, ...]\n    demand: Tuple[ClassDemandConfig, ...]\n    required_mode_combo: Optional[Tuple[str, ...]] = Field(default=None)\n</code></pre>"},{"location":"api/#tm2py.config.TransitConfig","title":"<code>TransitConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Transit assignment parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TransitConfig(ConfigItem):\n    \"\"\"Transit assignment parameters.\"\"\"\n\n    modes: Tuple[TransitModeConfig, ...]\n    classes: Tuple[TransitClassConfig, ...]\n    journey_levels: TransitJourneyLevelsConfig\n    apply_msa_demand: bool\n    value_of_time: float\n    walk_speed: float\n    transit_speed: float\n    effective_headway_source: str\n    initial_wait_perception_factor: float\n    transfer_wait_perception_factor: float\n    walk_perception_factor: float\n    walk_perception_factor: float\n    walk_perception_factor_cbd: float\n    drive_perception_factor: float\n    max_transfers: int\n    use_fares: bool\n    fare_2015_to_2000_deflator: float\n    fares_path: pathlib.Path\n    fare_matrix_path: pathlib.Path\n    fare_max_transfer_distance_miles: float\n    override_connector_times: bool\n    use_ccr: bool\n    ccr_stop_criteria: Optional[AssignmentStoppingCriteriaConfig]\n    ccr_weights: CcrWeightsConfig\n    eawt_weights: EawtWeightsConfig\n    congested_transit_assignment: bool\n    congested: CongestedAssnConfig\n    congested_weights: CongestedWeightsConfig\n    output_skim_path: pathlib.Path\n    output_skim_filename_tmpl: str = Field()\n    output_skim_matrixname_tmpl: str = Field()\n    output_stop_usage_path: Optional[str] = Field(default=None)\n    output_transit_boardings_path: Optional[str] = Field(default=None)\n    output_transit_segment_path: Optional[str] = Field(default=None)\n    output_station_to_station_flow_path: Optional[str] = Field(default=None)\n    output_transfer_at_station_path: Optional[str] = Field(default=None)\n    timed_transfer_nodes: Tuple[int, ...] = Field()\n    output_transfer_at_station_node_ids: Dict[str, int] = Field()\n    max_ccr_iterations: float = None\n    split_connectors_to_prevent_walk: bool = False\n    input_connector_access_times_path: Optional[str] = Field(default=None)\n    input_connector_egress_times_path: Optional[str] = Field(default=None)\n    vehicles: Optional[TransitVehicleConfig] = Field(\n        default_factory=TransitVehicleConfig\n    )\n</code></pre>"},{"location":"api/#tm2py.config.TransitJourneyLevelsConfig","title":"<code>TransitJourneyLevelsConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Transit manual journey levels structure.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TransitJourneyLevelsConfig(ConfigItem):\n    \"\"\"Transit manual journey levels structure.\"\"\"\n\n    use_algorithm: bool = False\n    \"\"\"\n    The original translation from Cube to Emme used an algorithm to, as faithfully as possible, reflect transfer fares via journey levels. \n    The algorithm examines fare costs and proximity of transit services to create a set of journey levels that reflects transfer costs. \n    While this algorithm works well, the Bay Area's complex fare system results in numerous journey levels specific to operators with low ridership. \n    The resulting assignment compute therefore expends a lot of resources on these operators. \n    Set this parameter to `True` to use the algorithm. Exactly one of `use_algorithm` or `specify_manually` must be `True`. \n    \"\"\"\n    specify_manually: bool = False\n    \"\"\"\n    An alternative to using an algorithm to specify the journey levels is to use specify them manually. \n    If this option is set to `True`, the `manual` parameter can be used to assign fare systems to faresystem groups (or journey levels). \n    Consider, for example, the following three journey levels: 0 - has yet to board transit; 1 - has boarded SF Muni; 2 - has boarded all other transit systems. \n    To specify this configuration, a single `manual` entry identifying the SF Muni fare systems is needed. \n    The other faresystem group is automatically generated in the code with the rest of the faresystems which are not specified in any of the groups.\n    See the `manual` entry for an example.\n    \"\"\"\n    manual: Optional[Tuple[ManualJourneyLevelsConfig, ...]] = (\n        ManualJourneyLevelsConfig(level_id=1, group_fare_systems=(25,)),\n    )\n    \"\"\"\n    If 'specify_manually' is set to `True`, there should be at least one faresystem group specified here.\n    The format includes two entries: `level_id`, which is the serial number of the group specified, \n    and `group_fare_system`, which is a list of all faresystems belonging to that group.\n    For example, to specify MUNI as one faresystem group, the right configuration would be:\n    [[transit.journey_levels.manual]]\n    level_id = 1\n    group_fare_systems = [25]\n    If there are multiple groups required to be specified, for example, MUNI in one and Caltrain in the other group,\n    it can be achieved by adding another entry of `manual`, like:\n    [[transit.journey_levels.manual]]\n    level_id = 1\n    group_fare_systems = [25]\n    [[transit.journey_levels.manual]]\n    level_id = 2\n    group_fare_systems = [12,14]\n\n    \"\"\"\n\n    @validator(\"specify_manually\")\n    def check_exclusivity(cls, v, values):\n        \"\"\"Valdiates that exactly one of specify_manually and use_algorithm is True\"\"\"\n        use_algorithm = values.get(\"use_algorithm\")\n        assert (\n            use_algorithm != v\n        ), 'Exactly one of \"use_algorithm\" or \"specify_manually\" must be True.'\n        return v\n\n    @validator(\"manual\", always=True)\n    def check_manual(cls, v, values):\n        if values.get(\"specify_manually\"):\n            assert (\n                v is not None and len(v) &gt; 0\n            ), \"If 'specify_manually' is True, 'manual' cannot be None or empty.\"\n        return v\n</code></pre>"},{"location":"api/#tm2py.config.TransitJourneyLevelsConfig.manual","title":"<code>manual: Optional[Tuple[ManualJourneyLevelsConfig, ...]] = (ManualJourneyLevelsConfig(level_id=1, group_fare_systems=(25,)),)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If \u2018specify_manually\u2019 is set to <code>True</code>, there should be at least one faresystem group specified here. The format includes two entries: <code>level_id</code>, which is the serial number of the group specified,  and <code>group_fare_system</code>, which is a list of all faresystems belonging to that group. For example, to specify MUNI as one faresystem group, the right configuration would be: [[transit.journey_levels.manual]] level_id = 1 group_fare_systems = [25] If there are multiple groups required to be specified, for example, MUNI in one and Caltrain in the other group, it can be achieved by adding another entry of <code>manual</code>, like: [[transit.journey_levels.manual]] level_id = 1 group_fare_systems = [25][[transit.journey_levels.manual]] level_id = 2 group_fare_systems = [12,14]</p>"},{"location":"api/#tm2py.config.TransitJourneyLevelsConfig.specify_manually","title":"<code>specify_manually: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An alternative to using an algorithm to specify the journey levels is to use specify them manually.  If this option is set to <code>True</code>, the <code>manual</code> parameter can be used to assign fare systems to faresystem groups (or journey levels).  Consider, for example, the following three journey levels: 0 - has yet to board transit; 1 - has boarded SF Muni; 2 - has boarded all other transit systems.  To specify this configuration, a single <code>manual</code> entry identifying the SF Muni fare systems is needed.  The other faresystem group is automatically generated in the code with the rest of the faresystems which are not specified in any of the groups. See the <code>manual</code> entry for an example.</p>"},{"location":"api/#tm2py.config.TransitJourneyLevelsConfig.use_algorithm","title":"<code>use_algorithm: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The original translation from Cube to Emme used an algorithm to, as faithfully as possible, reflect transfer fares via journey levels.  The algorithm examines fare costs and proximity of transit services to create a set of journey levels that reflects transfer costs.  While this algorithm works well, the Bay Area\u2019s complex fare system results in numerous journey levels specific to operators with low ridership.  The resulting assignment compute therefore expends a lot of resources on these operators.  Set this parameter to <code>True</code> to use the algorithm. Exactly one of <code>use_algorithm</code> or <code>specify_manually</code> must be <code>True</code>.</p>"},{"location":"api/#tm2py.config.TransitJourneyLevelsConfig.check_exclusivity","title":"<code>check_exclusivity(v, values)</code>","text":"<p>Valdiates that exactly one of specify_manually and use_algorithm is True</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"specify_manually\")\ndef check_exclusivity(cls, v, values):\n    \"\"\"Valdiates that exactly one of specify_manually and use_algorithm is True\"\"\"\n    use_algorithm = values.get(\"use_algorithm\")\n    assert (\n        use_algorithm != v\n    ), 'Exactly one of \"use_algorithm\" or \"specify_manually\" must be True.'\n    return v\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig","title":"<code>TransitModeConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Transit mode definition (see also mode in the Emme API).</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TransitModeConfig(ConfigItem):\n    \"\"\"Transit mode definition (see also mode in the Emme API).\"\"\"\n\n    type: Literal[\n        \"WALK\",\n        \"ACCESS\",\n        \"EGRESS\",\n        \"LOCAL\",\n        \"PREMIUM\",\n        \"DRIVE\",\n        \"PNR_dummy\",\n        \"KNR_dummy\",\n    ]\n    assign_type: Literal[\"TRANSIT\", \"AUX_TRANSIT\"]\n    mode_id: str = Field(min_length=1, max_length=1)\n    name: str = Field(max_length=10)\n    description: Optional[str] = \"\"\n    in_vehicle_perception_factor: Optional[float] = Field(default=None, ge=0)\n    speed_or_time_factor: Optional[str] = Field(default=\"\")\n    initial_boarding_penalty: Optional[float] = Field(default=None, ge=0)\n    transfer_boarding_penalty: Optional[float] = Field(default=None, ge=0)\n    headway_fraction: Optional[float] = Field(default=None, ge=0)\n    transfer_wait_perception_factor: Optional[float] = Field(default=None, ge=0)\n    eawt_factor: Optional[float] = Field(default=1)\n\n    @validator(\"in_vehicle_perception_factor\", always=True)\n    def in_vehicle_perception_factor_valid(cls, value, values):\n        \"\"\"Validate in_vehicle_perception_factor exists if assign_type is TRANSIT.\"\"\"\n        if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n            assert value is not None, \"must be specified when assign_type==TRANSIT\"\n        return value\n\n    @validator(\"speed_or_time_factor\", always=True)\n    def speed_or_time_factor_valid(cls, value, values):\n        \"\"\"Validate speed_or_time_factor exists if assign_type is AUX_TRANSIT.\"\"\"\n        if \"assign_type\" in values and values[\"assign_type\"] == \"AUX_TRANSIT\":\n            assert value is not None, \"must be specified when assign_type==AUX_TRANSIT\"\n        return value\n\n    @validator(\"initial_boarding_penalty\", always=True)\n    def initial_boarding_penalty_valid(value, values):\n        \"\"\"Validate initial_boarding_penalty exists if assign_type is TRANSIT.\"\"\"\n        if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n            assert value is not None, \"must be specified when assign_type==TRANSIT\"\n        return value\n\n    @validator(\"transfer_boarding_penalty\", always=True)\n    def transfer_boarding_penalty_valid(value, values):\n        \"\"\"Validate transfer_boarding_penalty exists if assign_type is TRANSIT.\"\"\"\n        if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n            assert value is not None, \"must be specified when assign_type==TRANSIT\"\n        return value\n\n    @validator(\"headway_fraction\", always=True)\n    def headway_fraction_valid(value, values):\n        \"\"\"Validate headway_fraction exists if assign_type is TRANSIT.\"\"\"\n        if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n            assert value is not None, \"must be specified when assign_type==TRANSIT\"\n        return value\n\n    @validator(\"transfer_wait_perception_factor\", always=True)\n    def transfer_wait_perception_factor_valid(value, values):\n        \"\"\"Validate transfer_wait_perception_factor exists if assign_type is TRANSIT.\"\"\"\n        if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n            assert value is not None, \"must be specified when assign_type==TRANSIT\"\n        return value\n\n    @classmethod\n    @validator(\"mode_id\")\n    def mode_id_valid(cls, value):\n        \"\"\"Validate mode_id.\"\"\"\n        assert len(value) == 1, \"mode_id must be one character\"\n        return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.headway_fraction_valid","title":"<code>headway_fraction_valid(value, values)</code>","text":"<p>Validate headway_fraction exists if assign_type is TRANSIT.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"headway_fraction\", always=True)\ndef headway_fraction_valid(value, values):\n    \"\"\"Validate headway_fraction exists if assign_type is TRANSIT.\"\"\"\n    if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n        assert value is not None, \"must be specified when assign_type==TRANSIT\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.in_vehicle_perception_factor_valid","title":"<code>in_vehicle_perception_factor_valid(value, values)</code>","text":"<p>Validate in_vehicle_perception_factor exists if assign_type is TRANSIT.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"in_vehicle_perception_factor\", always=True)\ndef in_vehicle_perception_factor_valid(cls, value, values):\n    \"\"\"Validate in_vehicle_perception_factor exists if assign_type is TRANSIT.\"\"\"\n    if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n        assert value is not None, \"must be specified when assign_type==TRANSIT\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.initial_boarding_penalty_valid","title":"<code>initial_boarding_penalty_valid(value, values)</code>","text":"<p>Validate initial_boarding_penalty exists if assign_type is TRANSIT.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"initial_boarding_penalty\", always=True)\ndef initial_boarding_penalty_valid(value, values):\n    \"\"\"Validate initial_boarding_penalty exists if assign_type is TRANSIT.\"\"\"\n    if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n        assert value is not None, \"must be specified when assign_type==TRANSIT\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.mode_id_valid","title":"<code>mode_id_valid(value)</code>  <code>classmethod</code>","text":"<p>Validate mode_id.</p> Source code in <code>tm2py/config.py</code> <pre><code>@classmethod\n@validator(\"mode_id\")\ndef mode_id_valid(cls, value):\n    \"\"\"Validate mode_id.\"\"\"\n    assert len(value) == 1, \"mode_id must be one character\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.speed_or_time_factor_valid","title":"<code>speed_or_time_factor_valid(value, values)</code>","text":"<p>Validate speed_or_time_factor exists if assign_type is AUX_TRANSIT.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"speed_or_time_factor\", always=True)\ndef speed_or_time_factor_valid(cls, value, values):\n    \"\"\"Validate speed_or_time_factor exists if assign_type is AUX_TRANSIT.\"\"\"\n    if \"assign_type\" in values and values[\"assign_type\"] == \"AUX_TRANSIT\":\n        assert value is not None, \"must be specified when assign_type==AUX_TRANSIT\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.transfer_boarding_penalty_valid","title":"<code>transfer_boarding_penalty_valid(value, values)</code>","text":"<p>Validate transfer_boarding_penalty exists if assign_type is TRANSIT.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"transfer_boarding_penalty\", always=True)\ndef transfer_boarding_penalty_valid(value, values):\n    \"\"\"Validate transfer_boarding_penalty exists if assign_type is TRANSIT.\"\"\"\n    if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n        assert value is not None, \"must be specified when assign_type==TRANSIT\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.transfer_wait_perception_factor_valid","title":"<code>transfer_wait_perception_factor_valid(value, values)</code>","text":"<p>Validate transfer_wait_perception_factor exists if assign_type is TRANSIT.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"transfer_wait_perception_factor\", always=True)\ndef transfer_wait_perception_factor_valid(value, values):\n    \"\"\"Validate transfer_wait_perception_factor exists if assign_type is TRANSIT.\"\"\"\n    if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n        assert value is not None, \"must be specified when assign_type==TRANSIT\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitVehicleConfig","title":"<code>TransitVehicleConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Transit vehicle definition (see also transit vehicle in the Emme API).</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TransitVehicleConfig(ConfigItem):\n    \"\"\"Transit vehicle definition (see also transit vehicle in the Emme API).\"\"\"\n\n    vehicle_id: Optional[int] = Field(default=None, ge=0)\n    mode: Optional[str] = Field(default=\"\")\n    name: Optional[str] = Field(default=\"\")\n    auto_equivalent: Optional[float] = Field(default=0, ge=0)\n    seated_capacity: Optional[int] = Field(default=None, ge=0)\n    total_capacity: Optional[int] = Field(default=None, ge=0)\n</code></pre>"},{"location":"api/#tm2py.config.TripDistributionClassConfig","title":"<code>TripDistributionClassConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Trip Distribution parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TripDistributionClassConfig(ConfigItem):\n    \"\"\"Trip Distribution parameters.\n\n    Properties:\n        name: name of class to apply to\n        impedance_name: refers to an impedance (skim) matrix to use - often a blended skim.\n        use_k_factors: boolean on if to use k-factors\n    \"\"\"\n\n    name: str\n    impedance: str\n    use_k_factors: bool\n</code></pre>"},{"location":"api/#tm2py.config.TripDistributionConfig","title":"<code>TripDistributionConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Trip Distribution parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TripDistributionConfig(ConfigItem):\n    \"\"\"Trip Distribution parameters.\"\"\"\n\n    classes: List[TripDistributionClassConfig]\n    max_balance_iterations: int\n    max_balance_relative_error: float\n    friction_factors_file: pathlib.Path\n    k_factors_file: Optional[pathlib.Path] = None\n</code></pre>"},{"location":"api/#tm2py.config.TripGenerationClassConfig","title":"<code>TripGenerationClassConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Trip Generation parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TripGenerationClassConfig(ConfigItem):\n    \"\"\"Trip Generation parameters.\"\"\"\n\n    name: str\n    purpose: Optional[str] = Field(default=None)\n    production_formula: Optional[TripGenerationFormulaConfig] = Field(default=None)\n    attraction_formula: Optional[TripGenerationFormulaConfig] = Field(default=None)\n    balance_to: Optional[str] = Field(default=\"production\")\n</code></pre>"},{"location":"api/#tm2py.config.TripGenerationConfig","title":"<code>TripGenerationConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Trip Generation parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TripGenerationConfig(ConfigItem):\n    \"\"\"Trip Generation parameters.\"\"\"\n\n    classes: List[TripGenerationClassConfig]\n</code></pre>"},{"location":"api/#tm2py.config.TripGenerationFormulaConfig","title":"<code>TripGenerationFormulaConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>TripProductionConfig.</p> <p>Trip productions or attractions for a zone are the constant plus the sum of the rates * values in land use file for that zone.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TripGenerationFormulaConfig(ConfigItem):\n    \"\"\"TripProductionConfig.\n\n    Trip productions or attractions for a zone are the constant plus the sum of the rates * values\n    in land use file for that zone.\n    \"\"\"\n\n    land_use_rates: List[CoefficientConfig]\n    constant: Optional[float] = Field(default=0.0)\n    multiplier: Optional[float] = Field(default=1.0)\n</code></pre>"},{"location":"api/#tm2py.config.TruckClassConfig","title":"<code>TruckClassConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Truck class parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TruckClassConfig(ConfigItem):\n    \"\"\"Truck class parameters.\"\"\"\n\n    name: str\n    description: Optional[str] = \"\"\n</code></pre>"},{"location":"api/#tm2py.config.TruckConfig","title":"<code>TruckConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Truck model parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TruckConfig(ConfigItem):\n    \"\"\"Truck model parameters.\"\"\"\n\n    classes: List[TruckClassConfig]\n    impedances: List[ImpedanceConfig]\n    trip_gen: TripGenerationConfig\n    trip_dist: TripDistributionConfig\n    time_of_day: TimeOfDayConfig\n    toll_choice: TollChoiceConfig\n    output_trip_table_directory: pathlib.Path\n    outfile_trip_table_tmp: str\n    highway_demand_file: str\n\n    \"\"\"\n    @validator(\"classes\")\n    def class_consistency(cls, v, values):\n        # TODO Can't get to work righ tnow\n        _class_names = [c.name for c in v]\n        _gen_classes = [c.name for c in values[\"trip_gen\"]]\n        _dist_classes = [c.name for c in values[\"trip_dist\"]]\n        _time_classes = [c.name for c in values[\"time_split\"]]\n        _toll_classes = [c.name for c in values[\"toll_choice\"]]\n\n        assert (\n            _class_names == _gen_classes\n        ), \"truck.classes ({_class_names}) doesn't equal\\\n            class names in truck.trip_gen ({_gen_classes}).\"\n        assert (\n            _class_names == _dist_classes\n        ), \"truck.classes ({_class_names}) doesn't  equal\\\n            class names in truck.trip_dist ({_dist_classes}).\"\n        assert (\n            _class_names == _time_classes\n        ), \"truck.classes ({_class_names}) doesn't  equal\\\n            class names in truck.time_split ({_time_classes}).\"\n        assert (\n            _class_names == _toll_classes\n        ), \"truck.classes ({_class_names}) doesn't equal\\\n            class names in truck.toll_choice ({_toll_classes}).\"\n\n        return v\n    \"\"\"\n</code></pre>"},{"location":"api/#tm2py.config.TruckConfig.highway_demand_file","title":"<code>highway_demand_file: str</code>  <code>instance-attribute</code>","text":"<p>@validator(\u201cclasses\u201d) def class_consistency(cls, v, values):     # TODO Can\u2019t get to work righ tnow     _class_names = [c.name for c in v]     _gen_classes = [c.name for c in values[\u201ctrip_gen\u201d]]     _dist_classes = [c.name for c in values[\u201ctrip_dist\u201d]]     _time_classes = [c.name for c in values[\u201ctime_split\u201d]]     _toll_classes = [c.name for c in values[\u201ctoll_choice\u201d]]</p> <pre><code>assert (\n    _class_names == _gen_classes\n), \"truck.classes ({_class_names}) doesn't equal            class names in truck.trip_gen ({_gen_classes}).\"\nassert (\n    _class_names == _dist_classes\n), \"truck.classes ({_class_names}) doesn't  equal            class names in truck.trip_dist ({_dist_classes}).\"\nassert (\n    _class_names == _time_classes\n), \"truck.classes ({_class_names}) doesn't  equal            class names in truck.time_split ({_time_classes}).\"\nassert (\n    _class_names == _toll_classes\n), \"truck.classes ({_class_names}) doesn't equal            class names in truck.toll_choice ({_toll_classes}).\"\n\nreturn v\n</code></pre>"},{"location":"api/#tm2py.config.WarmStartConfig","title":"<code>WarmStartConfig</code>","text":"<p>               Bases: <code>ConfigItem</code></p> <p>Warm start parameters.</p> <p>Note that the components will be executed in the order listed.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass WarmStartConfig(ConfigItem):\n    \"\"\"Warm start parameters.\n\n    Note that the components will be executed in the order listed.\n\n    Properties:\n        warmstart: Boolean indicating whether warmstart demand matrices are used.\n            If set to True, the global iteration 0 will either assign warmstart demand for highway and transit, or skip the assignment and just use warmstart skims.\n            If set to False, the global iteration 0 will assign zero demand for highway and transit.\n        warmstart_skim: Boolean indicating whether to use warmstart skims. If set to True, then skips warmstart assignment in iteraton 0.\n        warmstart_demand: Boolean indicating whether to use warmstart demand. If set to True, then runs warmstart assignment in iteration 0.\n        warmstart_check: if on, check that demand matrix files exist.\n        household_highway_demand_file: file name template of warmstart household highway demand matrices.\n        household_transit_demand_file: file name template of warmstart household transit demand matrices.\n        air_passenger_highway_demand_file: file name template of warmstart airport highway demand matrices.\n        internal_external_highway_demand_file: file name template of warmstart internal-external highway demand matrices.\n    \"\"\"\n\n    warmstart: bool = Field(default=True)\n    use_warmstart_skim: bool = Field(default=True)\n    use_warmstart_demand: bool = Field(default=False)\n    warmstart_check: Optional[bool] = Field(default=False)\n    household_highway_demand_file: Optional[str] = Field(default=\"\")\n    household_transit_demand_file: Optional[str] = Field(default=\"\")\n    air_passenger_highway_demand_file: Optional[str] = Field(default=\"\")\n    internal_external_highway_demand_file: Optional[str] = Field(default=\"\")\n    truck_highway_demand_file: Optional[str] = Field(default=\"\")\n\n    @validator(\"warmstart\", allow_reuse=True)\n    def check_warmstart_method(cls, value, values):\n        \"\"\"When warmstart, either skim or demand should be true.\"\"\"\n        if values.get(\"warmstart\"):\n            assert (\n                values.use_warmstart_skim != values.use_warmstart_demand\n            ), f\"'warmstart is on, only one of' {values.use_warmstart_skim} and {values.use_warmstart_demand} can be true\"\n        return value\n</code></pre>"},{"location":"api/#tm2py.config.WarmStartConfig.check_warmstart_method","title":"<code>check_warmstart_method(value, values)</code>","text":"<p>When warmstart, either skim or demand should be true.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"warmstart\", allow_reuse=True)\ndef check_warmstart_method(cls, value, values):\n    \"\"\"When warmstart, either skim or demand should be true.\"\"\"\n    if values.get(\"warmstart\"):\n        assert (\n            values.use_warmstart_skim != values.use_warmstart_demand\n        ), f\"'warmstart is on, only one of' {values.use_warmstart_skim} and {values.use_warmstart_demand} can be true\"\n    return value\n</code></pre>"},{"location":"api/#components","title":"Components","text":""},{"location":"api/#base-component","title":"Base Component","text":"<p>Root component ABC.</p>"},{"location":"api/#tm2py.components.component.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Template for Component class with several built-in methods.</p> <p>A component is a piece of the model that can be run independently (of other components) given the required input data and configuration.  It communicates information to other components via disk I/O (including the emmebank).</p> <p>Note: if the component needs data that is not written to disk, it would be considered a subcomponent.</p> <p>Abstract Methods \u2013\u00a0Each component class must have the following methods:     __init___: constructor, which associates the RunController with the instantiated object     run: run the component without any arguments     validate_inputs: validate the inputs to the component     report_progress: report progress to the user     verify: verify the component\u2019s output     write_top_sheet: write outputs to topsheet     test_component: test the component</p> Template Class methods - component classes inherit Template Class Properties - component classes inherit <p>::     class MyComponent(Component):</p> <pre><code>def __init__(self, controller):\n    super().__init__(controller)\n    self._parameter = None\n\ndef run(self):\n    self._step1()\n    self._step2()\n\ndef _step1(self):\n    pass\n\ndef _step2(self):\n    pass\n</code></pre> Source code in <code>tm2py/components/component.py</code> <pre><code>class Component(ABC):\n    \"\"\"Template for Component class with several built-in methods.\n\n    A component is a piece of the model that can be run independently (of other components) given\n    the required input data and configuration.  It communicates information to other components via\n    disk I/O (including the emmebank).\n\n    Note: if the component needs data that is not written to disk, it would be considered a\n    subcomponent.\n\n    Abstract Methods \u2013\u00a0Each component class must have the following methods:\n        __init___: constructor, which associates the RunController with the instantiated object\n        run: run the component without any arguments\n        validate_inputs: validate the inputs to the component\n        report_progress: report progress to the user\n        verify: verify the component's output\n        write_top_sheet: write outputs to topsheet\n        test_component: test the component\n\n    Template Class methods - component classes inherit:\n        get_abs_path: convenience method to get absolute path of the run directory\n\n\n    Template Class Properties - component classes inherit:\n        controller: RunController object\n        config: Config object\n        time_period_names: convenience property\n        top_sheet: topsheet object\n        logger: logger object\n        trace: trace object\n\n    Example:\n    ::\n        class MyComponent(Component):\n\n        def __init__(self, controller):\n            super().__init__(controller)\n            self._parameter = None\n\n        def run(self):\n            self._step1()\n            self._step2()\n\n        def _step1(self):\n            pass\n\n        def _step2(self):\n            pass\n    \"\"\"\n\n    def __init__(self, controller: RunController):\n        \"\"\"Model component template/abstract base class.\n\n        Args:\n            controller (RunController): Reference to the run controller object.\n        \"\"\"\n        self._controller = controller\n        self._trace = None\n\n        self._controller.logger.detail(f\"Initializing component {type(self).__qualname__}\")\n\n    @property\n    def controller(self):\n        \"\"\"Parent controller.\"\"\"\n        return self._controller\n\n    @property\n    def emme_manager(self):\n        return self.controller.emme_manager\n\n    def get_abs_path(self, path: Union[Path, str]) -&gt; str:\n        \"\"\"Convenince method to get absolute path from run directory.\"\"\"\n        if not os.path.isabs(path):\n            return self.controller.get_abs_path(path).__str__()\n        else:\n            return path\n\n    @property\n    def time_period_names(self) -&gt; List[str]:\n        \"\"\"Return input time_period name or names and return list of time_period names.\n\n        Implemented here for easy access for all components.\n\n        Returns: list of uppercased string names of time periods\n        \"\"\"\n        return self.controller.time_period_names\n\n    @property\n    def time_period_durations(self) -&gt; dict:\n        \"\"\"Return mapping of time periods to durations in hours.\"\"\"\n        return self.controller.time_period_durations\n\n    @property\n    def congested_transit_assn_max_iteration(self) -&gt; dict:\n        \"\"\"Return mapping of time periods to max iteration in congested transit assignment.\"\"\"\n        return self.controller.congested_transit_assn_max_iteration\n\n    @property\n    def top_sheet(self):\n        \"\"\"Reference to top sheet.\"\"\"\n        return self.controller.top_sheet\n\n    @property\n    def logger(self):\n        \"\"\"Reference to logger.\"\"\"\n        return self.controller.logger\n\n    @property\n    def trace(self):\n        \"\"\"Reference to trace.\"\"\"\n        return self._trace\n\n    @abstractmethod\n    def validate_inputs(self):\n        \"\"\"Validate inputs are correct at model initiation, raise on error.\"\"\"\n\n    @abstractmethod\n    def run(self):\n        \"\"\"Run model component.\"\"\"\n\n    # @abstractmethod\n    def report_progress(self):\n        \"\"\"Write progress to log file.\"\"\"\n\n    # @abstractmethod\n    def verify(self):\n        \"\"\"Verify component outputs / results.\"\"\"\n\n    # @abstractmethod\n    def write_top_sheet(self):\n        \"\"\"Write key outputs to the model top sheet.\"\"\"\n</code></pre>"},{"location":"api/#tm2py.components.component.Component.congested_transit_assn_max_iteration","title":"<code>congested_transit_assn_max_iteration: dict</code>  <code>property</code>","text":"<p>Return mapping of time periods to max iteration in congested transit assignment.</p>"},{"location":"api/#tm2py.components.component.Component.controller","title":"<code>controller</code>  <code>property</code>","text":"<p>Parent controller.</p>"},{"location":"api/#tm2py.components.component.Component.logger","title":"<code>logger</code>  <code>property</code>","text":"<p>Reference to logger.</p>"},{"location":"api/#tm2py.components.component.Component.time_period_durations","title":"<code>time_period_durations: dict</code>  <code>property</code>","text":"<p>Return mapping of time periods to durations in hours.</p>"},{"location":"api/#tm2py.components.component.Component.time_period_names","title":"<code>time_period_names: List[str]</code>  <code>property</code>","text":"<p>Return input time_period name or names and return list of time_period names.</p> <p>Implemented here for easy access for all components.</p> <p>Returns: list of uppercased string names of time periods</p>"},{"location":"api/#tm2py.components.component.Component.top_sheet","title":"<code>top_sheet</code>  <code>property</code>","text":"<p>Reference to top sheet.</p>"},{"location":"api/#tm2py.components.component.Component.trace","title":"<code>trace</code>  <code>property</code>","text":"<p>Reference to trace.</p>"},{"location":"api/#tm2py.components.component.Component.__init__","title":"<code>__init__(controller)</code>","text":"<p>Model component template/abstract base class.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>Reference to the run controller object.</p> required Source code in <code>tm2py/components/component.py</code> <pre><code>def __init__(self, controller: RunController):\n    \"\"\"Model component template/abstract base class.\n\n    Args:\n        controller (RunController): Reference to the run controller object.\n    \"\"\"\n    self._controller = controller\n    self._trace = None\n\n    self._controller.logger.detail(f\"Initializing component {type(self).__qualname__}\")\n</code></pre>"},{"location":"api/#tm2py.components.component.Component.get_abs_path","title":"<code>get_abs_path(path)</code>","text":"<p>Convenince method to get absolute path from run directory.</p> Source code in <code>tm2py/components/component.py</code> <pre><code>def get_abs_path(self, path: Union[Path, str]) -&gt; str:\n    \"\"\"Convenince method to get absolute path from run directory.\"\"\"\n    if not os.path.isabs(path):\n        return self.controller.get_abs_path(path).__str__()\n    else:\n        return path\n</code></pre>"},{"location":"api/#tm2py.components.component.Component.report_progress","title":"<code>report_progress()</code>","text":"<p>Write progress to log file.</p> Source code in <code>tm2py/components/component.py</code> <pre><code>def report_progress(self):\n    \"\"\"Write progress to log file.\"\"\"\n</code></pre>"},{"location":"api/#tm2py.components.component.Component.run","title":"<code>run()</code>  <code>abstractmethod</code>","text":"<p>Run model component.</p> Source code in <code>tm2py/components/component.py</code> <pre><code>@abstractmethod\ndef run(self):\n    \"\"\"Run model component.\"\"\"\n</code></pre>"},{"location":"api/#tm2py.components.component.Component.validate_inputs","title":"<code>validate_inputs()</code>  <code>abstractmethod</code>","text":"<p>Validate inputs are correct at model initiation, raise on error.</p> Source code in <code>tm2py/components/component.py</code> <pre><code>@abstractmethod\ndef validate_inputs(self):\n    \"\"\"Validate inputs are correct at model initiation, raise on error.\"\"\"\n</code></pre>"},{"location":"api/#tm2py.components.component.Component.verify","title":"<code>verify()</code>","text":"<p>Verify component outputs / results.</p> Source code in <code>tm2py/components/component.py</code> <pre><code>def verify(self):\n    \"\"\"Verify component outputs / results.\"\"\"\n</code></pre>"},{"location":"api/#tm2py.components.component.Component.write_top_sheet","title":"<code>write_top_sheet()</code>","text":"<p>Write key outputs to the model top sheet.</p> Source code in <code>tm2py/components/component.py</code> <pre><code>def write_top_sheet(self):\n    \"\"\"Write key outputs to the model top sheet.\"\"\"\n</code></pre>"},{"location":"api/#tm2py.components.component.FileFormatError","title":"<code>FileFormatError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a file is not in the expected format.</p> Source code in <code>tm2py/components/component.py</code> <pre><code>class FileFormatError(Exception):\n    \"\"\"Exception raised when a file is not in the expected format.\"\"\"\n\n    def __init__(self, f, *args):\n        \"\"\"Exception for invalid file formats.\"\"\"\n        super().__init__(args)\n        self.f = f\n\n    def __str__(self):\n        \"\"\"String representation for FileFormatError.\"\"\"\n        return f\"The {self.f} is not a valid format.\"\n</code></pre>"},{"location":"api/#tm2py.components.component.FileFormatError.__init__","title":"<code>__init__(f, *args)</code>","text":"<p>Exception for invalid file formats.</p> Source code in <code>tm2py/components/component.py</code> <pre><code>def __init__(self, f, *args):\n    \"\"\"Exception for invalid file formats.\"\"\"\n    super().__init__(args)\n    self.f = f\n</code></pre>"},{"location":"api/#tm2py.components.component.FileFormatError.__str__","title":"<code>__str__()</code>","text":"<p>String representation for FileFormatError.</p> Source code in <code>tm2py/components/component.py</code> <pre><code>def __str__(self):\n    \"\"\"String representation for FileFormatError.\"\"\"\n    return f\"The {self.f} is not a valid format.\"\n</code></pre>"},{"location":"api/#tm2py.components.component.Subcomponent","title":"<code>Subcomponent</code>","text":"<p>               Bases: <code>Component</code></p> <p>Template for sub-component class.</p> <p>A sub-component is a more loosly defined component that allows for input into the run() method.  It is used to break-up larger processes into smaller chunks which can be: (1) re-used across components (i.e toll choice) (2) updated/subbed in to a parent component(s) run method based on the expected API (3) easier to test, understand and debug. (4) more consistent with the algorithms we understand from transportation planning 101</p> Source code in <code>tm2py/components/component.py</code> <pre><code>class Subcomponent(Component):\n    \"\"\"Template for sub-component class.\n\n    A sub-component is a more loosly defined component that allows for input into the run()\n    method.  It is used to break-up larger processes into smaller chunks which can be:\n    (1) re-used across components (i.e toll choice)\n    (2) updated/subbed in to a parent component(s) run method based on the expected API\n    (3) easier to test, understand and debug.\n    (4) more consistent with the algorithms we understand from transportation planning 101\n    \"\"\"\n\n    def __init__(self, controller: RunController, component: Component):\n        \"\"\"Constructor for model sub-component abstract base class.\n\n        Only calls the super class constructor.\n\n        Args:\n            controller (RunController): Reference to the run controller object.\n            component (Component): Reference to the parent component object.\n        \"\"\"\n        super().__init__(controller)\n        self.component = component\n\n    @abstractmethod\n    def run(self, *args, **kwargs):\n        \"\"\"Run sub-component, allowing for multiple inputs.\n\n        Allowing for inputs to the run() method is what differentiates a sub-component from\n        a component.\n        \"\"\"\n</code></pre>"},{"location":"api/#tm2py.components.component.Subcomponent.__init__","title":"<code>__init__(controller, component)</code>","text":"<p>Constructor for model sub-component abstract base class.</p> <p>Only calls the super class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>Reference to the run controller object.</p> required <code>component</code> <code>Component</code> <p>Reference to the parent component object.</p> required Source code in <code>tm2py/components/component.py</code> <pre><code>def __init__(self, controller: RunController, component: Component):\n    \"\"\"Constructor for model sub-component abstract base class.\n\n    Only calls the super class constructor.\n\n    Args:\n        controller (RunController): Reference to the run controller object.\n        component (Component): Reference to the parent component object.\n    \"\"\"\n    super().__init__(controller)\n    self.component = component\n</code></pre>"},{"location":"api/#tm2py.components.component.Subcomponent.run","title":"<code>run(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Run sub-component, allowing for multiple inputs.</p> <p>Allowing for inputs to the run() method is what differentiates a sub-component from a component.</p> Source code in <code>tm2py/components/component.py</code> <pre><code>@abstractmethod\ndef run(self, *args, **kwargs):\n    \"\"\"Run sub-component, allowing for multiple inputs.\n\n    Allowing for inputs to the run() method is what differentiates a sub-component from\n    a component.\n    \"\"\"\n</code></pre>"},{"location":"api/#demand-components","title":"Demand Components","text":"<p>Demand loading from OMX to Emme database.</p>"},{"location":"api/#tm2py.components.demand.prepare_demand.EmmeDemand","title":"<code>EmmeDemand</code>","text":"<p>Abstract base class to import and average demand.</p> Source code in <code>tm2py/components/demand/prepare_demand.py</code> <pre><code>class EmmeDemand:\n    \"\"\"Abstract base class to import and average demand.\"\"\"\n\n    def __init__(self, controller: RunController):\n        \"\"\"Constructor for PrepareDemand class.\n\n        Args:\n            controller (RunController): Run controller for the current run.\n        \"\"\"\n        self.controller = controller\n        self._emmebank = None\n        self._scenario = None\n        self._source_ref_key = None\n\n    @property\n    def logger(self):\n        \"\"\"Reference to logger.\"\"\"\n        return self.controller.logger\n\n    def _read(\n        self, path: str, name: str, num_zones, factor: float = None\n    ) -&gt; NumpyArray:\n        \"\"\"Read matrix array from OMX file at path with name, and multiple by factor (if specified).\n\n        Args:\n            path: full path to OMX file\n            name: name of the OMX matrix / key\n            factor: optional factor to apply to matrix\n        \"\"\"\n        with OMXManager(path, \"r\") as omx_file:\n            demand = omx_file.read(name)\n            omx_file.close()\n        if factor is not None:\n            demand = factor * demand\n        demand = self._redim_demand(demand, num_zones)\n        # self.logger.log(f\"{name} sum: {demand.sum()}\", level=3)\n        return demand\n\n    @staticmethod\n    def _redim_demand(demand, num_zones):\n        _shape = demand.shape\n        if _shape &lt; (num_zones, num_zones):\n            demand = np.pad(\n                demand, ((0, num_zones - _shape[0]), (0, num_zones - _shape[1]))\n            )\n        elif _shape &gt; (num_zones, num_zones):\n            ValueError(\n                f\"Provided demand matrix is larger ({_shape}) than the \\\n                specified number of zones: {num_zones}\"\n            )\n\n        return demand\n\n    def _save_demand(\n        self,\n        name: str,\n        demand: NumpyArray,\n        description: str = None,\n        apply_msa: bool = False,\n    ):\n        \"\"\"Save demand array to Emme matrix with name, optional description.\n\n        Matrix will be created if it does not exist and the model is on iteration 0.\n\n        Args:\n            name: name of the matrix in the Emmebank\n            demand: NumpyArray, demand array to save\n            description: str, optional description to use in the Emmebank\n            apply_msa: bool, default False: use MSA on matrix with current array\n                values if model is on iteration &gt;= 1\n        \"\"\"\n        matrix = self._emmebank.emmebank.matrix(f'mf\"{name}\"')\n        msa_iteration = self.controller.iteration\n        if not apply_msa or msa_iteration &lt;= 1:\n            if not matrix:\n                ident = self._emmebank.emmebank.available_matrix_identifier(\"FULL\")\n                matrix = self._emmebank.emmebank.create_matrix(ident)\n                matrix.name = name\n                if description is not None:\n                    matrix.description = description\n        else:\n            if not matrix:\n                raise Exception(f\"error averaging demand: matrix {name} does not exist\")\n            prev_demand = matrix.get_numpy_data(self._scenario.id)\n            demand = prev_demand + (1.0 / msa_iteration) * (demand - prev_demand)\n        self.logger.log(f\"{name} sum: {demand.sum()}\", level=\"DEBUG\")\n        matrix.set_numpy_data(demand, self._scenario.id)\n</code></pre>"},{"location":"api/#tm2py.components.demand.prepare_demand.EmmeDemand.logger","title":"<code>logger</code>  <code>property</code>","text":"<p>Reference to logger.</p>"},{"location":"api/#tm2py.components.demand.prepare_demand.EmmeDemand.__init__","title":"<code>__init__(controller)</code>","text":"<p>Constructor for PrepareDemand class.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>Run controller for the current run.</p> required Source code in <code>tm2py/components/demand/prepare_demand.py</code> <pre><code>def __init__(self, controller: RunController):\n    \"\"\"Constructor for PrepareDemand class.\n\n    Args:\n        controller (RunController): Run controller for the current run.\n    \"\"\"\n    self.controller = controller\n    self._emmebank = None\n    self._scenario = None\n    self._source_ref_key = None\n</code></pre>"},{"location":"api/#tm2py.components.demand.prepare_demand.PrepareHighwayDemand","title":"<code>PrepareHighwayDemand</code>","text":"<p>               Bases: <code>EmmeDemand</code></p> <p>Import and average highway demand.</p> <p>Demand is imported from OMX files based on reference file paths and OMX matrix names in highway assignment config (highway.classes). The demand is average using MSA with the current demand matrices (in the Emmebank) if the controller.iteration &gt; 1.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>parent RunController object</p> required Source code in <code>tm2py/components/demand/prepare_demand.py</code> <pre><code>class PrepareHighwayDemand(EmmeDemand):\n    \"\"\"Import and average highway demand.\n\n    Demand is imported from OMX files based on reference file paths and OMX\n    matrix names in highway assignment config (highway.classes).\n    The demand is average using MSA with the current demand matrices\n    (in the Emmebank) if the controller.iteration &gt; 1.\n\n    Args:\n        controller: parent RunController object\n    \"\"\"\n\n    def __init__(self, controller: RunController):\n        \"\"\"Constructor for PrepareHighwayDemand.\n\n        Args:\n            controller (RunController): Reference to run controller object.\n        \"\"\"\n        super().__init__(controller)\n        self.controller = controller\n        self.config = self.controller.config.highway\n        self._highway_emmebank = None\n\n    def validate_inputs(self):\n        # TODO\n        pass\n\n    @property\n    def highway_emmebank(self):\n        if self._highway_emmebank == None:\n            self._highway_emmebank = self.controller.emme_manager.highway_emmebank\n            self._emmebank = self._highway_emmebank\n        return self._highway_emmebank\n\n    # @LogStartEnd(\"prepare highway demand\")\n    def run(self):\n        \"\"\"Open combined demand OMX files from demand models and prepare for assignment.\"\"\"\n\n        self.highway_emmebank.create_zero_matrix()\n        for time in self.controller.time_period_names:\n            for klass in self.config.classes:\n                self._prepare_demand(klass.name, klass.description, klass.demand, time)\n\n    def _prepare_demand(\n        self,\n        name: str,\n        description: str,\n        demand_config: List[Dict[str, Union[str, float]]],\n        time_period: str,\n    ):\n        \"\"\"Load demand from OMX files and save to Emme matrix for highway assignment.\n\n        Average with previous demand (MSA) if the current iteration &gt; 1\n\n        Args:\n            name (str): the name of the highway assignment class\n            description (str): the description for the highway assignment class\n            demand_config (dict): the list of file cross-reference(s) for the demand to be loaded\n                {\"source\": &lt;name of demand model component&gt;,\n                 \"name\": &lt;OMX key name&gt;,\n                 \"factor\": &lt;factor to apply to demand in this file&gt;}\n            time_period (str): the time time_period ID (name)\n        \"\"\"\n        self._scenario = self.highway_emmebank.scenario(time_period)\n        num_zones = len(self._scenario.zone_numbers)\n        demand = self._read_demand(demand_config[0], time_period, num_zones)\n        for file_config in demand_config[1:]:\n            demand = demand + self._read_demand(file_config, time_period, num_zones)\n        demand_name = f\"{time_period}_{name}\"\n        description = f\"{time_period} {description} demand\"\n        self._save_demand(\n            demand_name, demand, description, apply_msa=self.config.apply_msa_demand\n        )\n\n    def _read_demand(self, file_config, time_period, num_zones):\n        # Load demand from cross-referenced source file,\n        # the named demand model component under the key highway_demand_file\n        source = file_config[\"source\"]\n        name = file_config[\"name\"].format(period=time_period.upper())\n        path = self.controller.get_abs_path(\n            self.controller.config[source].highway_demand_file\n        ).__str__()\n        return self._read(\n            path.format(period=time_period, iter=self.controller.iteration),\n            name,\n            num_zones,\n        )\n\n    @LogStartEnd(\"Prepare household demand matrices.\")\n    def prepare_household_demand(self):\n        \"\"\"Prepares highway and transit household demand matrices from trip lists produced by CT-RAMP.\"\"\"\n        iteration = self.controller.iteration\n\n        # Create folders if they don't exist\n        pathlib.Path(\n            self.controller.get_abs_path(\n                self.controller.config.household.highway_demand_file\n            )\n        ).parents[0].mkdir(parents=True, exist_ok=True)\n        pathlib.Path(\n            self.controller.get_abs_path(\n                self.controller.config.household.transit_demand_file\n            )\n        ).parents[0].mkdir(parents=True, exist_ok=True)\n        #    pathlib.Path(self.controller.get_abs_path(self.controller.config.household.active_demand_file)).parents[0].mkdir(parents=True, exist_ok=True)\n\n        indiv_trip_file = (\n            self.controller.config.household.ctramp_indiv_trip_file.format(\n                iteration=iteration\n            )\n        )\n        joint_trip_file = (\n            self.controller.config.household.ctramp_joint_trip_file.format(\n                iteration=iteration\n            )\n        )\n        it_full, jt_full = pd.read_csv(indiv_trip_file), pd.read_csv(joint_trip_file)\n\n        # Add time period, expanded count\n        time_period_start = dict(\n            zip(\n                [c.name.upper() for c in self.controller.config.time_periods],\n                [c.start_period for c in self.controller.config.time_periods],\n            )\n        )\n        # the last time period needs to be filled in because the first period may or may not start at midnight\n        time_periods_sorted = sorted(\n            time_period_start, key=lambda x: time_period_start[x]\n        )  # in upper case\n        first_period = time_periods_sorted[0]\n        periods_except_last = time_periods_sorted[:-1]\n        breakpoints = [time_period_start[tp] for tp in time_periods_sorted]\n        it_full[\"time_period\"] = (\n            pd.cut(\n                it_full.stop_period,\n                breakpoints,\n                right=False,\n                labels=periods_except_last,\n            )\n            .cat.add_categories(time_periods_sorted[-1])\n            .fillna(time_periods_sorted[-1])\n            .astype(str)\n        )\n        jt_full[\"time_period\"] = (\n            pd.cut(\n                jt_full.stop_period,\n                breakpoints,\n                right=False,\n                labels=periods_except_last,\n            )\n            .cat.add_categories(time_periods_sorted[-1])\n            .fillna(time_periods_sorted[-1])\n            .astype(str)\n        )\n        it_full[\"eq_cnt\"] = 1 / it_full.sampleRate\n        it_full[\"eq_cnt\"] = np.where(\n            it_full[\"trip_mode\"].isin([3, 4, 5]),\n            0.5 * it_full[\"eq_cnt\"],\n            np.where(\n                it_full[\"trip_mode\"].isin([6, 7, 8]),\n                0.35 * it_full[\"eq_cnt\"],\n                it_full[\"eq_cnt\"],\n            ),\n        )\n        jt_full[\"eq_cnt\"] = jt_full.num_participants / jt_full.sampleRate\n        zp_cav = self.controller.config.household.OwnedAV_ZPV_factor\n        zp_tnc = self.controller.config.household.TNC_ZPV_factor\n\n        maz_taz_df = pd.read_csv(\n            self.controller.get_abs_path(self.controller.config.scenario.landuse_file),\n            usecols=[\"MAZ\", \"TAZ\"],\n        )\n        it_full = it_full.merge(\n            maz_taz_df, left_on=\"orig_mgra\", right_on=\"MAZ\", how=\"left\"\n        ).rename(columns={\"TAZ\": \"orig_taz\"})\n        it_full = it_full.merge(\n            maz_taz_df, left_on=\"dest_mgra\", right_on=\"MAZ\", how=\"left\"\n        ).rename(columns={\"TAZ\": \"dest_taz\"})\n        jt_full = jt_full.merge(\n            maz_taz_df, left_on=\"orig_mgra\", right_on=\"MAZ\", how=\"left\"\n        ).rename(columns={\"TAZ\": \"orig_taz\"})\n        jt_full = jt_full.merge(\n            maz_taz_df, left_on=\"dest_mgra\", right_on=\"MAZ\", how=\"left\"\n        ).rename(columns={\"TAZ\": \"dest_taz\"})\n        it_full[\"trip_mode\"] = np.where(\n            it_full[\"trip_mode\"] == 14, 13, it_full[\"trip_mode\"]\n        )\n        jt_full[\"trip_mode\"] = np.where(\n            jt_full[\"trip_mode\"] == 14, 13, jt_full[\"trip_mode\"]\n        )\n\n        num_zones = self.num_internal_zones\n        OD_full_index = pd.MultiIndex.from_product(\n            [range(1, num_zones + 1), range(1, num_zones + 1)]\n        )\n\n        def combine_trip_lists(it, jt, trip_mode):\n            # combines individual trip list and joint trip list\n            combined_trips = pd.concat(\n                [it[(it[\"trip_mode\"] == trip_mode)], jt[(jt[\"trip_mode\"] == trip_mode)]]\n            )\n            combined_sum = combined_trips.groupby([\"orig_taz\", \"dest_taz\"])[\n                \"eq_cnt\"\n            ].sum()\n            return combined_sum.reindex(OD_full_index, fill_value=0).unstack().values\n\n        def create_zero_passenger_trips(\n            trips, deadheading_factor, trip_modes=[1, 2, 3]\n        ):\n            zpv_trips = trips.loc[\n                (trips[\"avAvailable\"] == 1) &amp; (trips[\"trip_mode\"].isin(trip_modes))\n            ]\n            zpv_trips[\"eq_cnt\"] = zpv_trips[\"eq_cnt\"] * deadheading_factor\n            zpv_trips = zpv_trips.rename(\n                columns={\"dest_taz\": \"orig_taz\", \"orig_taz\": \"dest_taz\"}\n            )\n            return zpv_trips\n\n        # create zero passenger trips for auto modes\n        if it_full[\"avAvailable\"].sum() &gt; 0:\n            it_zpav_trp = create_zero_passenger_trips(\n                it_full, zp_cav, trip_modes=[1, 2, 3]\n            )\n            it_zptnc_trp = create_zero_passenger_trips(it_full, zp_tnc, trip_modes=[9])\n            # Combining zero passenger trips to trip files\n            it_full = pd.concat(\n                [it_full, it_zpav_trp, it_zptnc_trp], ignore_index=True\n            ).reset_index(drop=True)\n\n        if jt_full[\"avAvailable\"].sum() &gt; 0:\n            jt_zpav_trp = create_zero_passenger_trips(\n                jt_full, zp_cav, trip_modes=[1, 2, 3]\n            )\n            jt_zptnc_trp = create_zero_passenger_trips(jt_full, zp_tnc, trip_modes=[9])\n            # Combining zero passenger trips to trip files\n            jt_full = pd.concat(\n                [jt_full, jt_zpav_trp, jt_zptnc_trp], ignore_index=True\n            ).reset_index(drop=True)\n\n        # read properties from config\n\n        mode_name_dict = self.controller.config.household.ctramp_mode_names\n        income_segment_config = self.controller.config.household.income_segment\n\n        if income_segment_config[\"enabled\"]:\n            # This only affects highway trip tables.\n\n            hh_file = self.controller.config.household.ctramp_hh_file.format(\n                iteration=iteration\n            )\n            hh = pd.read_csv(hh_file, usecols=[\"hh_id\", \"income\"])\n            it_full = it_full.merge(hh, on=\"hh_id\", how=\"left\")\n            jt_full = jt_full.merge(hh, on=\"hh_id\", how=\"left\")\n\n            suffixes = income_segment_config[\"segment_suffixes\"]\n\n            it_full[\"income_seg\"] = pd.cut(\n                it_full[\"income\"],\n                right=False,\n                bins=income_segment_config[\"cutoffs\"] + [float(\"inf\")],\n                labels=suffixes,\n            ).astype(str)\n\n            jt_full[\"income_seg\"] = pd.cut(\n                jt_full[\"income\"],\n                right=False,\n                bins=income_segment_config[\"cutoffs\"] + [float(\"inf\")],\n                labels=suffixes,\n            ).astype(str)\n        else:\n            it_full[\"income_seg\"] = \"\"\n            jt_full[\"income_seg\"] = \"\"\n            suffixes = [\"\"]\n\n        # groupby objects for combinations of time period - income segmentation, used for highway modes only\n        it_grp = it_full.groupby([\"time_period\", \"income_seg\"])\n        jt_grp = jt_full.groupby([\"time_period\", \"income_seg\"])\n\n        for time_period in time_periods_sorted:\n            self.logger.debug(\n                f\"Producing household demand matrices for period {time_period}\"\n            )\n\n            highway_out_file = OMXManager(\n                self.controller.get_abs_path(\n                    self.controller.config.household.highway_demand_file\n                )\n                .__str__()\n                .format(period=time_period, iter=self.controller.iteration),\n                \"w\",\n            )\n            transit_out_file = OMXManager(\n                self.controller.get_abs_path(\n                    self.controller.config.household.transit_demand_file\n                )\n                .__str__()\n                .format(period=time_period, iter=self.controller.iteration),\n                \"w\",\n            )\n            # active_out_file = OMXManager(\n            #    self.controller.get_abs_path(self.controller.config.household.active_demand_file).__str__().format(period=time_period), 'w')\n\n            # hsr_trips_file = _omx.open_file(\n            #    self.controller.get_abs_path(self.controller.config.household.hsr_demand_file).format(year=self.controller.config.scenario.year, period=time_period))\n\n            # interregional_trips_file = _omx.open_file(\n            #   self.controller.get_abs_path(self.controller.config.household.interregional_demand_file).format(year=self.controller.config.scenario.year, period=time_period))\n\n            highway_out_file.open()\n            transit_out_file.open()\n            # active_out_file.open()\n\n            # Transit and active modes: one matrix per time period per mode\n            it = it_full[it_full.time_period == time_period]\n            jt = jt_full[jt_full.time_period == time_period]\n\n            for trip_mode in mode_name_dict:\n                #                if trip_mode in [9,10]:\n                #                    matrix_name =  mode_name_dict[trip_mode]\n                #                    self.logger.debug(f\"Writing out mode {mode_name_dict[trip_mode]}\")\n                #                    active_out_file.write_array(numpy_array=combine_trip_lists(it,jt, trip_mode), name = matrix_name)\n\n                if trip_mode == 11:\n                    matrix_name = \"WLK_TRN_WLK\"\n                    self.logger.debug(f\"Writing out mode WLK_TRN_WLK\")\n                    # other_trn_trips = np.array(hsr_trips_file[matrix_name])+np.array(interregional_trips_file[matrix_name])\n                    transit_out_file.write_array(\n                        numpy_array=(combine_trip_lists(it, jt, trip_mode)),\n                        name=matrix_name,\n                    )\n\n                elif trip_mode in [12, 13]:\n                    it_outbound, it_inbound = it[it.inbound == 0], it[it.inbound == 1]\n                    jt_outbound, jt_inbound = jt[jt.inbound == 0], jt[jt.inbound == 1]\n\n                    matrix_name = f\"{mode_name_dict[trip_mode].upper()}_TRN_WLK\"\n                    # other_trn_trips = np.array(hsr_trips_file[matrix_name])+np.array(interregional_trips_file[matrix_name])\n                    self.logger.debug(\n                        f\"Writing out mode {mode_name_dict[trip_mode].upper() + '_TRN_WLK'}\"\n                    )\n                    transit_out_file.write_array(\n                        numpy_array=(\n                            combine_trip_lists(it_outbound, jt_outbound, trip_mode)\n                        ),\n                        name=matrix_name,\n                    )\n\n                    matrix_name = f\"WLK_TRN_{mode_name_dict[trip_mode].upper()}\"\n                    # other_trn_trips = np.array(hsr_trips_file[matrix_name])+np.array(interregional_trips_file[matrix_name])\n                    self.logger.debug(\n                        f\"Writing out mode {'WLK_TRN_' + mode_name_dict[trip_mode].upper()}\"\n                    )\n                    transit_out_file.write_array(\n                        numpy_array=(\n                            combine_trip_lists(it_inbound, jt_inbound, trip_mode)\n                        ),\n                        name=matrix_name,\n                    )\n\n            # Highway modes: one matrix per suffix (income class) per time period per mode\n            for suffix in suffixes:\n                highway_cache = {}\n\n                if (time_period, suffix) in it_grp.groups.keys():\n                    it = it_grp.get_group((time_period, suffix))\n                else:\n                    it = pd.DataFrame(None, columns=it_full.columns)\n\n                if (time_period, suffix) in jt_grp.groups.keys():\n                    jt = jt_grp.get_group((time_period, suffix))\n                else:\n                    jt = pd.DataFrame(None, columns=jt_full.columns)\n\n                for trip_mode in sorted(mode_name_dict):\n                    # Python preserves keys in the order they are inserted but\n                    # mode_name_dict originates from TOML, which does not guarantee\n                    # that the ordering of keys is preserved.  See\n                    # https://github.com/toml-lang/toml/issues/162\n\n                    if trip_mode in [\n                        1,\n                        2,\n                        3,\n                        4,\n                        5,\n                        6,\n                        7,\n                        8,\n                        9,\n                        10,\n                        15,\n                        16,\n                        17,\n                    ]:  # currently hard-coded based on Travel Mode trip mode codes\n                        highway_cache[mode_name_dict[trip_mode]] = combine_trip_lists(\n                            it, jt, trip_mode\n                        )\n                        out_mode = f\"{mode_name_dict[trip_mode].upper()}\"\n                        matrix_name = (\n                            f\"{out_mode}_{suffix}_{time_period.upper()}\"\n                            if suffix\n                            else f\"{out_mode}_{time_period.upper()}\"\n                        )\n                        highway_out_file.write_array(\n                            numpy_array=highway_cache[mode_name_dict[trip_mode]],\n                            name=matrix_name,\n                        )\n\n                    elif trip_mode in [15, 16]:\n                        # identify the correct mode split factors for da, sr2, sr3\n                        self.logger.debug(\n                            f\"Splitting ridehail trips into shared ride trips\"\n                        )\n                        ridehail_split_factors = defaultdict(float)\n                        splits = self.controller.config.household.rideshare_mode_split\n                        for key in splits:\n                            out_mode_split = self.controller.config.household.__dict__[\n                                f\"{key}_split\"\n                            ]\n                            for out_mode in out_mode_split:\n                                ridehail_split_factors[out_mode] += (\n                                    out_mode_split[out_mode] * splits[key]\n                                )\n\n                        ridehail_trips = combine_trip_lists(it, jt, trip_mode)\n                        for out_mode in ridehail_split_factors:\n                            matrix_name = f\"{out_mode}_{suffix}\" if suffix else out_mode\n                            self.logger.debug(f\"Writing out mode {out_mode}\")\n                            highway_cache[out_mode] += (\n                                (ridehail_trips * ridehail_split_factors[out_mode])\n                                .astype(float)\n                                .round(2)\n                            )\n                            highway_out_file.write_array(\n                                numpy_array=highway_cache[out_mode], name=matrix_name\n                            )\n\n            highway_out_file.close()\n            transit_out_file.close()\n            # active_out_file.close()\n\n    @property\n    def num_internal_zones(self):\n        df = pd.read_csv(\n            self.controller.get_abs_path(self.controller.config.scenario.landuse_file),\n            usecols=[self.controller.config.scenario.landuse_index_column],\n        )\n        return len(df[\"TAZ\"].unique())\n\n    @property\n    def num_total_zones(self):\n        self._emmebank_path = self.controller.get_abs_path(\n            self.controller.config.emme.highway_database_path\n        )\n        self._emmebank = self.controller.emme_manager.emmebank(self._emmebank_path)\n        time_period = self.controller.config.time_periods[0].name\n        scenario = self.get_emme_scenario(\n            self._emmebank.path, time_period\n        )  # any scenario id works\n        return len(scenario.zone_numbers)\n</code></pre>"},{"location":"api/#tm2py.components.demand.prepare_demand.PrepareHighwayDemand.__init__","title":"<code>__init__(controller)</code>","text":"<p>Constructor for PrepareHighwayDemand.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>Reference to run controller object.</p> required Source code in <code>tm2py/components/demand/prepare_demand.py</code> <pre><code>def __init__(self, controller: RunController):\n    \"\"\"Constructor for PrepareHighwayDemand.\n\n    Args:\n        controller (RunController): Reference to run controller object.\n    \"\"\"\n    super().__init__(controller)\n    self.controller = controller\n    self.config = self.controller.config.highway\n    self._highway_emmebank = None\n</code></pre>"},{"location":"api/#tm2py.components.demand.prepare_demand.PrepareHighwayDemand.prepare_household_demand","title":"<code>prepare_household_demand()</code>","text":"<p>Prepares highway and transit household demand matrices from trip lists produced by CT-RAMP.</p> Source code in <code>tm2py/components/demand/prepare_demand.py</code> <pre><code>@LogStartEnd(\"Prepare household demand matrices.\")\ndef prepare_household_demand(self):\n    \"\"\"Prepares highway and transit household demand matrices from trip lists produced by CT-RAMP.\"\"\"\n    iteration = self.controller.iteration\n\n    # Create folders if they don't exist\n    pathlib.Path(\n        self.controller.get_abs_path(\n            self.controller.config.household.highway_demand_file\n        )\n    ).parents[0].mkdir(parents=True, exist_ok=True)\n    pathlib.Path(\n        self.controller.get_abs_path(\n            self.controller.config.household.transit_demand_file\n        )\n    ).parents[0].mkdir(parents=True, exist_ok=True)\n    #    pathlib.Path(self.controller.get_abs_path(self.controller.config.household.active_demand_file)).parents[0].mkdir(parents=True, exist_ok=True)\n\n    indiv_trip_file = (\n        self.controller.config.household.ctramp_indiv_trip_file.format(\n            iteration=iteration\n        )\n    )\n    joint_trip_file = (\n        self.controller.config.household.ctramp_joint_trip_file.format(\n            iteration=iteration\n        )\n    )\n    it_full, jt_full = pd.read_csv(indiv_trip_file), pd.read_csv(joint_trip_file)\n\n    # Add time period, expanded count\n    time_period_start = dict(\n        zip(\n            [c.name.upper() for c in self.controller.config.time_periods],\n            [c.start_period for c in self.controller.config.time_periods],\n        )\n    )\n    # the last time period needs to be filled in because the first period may or may not start at midnight\n    time_periods_sorted = sorted(\n        time_period_start, key=lambda x: time_period_start[x]\n    )  # in upper case\n    first_period = time_periods_sorted[0]\n    periods_except_last = time_periods_sorted[:-1]\n    breakpoints = [time_period_start[tp] for tp in time_periods_sorted]\n    it_full[\"time_period\"] = (\n        pd.cut(\n            it_full.stop_period,\n            breakpoints,\n            right=False,\n            labels=periods_except_last,\n        )\n        .cat.add_categories(time_periods_sorted[-1])\n        .fillna(time_periods_sorted[-1])\n        .astype(str)\n    )\n    jt_full[\"time_period\"] = (\n        pd.cut(\n            jt_full.stop_period,\n            breakpoints,\n            right=False,\n            labels=periods_except_last,\n        )\n        .cat.add_categories(time_periods_sorted[-1])\n        .fillna(time_periods_sorted[-1])\n        .astype(str)\n    )\n    it_full[\"eq_cnt\"] = 1 / it_full.sampleRate\n    it_full[\"eq_cnt\"] = np.where(\n        it_full[\"trip_mode\"].isin([3, 4, 5]),\n        0.5 * it_full[\"eq_cnt\"],\n        np.where(\n            it_full[\"trip_mode\"].isin([6, 7, 8]),\n            0.35 * it_full[\"eq_cnt\"],\n            it_full[\"eq_cnt\"],\n        ),\n    )\n    jt_full[\"eq_cnt\"] = jt_full.num_participants / jt_full.sampleRate\n    zp_cav = self.controller.config.household.OwnedAV_ZPV_factor\n    zp_tnc = self.controller.config.household.TNC_ZPV_factor\n\n    maz_taz_df = pd.read_csv(\n        self.controller.get_abs_path(self.controller.config.scenario.landuse_file),\n        usecols=[\"MAZ\", \"TAZ\"],\n    )\n    it_full = it_full.merge(\n        maz_taz_df, left_on=\"orig_mgra\", right_on=\"MAZ\", how=\"left\"\n    ).rename(columns={\"TAZ\": \"orig_taz\"})\n    it_full = it_full.merge(\n        maz_taz_df, left_on=\"dest_mgra\", right_on=\"MAZ\", how=\"left\"\n    ).rename(columns={\"TAZ\": \"dest_taz\"})\n    jt_full = jt_full.merge(\n        maz_taz_df, left_on=\"orig_mgra\", right_on=\"MAZ\", how=\"left\"\n    ).rename(columns={\"TAZ\": \"orig_taz\"})\n    jt_full = jt_full.merge(\n        maz_taz_df, left_on=\"dest_mgra\", right_on=\"MAZ\", how=\"left\"\n    ).rename(columns={\"TAZ\": \"dest_taz\"})\n    it_full[\"trip_mode\"] = np.where(\n        it_full[\"trip_mode\"] == 14, 13, it_full[\"trip_mode\"]\n    )\n    jt_full[\"trip_mode\"] = np.where(\n        jt_full[\"trip_mode\"] == 14, 13, jt_full[\"trip_mode\"]\n    )\n\n    num_zones = self.num_internal_zones\n    OD_full_index = pd.MultiIndex.from_product(\n        [range(1, num_zones + 1), range(1, num_zones + 1)]\n    )\n\n    def combine_trip_lists(it, jt, trip_mode):\n        # combines individual trip list and joint trip list\n        combined_trips = pd.concat(\n            [it[(it[\"trip_mode\"] == trip_mode)], jt[(jt[\"trip_mode\"] == trip_mode)]]\n        )\n        combined_sum = combined_trips.groupby([\"orig_taz\", \"dest_taz\"])[\n            \"eq_cnt\"\n        ].sum()\n        return combined_sum.reindex(OD_full_index, fill_value=0).unstack().values\n\n    def create_zero_passenger_trips(\n        trips, deadheading_factor, trip_modes=[1, 2, 3]\n    ):\n        zpv_trips = trips.loc[\n            (trips[\"avAvailable\"] == 1) &amp; (trips[\"trip_mode\"].isin(trip_modes))\n        ]\n        zpv_trips[\"eq_cnt\"] = zpv_trips[\"eq_cnt\"] * deadheading_factor\n        zpv_trips = zpv_trips.rename(\n            columns={\"dest_taz\": \"orig_taz\", \"orig_taz\": \"dest_taz\"}\n        )\n        return zpv_trips\n\n    # create zero passenger trips for auto modes\n    if it_full[\"avAvailable\"].sum() &gt; 0:\n        it_zpav_trp = create_zero_passenger_trips(\n            it_full, zp_cav, trip_modes=[1, 2, 3]\n        )\n        it_zptnc_trp = create_zero_passenger_trips(it_full, zp_tnc, trip_modes=[9])\n        # Combining zero passenger trips to trip files\n        it_full = pd.concat(\n            [it_full, it_zpav_trp, it_zptnc_trp], ignore_index=True\n        ).reset_index(drop=True)\n\n    if jt_full[\"avAvailable\"].sum() &gt; 0:\n        jt_zpav_trp = create_zero_passenger_trips(\n            jt_full, zp_cav, trip_modes=[1, 2, 3]\n        )\n        jt_zptnc_trp = create_zero_passenger_trips(jt_full, zp_tnc, trip_modes=[9])\n        # Combining zero passenger trips to trip files\n        jt_full = pd.concat(\n            [jt_full, jt_zpav_trp, jt_zptnc_trp], ignore_index=True\n        ).reset_index(drop=True)\n\n    # read properties from config\n\n    mode_name_dict = self.controller.config.household.ctramp_mode_names\n    income_segment_config = self.controller.config.household.income_segment\n\n    if income_segment_config[\"enabled\"]:\n        # This only affects highway trip tables.\n\n        hh_file = self.controller.config.household.ctramp_hh_file.format(\n            iteration=iteration\n        )\n        hh = pd.read_csv(hh_file, usecols=[\"hh_id\", \"income\"])\n        it_full = it_full.merge(hh, on=\"hh_id\", how=\"left\")\n        jt_full = jt_full.merge(hh, on=\"hh_id\", how=\"left\")\n\n        suffixes = income_segment_config[\"segment_suffixes\"]\n\n        it_full[\"income_seg\"] = pd.cut(\n            it_full[\"income\"],\n            right=False,\n            bins=income_segment_config[\"cutoffs\"] + [float(\"inf\")],\n            labels=suffixes,\n        ).astype(str)\n\n        jt_full[\"income_seg\"] = pd.cut(\n            jt_full[\"income\"],\n            right=False,\n            bins=income_segment_config[\"cutoffs\"] + [float(\"inf\")],\n            labels=suffixes,\n        ).astype(str)\n    else:\n        it_full[\"income_seg\"] = \"\"\n        jt_full[\"income_seg\"] = \"\"\n        suffixes = [\"\"]\n\n    # groupby objects for combinations of time period - income segmentation, used for highway modes only\n    it_grp = it_full.groupby([\"time_period\", \"income_seg\"])\n    jt_grp = jt_full.groupby([\"time_period\", \"income_seg\"])\n\n    for time_period in time_periods_sorted:\n        self.logger.debug(\n            f\"Producing household demand matrices for period {time_period}\"\n        )\n\n        highway_out_file = OMXManager(\n            self.controller.get_abs_path(\n                self.controller.config.household.highway_demand_file\n            )\n            .__str__()\n            .format(period=time_period, iter=self.controller.iteration),\n            \"w\",\n        )\n        transit_out_file = OMXManager(\n            self.controller.get_abs_path(\n                self.controller.config.household.transit_demand_file\n            )\n            .__str__()\n            .format(period=time_period, iter=self.controller.iteration),\n            \"w\",\n        )\n        # active_out_file = OMXManager(\n        #    self.controller.get_abs_path(self.controller.config.household.active_demand_file).__str__().format(period=time_period), 'w')\n\n        # hsr_trips_file = _omx.open_file(\n        #    self.controller.get_abs_path(self.controller.config.household.hsr_demand_file).format(year=self.controller.config.scenario.year, period=time_period))\n\n        # interregional_trips_file = _omx.open_file(\n        #   self.controller.get_abs_path(self.controller.config.household.interregional_demand_file).format(year=self.controller.config.scenario.year, period=time_period))\n\n        highway_out_file.open()\n        transit_out_file.open()\n        # active_out_file.open()\n\n        # Transit and active modes: one matrix per time period per mode\n        it = it_full[it_full.time_period == time_period]\n        jt = jt_full[jt_full.time_period == time_period]\n\n        for trip_mode in mode_name_dict:\n            #                if trip_mode in [9,10]:\n            #                    matrix_name =  mode_name_dict[trip_mode]\n            #                    self.logger.debug(f\"Writing out mode {mode_name_dict[trip_mode]}\")\n            #                    active_out_file.write_array(numpy_array=combine_trip_lists(it,jt, trip_mode), name = matrix_name)\n\n            if trip_mode == 11:\n                matrix_name = \"WLK_TRN_WLK\"\n                self.logger.debug(f\"Writing out mode WLK_TRN_WLK\")\n                # other_trn_trips = np.array(hsr_trips_file[matrix_name])+np.array(interregional_trips_file[matrix_name])\n                transit_out_file.write_array(\n                    numpy_array=(combine_trip_lists(it, jt, trip_mode)),\n                    name=matrix_name,\n                )\n\n            elif trip_mode in [12, 13]:\n                it_outbound, it_inbound = it[it.inbound == 0], it[it.inbound == 1]\n                jt_outbound, jt_inbound = jt[jt.inbound == 0], jt[jt.inbound == 1]\n\n                matrix_name = f\"{mode_name_dict[trip_mode].upper()}_TRN_WLK\"\n                # other_trn_trips = np.array(hsr_trips_file[matrix_name])+np.array(interregional_trips_file[matrix_name])\n                self.logger.debug(\n                    f\"Writing out mode {mode_name_dict[trip_mode].upper() + '_TRN_WLK'}\"\n                )\n                transit_out_file.write_array(\n                    numpy_array=(\n                        combine_trip_lists(it_outbound, jt_outbound, trip_mode)\n                    ),\n                    name=matrix_name,\n                )\n\n                matrix_name = f\"WLK_TRN_{mode_name_dict[trip_mode].upper()}\"\n                # other_trn_trips = np.array(hsr_trips_file[matrix_name])+np.array(interregional_trips_file[matrix_name])\n                self.logger.debug(\n                    f\"Writing out mode {'WLK_TRN_' + mode_name_dict[trip_mode].upper()}\"\n                )\n                transit_out_file.write_array(\n                    numpy_array=(\n                        combine_trip_lists(it_inbound, jt_inbound, trip_mode)\n                    ),\n                    name=matrix_name,\n                )\n\n        # Highway modes: one matrix per suffix (income class) per time period per mode\n        for suffix in suffixes:\n            highway_cache = {}\n\n            if (time_period, suffix) in it_grp.groups.keys():\n                it = it_grp.get_group((time_period, suffix))\n            else:\n                it = pd.DataFrame(None, columns=it_full.columns)\n\n            if (time_period, suffix) in jt_grp.groups.keys():\n                jt = jt_grp.get_group((time_period, suffix))\n            else:\n                jt = pd.DataFrame(None, columns=jt_full.columns)\n\n            for trip_mode in sorted(mode_name_dict):\n                # Python preserves keys in the order they are inserted but\n                # mode_name_dict originates from TOML, which does not guarantee\n                # that the ordering of keys is preserved.  See\n                # https://github.com/toml-lang/toml/issues/162\n\n                if trip_mode in [\n                    1,\n                    2,\n                    3,\n                    4,\n                    5,\n                    6,\n                    7,\n                    8,\n                    9,\n                    10,\n                    15,\n                    16,\n                    17,\n                ]:  # currently hard-coded based on Travel Mode trip mode codes\n                    highway_cache[mode_name_dict[trip_mode]] = combine_trip_lists(\n                        it, jt, trip_mode\n                    )\n                    out_mode = f\"{mode_name_dict[trip_mode].upper()}\"\n                    matrix_name = (\n                        f\"{out_mode}_{suffix}_{time_period.upper()}\"\n                        if suffix\n                        else f\"{out_mode}_{time_period.upper()}\"\n                    )\n                    highway_out_file.write_array(\n                        numpy_array=highway_cache[mode_name_dict[trip_mode]],\n                        name=matrix_name,\n                    )\n\n                elif trip_mode in [15, 16]:\n                    # identify the correct mode split factors for da, sr2, sr3\n                    self.logger.debug(\n                        f\"Splitting ridehail trips into shared ride trips\"\n                    )\n                    ridehail_split_factors = defaultdict(float)\n                    splits = self.controller.config.household.rideshare_mode_split\n                    for key in splits:\n                        out_mode_split = self.controller.config.household.__dict__[\n                            f\"{key}_split\"\n                        ]\n                        for out_mode in out_mode_split:\n                            ridehail_split_factors[out_mode] += (\n                                out_mode_split[out_mode] * splits[key]\n                            )\n\n                    ridehail_trips = combine_trip_lists(it, jt, trip_mode)\n                    for out_mode in ridehail_split_factors:\n                        matrix_name = f\"{out_mode}_{suffix}\" if suffix else out_mode\n                        self.logger.debug(f\"Writing out mode {out_mode}\")\n                        highway_cache[out_mode] += (\n                            (ridehail_trips * ridehail_split_factors[out_mode])\n                            .astype(float)\n                            .round(2)\n                        )\n                        highway_out_file.write_array(\n                            numpy_array=highway_cache[out_mode], name=matrix_name\n                        )\n\n        highway_out_file.close()\n        transit_out_file.close()\n</code></pre>"},{"location":"api/#tm2py.components.demand.prepare_demand.PrepareHighwayDemand.run","title":"<code>run()</code>","text":"<p>Open combined demand OMX files from demand models and prepare for assignment.</p> Source code in <code>tm2py/components/demand/prepare_demand.py</code> <pre><code>def run(self):\n    \"\"\"Open combined demand OMX files from demand models and prepare for assignment.\"\"\"\n\n    self.highway_emmebank.create_zero_matrix()\n    for time in self.controller.time_period_names:\n        for klass in self.config.classes:\n            self._prepare_demand(klass.name, klass.description, klass.demand, time)\n</code></pre>"},{"location":"api/#tm2py.components.demand.prepare_demand.PrepareTransitDemand","title":"<code>PrepareTransitDemand</code>","text":"<p>               Bases: <code>EmmeDemand</code></p> <p>Import transit demand.</p> <p>Demand is imported from OMX files based on reference file paths and OMX matrix names in transit assignment config (transit.classes). The demand is average using MSA with the current demand matrices (in the Emmebank) if transit.apply_msa_demand is true if the controller.iteration &gt; 1.</p> Source code in <code>tm2py/components/demand/prepare_demand.py</code> <pre><code>class PrepareTransitDemand(EmmeDemand):\n    \"\"\"Import transit demand.\n\n    Demand is imported from OMX files based on reference file paths and OMX\n    matrix names in transit assignment config (transit.classes).\n    The demand is average using MSA with the current demand matrices (in the\n    Emmebank) if transit.apply_msa_demand is true if the\n    controller.iteration &gt; 1.\n\n    \"\"\"\n\n    def __init__(self, controller: \"RunController\"):\n        \"\"\"Constructor for PrepareTransitDemand.\n\n        Args:\n            controller: RunController object.\n        \"\"\"\n        super().__init__(controller)\n        self.controller = controller\n        self.config = self.controller.config.transit\n        self._transit_emmebank = None\n\n    def validate_inputs(self):\n        \"\"\"Validate the inputs.\"\"\"\n        # TODO\n\n    @property\n    def transit_emmebank(self):\n        if not self._transit_emmebank:\n            self._transit_emmebank = self.controller.emme_manager.transit_emmebank\n            self._emmebank = self._transit_emmebank\n        return self._transit_emmebank\n\n    @LogStartEnd(\"Prepare transit demand\")\n    def run(self):\n        \"\"\"Open combined demand OMX files from demand models and prepare for assignment.\"\"\"\n        self._source_ref_key = \"transit_demand_file\"\n        self.transit_emmebank.create_zero_matrix()\n        _time_period_tclass = itertools.product(\n            self.controller.time_period_names, self.config.classes\n        )\n        for _time_period, _tclass in _time_period_tclass:\n            self._prepare_demand(\n                _tclass.skim_set_id, _tclass.description, _tclass.demand, _time_period\n            )\n\n    def _prepare_demand(\n        self,\n        name: str,\n        description: str,\n        demand_config: List[Dict[str, Union[str, float]]],\n        time_period: str,\n    ):\n        \"\"\"Load demand from OMX files and save to Emme matrix for transit assignment.\n\n        Average with previous demand (MSA) if the current iteration &gt; 1 and\n        config.transit.apply_msa_demand is True\n\n        Args:\n            name (str): the name of the transit assignment class in the OMX files, usually a number\n            description (str): the description for the transit assignment class\n            demand_config (dict): the list of file cross-reference(s) for the demand to be loaded\n                {\"source\": &lt;name of demand model component&gt;,\n                 \"name\": &lt;OMX key name&gt;,\n                 \"factor\": &lt;factor to apply to demand in this file&gt;}\n            time_period (str): the time _time_period ID (name)\n        \"\"\"\n        self._scenario = self.transit_emmebank.scenario(time_period)\n        num_zones = len(self._scenario.zone_numbers)\n        demand = self._read_demand(demand_config[0], time_period, name, num_zones)\n        for file_config in demand_config[1:]:\n            demand = demand + self._read_demand(\n                file_config, time_period, name, num_zones\n            )\n        demand_name = f\"TRN_{name}_{time_period}\"\n        description = f\"{time_period} {description} demand\"\n        apply_msa = self.config.apply_msa_demand\n        self._save_demand(demand_name, demand, description, apply_msa=apply_msa)\n\n    def _read_demand(self, file_config, time_period, skim_set, num_zones):\n        # Load demand from cross-referenced source file,\n        # the named demand model component under the key highway_demand_file\n        if (\n            self.controller.config.warmstart.warmstart\n            and self.controller.iteration == 0\n        ):\n            source = file_config[\"source\"]\n            path = self.controller.get_abs_path(\n                self.controller.config[source].transit_demand_file\n            ).__str__()\n        else:\n            source = file_config[\"source\"]\n            path = self.controller.get_abs_path(\n                self.controller.config[source].transit_demand_file\n            ).__str__()\n        name = file_config[\"name\"]\n        return self._read(\n            path.format(period=time_period, iter=self.controller.iteration),\n            name,\n            num_zones,\n        )\n</code></pre>"},{"location":"api/#tm2py.components.demand.prepare_demand.PrepareTransitDemand.__init__","title":"<code>__init__(controller)</code>","text":"<p>Constructor for PrepareTransitDemand.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>'RunController'</code> <p>RunController object.</p> required Source code in <code>tm2py/components/demand/prepare_demand.py</code> <pre><code>def __init__(self, controller: \"RunController\"):\n    \"\"\"Constructor for PrepareTransitDemand.\n\n    Args:\n        controller: RunController object.\n    \"\"\"\n    super().__init__(controller)\n    self.controller = controller\n    self.config = self.controller.config.transit\n    self._transit_emmebank = None\n</code></pre>"},{"location":"api/#tm2py.components.demand.prepare_demand.PrepareTransitDemand.run","title":"<code>run()</code>","text":"<p>Open combined demand OMX files from demand models and prepare for assignment.</p> Source code in <code>tm2py/components/demand/prepare_demand.py</code> <pre><code>@LogStartEnd(\"Prepare transit demand\")\ndef run(self):\n    \"\"\"Open combined demand OMX files from demand models and prepare for assignment.\"\"\"\n    self._source_ref_key = \"transit_demand_file\"\n    self.transit_emmebank.create_zero_matrix()\n    _time_period_tclass = itertools.product(\n        self.controller.time_period_names, self.config.classes\n    )\n    for _time_period, _tclass in _time_period_tclass:\n        self._prepare_demand(\n            _tclass.skim_set_id, _tclass.description, _tclass.demand, _time_period\n        )\n</code></pre>"},{"location":"api/#tm2py.components.demand.prepare_demand.PrepareTransitDemand.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate the inputs.</p> Source code in <code>tm2py/components/demand/prepare_demand.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate the inputs.\"\"\"\n</code></pre>"},{"location":"api/#tm2py.components.demand.prepare_demand.avg_matrix_msa","title":"<code>avg_matrix_msa(prev_avg_matrix, this_iter_matrix, msa_iteration)</code>","text":"<p>Average matrices based on Method of Successive Averages (MSA).</p> <p>Parameters:</p> Name Type Description Default <code>prev_avg_matrix</code> <code>NumpyArray</code> <p>Previously averaged matrix</p> required <code>this_iter_matrix</code> <code>NumpyArray</code> <p>Matrix for this iteration</p> required <code>msa_iteration</code> <code>int</code> <p>MSA iteration</p> required <p>Returns:</p> Name Type Description <code>NumpyArray</code> <code>NumpyArray</code> <p>MSA Averaged matrix for this iteration.</p> Source code in <code>tm2py/components/demand/prepare_demand.py</code> <pre><code>def avg_matrix_msa(\n    prev_avg_matrix: NumpyArray, this_iter_matrix: NumpyArray, msa_iteration: int\n) -&gt; NumpyArray:\n    \"\"\"Average matrices based on Method of Successive Averages (MSA).\n\n    Args:\n        prev_avg_matrix (NumpyArray): Previously averaged matrix\n        this_iter_matrix (NumpyArray): Matrix for this iteration\n        msa_iteration (int): MSA iteration\n\n    Returns:\n        NumpyArray: MSA Averaged matrix for this iteration.\n    \"\"\"\n    if msa_iteration &lt; 1:\n        return this_iter_matrix\n    result_matrix = prev_avg_matrix + (1.0 / msa_iteration) * (\n        this_iter_matrix - prev_avg_matrix\n    )\n    return result_matrix\n</code></pre>"},{"location":"api/#household-demand","title":"Household Demand","text":"<p>Personal travel demand generated by household members.</p> <p>Placeholder docstring for CT-RAMP related components for household residents\u2019 model.</p> <p>               Bases: <code>ConfigItem</code></p> <p>Household (residents) model parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HouseholdConfig(ConfigItem):\n    \"\"\"Household (residents) model parameters.\"\"\"\n\n    highway_demand_file: pathlib.Path\n    transit_demand_file: pathlib.Path\n    active_demand_file: pathlib.Path\n    highway_maz_ctramp_output_file: pathlib.Path\n    OwnedAV_ZPV_factor: float\n    TNC_ZPV_factor: float\n    ctramp_indiv_trip_file: str\n    ctramp_joint_trip_file: str\n    ctramp_run_dir: pathlib.Path\n    rideshare_mode_split: Dict[str, float]\n    taxi_split: Dict[str, float]\n    single_tnc_split: Dict[str, float]\n    shared_tnc_split: Dict[str, float]\n    ctramp_mode_names: Dict[float, str]\n    income_segment: Dict[str, Union[float, str, list]]\n    ctramp_hh_file: str\n    sample_rate_by_iteration: List[float]\n</code></pre>"},{"location":"api/#tm2py.components.demand.household.HouseholdModel","title":"<code>HouseholdModel</code>","text":"<p>               Bases: <code>Component</code></p> <p>Run household resident model.</p> Source code in <code>tm2py/components/demand/household.py</code> <pre><code>class HouseholdModel(Component):\n    \"\"\"Run household resident model.\"\"\"\n\n    def validate_inputs(self):\n        \"\"\"Validates inputs for component.\"\"\"\n        pass\n\n    @LogStartEnd()\n    def run(self):\n        \"\"\"Run the the household resident travel demand model.\n\n        Steps:\n            1. Starts household manager.\n            2. Starts matrix manager.\n            3. Starts resident travel model (CTRAMP).\n            4. Cleans up CTRAMP java.\n        \"\"\"\n        self.config = self.controller.config.household\n        self._start_household_manager()\n        self._start_matrix_manager()\n        self._run_resident_model()\n        self._stop_java()\n        # consume ctramp person trip list and create trip tables for assignment\n        self._prepare_demand_for_assignment()\n        self._copy_auto_maz_demand()\n\n    def _prepare_demand_for_assignment(self):\n        prep_demand = PrepareHighwayDemand(self.controller)\n        prep_demand.prepare_household_demand()\n\n    def _start_household_manager(self):\n        commands = [\n            f\"cd /d {self.controller.run_dir}\",\n            f\"CALL {self.controller.run_dir}\\\\CTRAMP\\\\runtime\\\\CTRampEnv.bat\",\n            \"set PATH=%CD%\\\\CTRAMP\\\\runtime;C:\\\\Windows\\\\System32;%JAVA_PATH%\\\\bin;\"\n            \"%TPP_PATH%;%PYTHON_PATH%;%PYTHON_PATH%\\\\condabin;%PYTHON_PATH%\\\\envs\",\n            f\"CALL {self.controller.run_dir}\\\\CTRAMP\\\\runtime\\\\runHhMgr.cmd %JAVA_PATH% %HOST_IP_ADDRESS%\",\n        ]\n        run_process(commands, name=\"start_household_manager\")\n\n    def _start_matrix_manager(self):\n        commands = [\n            f\"cd /d {self.controller.run_dir}\",\n            f\"CALL {self.controller.run_dir}\\\\CTRAMP\\\\runtime\\\\CTRampEnv.bat\",\n            \"set PATH=%CD%\\\\CTRAMP\\\\runtime;C:\\\\Windows\\\\System32;%JAVA_PATH%\\\\bin;\"\n            \"%TPP_PATH%;%PYTHON_PATH%;%PYTHON_PATH%\\\\condabin;%PYTHON_PATH%\\\\envs\",\n            f\"CALL {self.controller.run_dir}\\\\CTRAMP\\\\runtime\\\\runMtxMgr.cmd %HOST_IP_ADDRESS% %JAVA_PATH%\",\n        ]\n        run_process(commands, name=\"start_matrix_manager\")\n\n    def _run_resident_model(self):\n        sample_rate_iteration = self.config.sample_rate_by_iteration\n        iteration = self.controller.iteration\n        sample_rate = sample_rate_iteration[iteration - 1]\n        _shutil.copyfile(\"CTRAMP\\\\runtime\\\\mtctm2.properties\", \"mtctm2.properties\")\n        commands = [\n            f\"cd /d {self.controller.run_dir}\",\n            f\"CALL {self.controller.run_dir}\\\\CTRAMP\\\\runtime\\\\CTRampEnv.bat\",\n            \"set PATH=%CD%\\\\CTRAMP\\\\runtime;C:\\\\Windows\\\\System32;%JAVA_PATH%\\\\bin;\"\n            \"%TPP_PATH%;%PYTHON_PATH%;%PYTHON_PATH%\\\\condabin;%PYTHON_PATH%\\\\envs\",\n            f\"CALL {self.controller.run_dir}\\\\CTRAMP\\\\runtime\\\\runMTCTM2ABM.cmd {sample_rate} {iteration} %JAVA_PATH%\",\n        ]\n        run_process(commands, name=\"run_resident_model\")\n\n    @staticmethod\n    def _stop_java():\n        run_process(['taskkill /im \"java.exe\" /F'])\n\n    def _copy_auto_maz_demand(self):\n        time_period_names = self.time_period_names\n\n        for period in time_period_names:\n            for maz_group in [1, 2, 3]:\n                output_path = (\n                    self.controller.get_abs_path(\n                        self.controller.config.highway.maz_to_maz.demand_file\n                    )\n                    .__str__()\n                    .format(\n                        period=period, number=maz_group, iter=self.controller.iteration\n                    )\n                )\n\n                input_path = (\n                    self.controller.get_abs_path(\n                        self.config.highway_maz_ctramp_output_file\n                    )\n                    .__str__()\n                    .format(period=period, number=maz_group)\n                )\n\n                _shutil.copyfile(input_path, output_path)\n\n    def _consolidate_demand_for_assign(self):\n        \"\"\"\n        CTRAMP writes out demands in separate omx files, e.g.\n        ctramp_output\\\\auto_@p@_SOV_GP_@p@.mat\n        ctramp_output\\\\auto_@p@_SOV_PAY_@p@.mat\n        ctramp_output\\\\auto_@p@_SR2_GP_@p@.mat\n        ctramp_output\\\\auto_@p@_SR2_HOV_@p@.mat\n        ctramp_output\\\\auto_@p@_SR2_PAY_@p@.mat\n        ctramp_output\\\\auto_@p@_SR3_GP_@p@.mat\n        ctramp_output\\\\auto_@p@_SR3_HOV_@p@.mat\n        ctramp_output\\\\auto_@p@_SR3_PAY_@p@.mat\n        ctramp_output\\\\Nonmotor_@p@_BIKE_@p@.mat\n        ctramp_output\\\\Nonmotor_@p@_WALK_@p@.mat\n        ctramp_output\\\\other_@p@_SCHLBUS_@p@.mat\n\n        Need to combine demands for one period into one omx file.\n        \"\"\"\n        time_period_names = self.time_period_names\n\n        # auto TAZ\n        for period in time_period_names:\n            output_path = (\n                self.controller.get_abs_path(self.config.highway_demand_file)\n                .__str__()\n                .format(period=period, iter=self.controller.iteration)\n            )\n            output_omx = omx.open_file(output_path, \"w\")\n            for mode_agg in self.config.mode_agg:\n                if mode_agg.name == \"transit\":\n                    continue\n                for mode in mode_agg.modes:\n                    input_path = (\n                        self.controller.get_abs_path(\n                            self.config.highway_taz_ctramp_output_file\n                        )\n                        .__str__()\n                        .format(period=period, mode_agg=mode_agg.name, mode=mode)\n                    )\n                    input_omx = omx.open_file(input_path, \"r\")\n                    core_name = mode + \"_\" + period.upper()\n                    output_omx[core_name] = input_omx[core_name][:, :]\n                    input_omx.close()\n\n            output_omx.close()\n\n        # auto MAZ\n        self._copy_auto_maz_demand()\n\n        # transit TAP\n        # for period in time_period_names:\n        #    for set in [\"set1\", \"set2\", \"set3\"]:\n        #        output_path = (\n        #            self.controller.get_abs_path(self.config.transit_demand_file)\n        #            .__str__()\n        #            .format(period=period, iter=self.controller.iteration, set=set)\n        #        )\n        #        output_omx = omx.open_file(output_path, \"w\")\n        #        for mode_agg in self.config.mode_agg:\n        #            if mode_agg.name != \"transit\":\n        #                continue\n        #            for mode in mode_agg.modes:\n        #                input_path = (\n        #                    self.controller.get_abs_path(\n        #                        self.config.transit_tap_ctramp_output_file\n        #                    )\n        #                    .__str__()\n        #                    .format(\n        #                        period=period,\n        #                        mode_agg=mode_agg.name,\n        #                        mode=mode,\n        #                        set=set,\n        #                    )\n        #                )\n        #                input_omx = omx.open_file(input_path, \"r\")\n        #                core_name = mode + \"_TRN_\" + set + \"_\" + period.upper()\n        #                output_omx[core_name] = input_omx[core_name][:, :]\n        #                input_omx.close()\n        #\n        #        output_omx.close()\n        # transit TAZ\n        for period in time_period_names:\n            output_path = (\n                self.controller.get_abs_path(self.config.transit_demand_file)\n                .__str__()\n                .format(period=period, iter=self.controller.iteration)\n            )\n            output_omx = omx.open_file(output_path, \"w\")\n            for mode_agg in self.config.mode_agg:\n                if mode_agg.name != \"transit\":\n                    continue\n                for mode in mode_agg.modes:\n                    input_path = (\n                        self.controller.get_abs_path(\n                            self.config.transit_taz_ctramp_output_file\n                        )\n                        .__str__()\n                        .format(\n                            period=period,\n                            mode_agg=mode_agg.name,\n                            mode=mode,\n                        )\n                    )\n                    input_omx = omx.open_file(input_path, \"r\")\n                    core_name = mode + \"_TRN_\" + period.upper()\n                    output_omx[core_name] = input_omx[core_name][:, :]\n                    input_omx.close()\n\n            output_omx.close()\n</code></pre>"},{"location":"api/#tm2py.components.demand.household.HouseholdModel.run","title":"<code>run()</code>","text":"<p>Run the the household resident travel demand model.</p> Steps <ol> <li>Starts household manager.</li> <li>Starts matrix manager.</li> <li>Starts resident travel model (CTRAMP).</li> <li>Cleans up CTRAMP java.</li> </ol> Source code in <code>tm2py/components/demand/household.py</code> <pre><code>@LogStartEnd()\ndef run(self):\n    \"\"\"Run the the household resident travel demand model.\n\n    Steps:\n        1. Starts household manager.\n        2. Starts matrix manager.\n        3. Starts resident travel model (CTRAMP).\n        4. Cleans up CTRAMP java.\n    \"\"\"\n    self.config = self.controller.config.household\n    self._start_household_manager()\n    self._start_matrix_manager()\n    self._run_resident_model()\n    self._stop_java()\n    # consume ctramp person trip list and create trip tables for assignment\n    self._prepare_demand_for_assignment()\n    self._copy_auto_maz_demand()\n</code></pre>"},{"location":"api/#tm2py.components.demand.household.HouseholdModel.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validates inputs for component.</p> Source code in <code>tm2py/components/demand/household.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validates inputs for component.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#air-passenger-demand","title":"Air Passenger Demand","text":"<p>Module containing the AirPassenger class which builds the airport trip matrices.</p> <p>               Bases: <code>ConfigItem</code></p> <p>Air passenger demand aggregation input parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass AirPassengerDemandAggregationConfig(ConfigItem):\n    \"\"\"Air passenger demand aggregation input parameters.\n\n    Properties:\n        name: (src_group_name) name used for the class group in the input columns\n            for the trip tables,\n        mode: (result_class_name) name used in the output OMX matrix names, note\n            that this should match the expected naming convention in the\n            HighwayClassDemandConfig name(s)\n        access_modes: list of names used for the access modes in the input\n            columns for the trip tables\n    \"\"\"\n\n    name: str\n    mode: str\n    access_modes: Tuple[str, ...]\n</code></pre>"},{"location":"api/#tm2py.components.demand.air_passenger.AirPassenger","title":"<code>AirPassenger</code>","text":"<p>               Bases: <code>Component</code></p> <p>Builds the airport trip matrices.</p> <p>input: nonres/{year}_{tofrom}{airport}.csv output: five time-of-day-specific OMX files with matrices DA, SR2, SR3</p> <p>Notes: These are independent of level-of-service.</p> <p>Note that the reference names, years, file paths and other key details are controlled via the config, air_passenger section. See the AirPassengerConfig doc for details on specifying these inputs.</p> <p>The following details are based on the default config values.</p> <p>Creates air passenger vehicle trip tables for the Bay Area\u2019s three major airports, namely SFO, OAK, and SJC.  Geoff Gosling, a consultant, created vehicle trip tables segmented by time of day, travel mode, and access/egress direction (i.e. to the airport or from the airport) for years 2007 and 2035. The tables are based on a 2006 Air Passenger survey, which was conducted at SFO and OAK (but not SJC).</p> The travel modes are as follows <p>(a) escort (drive alone, shared ride 2, and shared ride 3+) (b) park (da, sr2, &amp; sr3+) \u00a9 rental car (da, sr2, &amp; sr3+) (d) taxi ((da, sr2, &amp; sr3+) (e) limo (da, sr2, &amp; sr3+) (f) shared ride van (all assumed to be sr3); (g) hotel shuttle (all assumed to be sr3); and, (h) charter bus (all assumed to be sr3).</p> <p>The shared ride van, hotel shuttle, and charter bus modes are assumed to have no deadhead travel. The return escort trip is included, as are the deadhead limo and taxi trips.</p> <p>The scripts reads in csv files adapted from Mr. Gosling\u2019s Excel files, and creates a highway-assignment ready OMX matrix file for each time-of-day interval.</p> <p>Assumes that no air passengers use HOT lanes (probably not exactly true in certain future year scenarios, but the assumption is made here as a simplification).  Simple linear interpolations are used to estimate vehicle demand in years other than 2007 and 2035, including 2015, 2020, 2025, 2030, and 2040.</p> <p>Transit travel to the airports is not included in these vehicle trip tables.</p> Input <p>Year-, access/egress-, and airport-specific database file with 90 columns of data for each TAZ.  There are 18 columns for each time-of-day interval as follows:         (1)   Escort, drive alone         (2)   Escort, shared ride 2         (3)   Escort, shared ride 3+         (4)   Park, drive alone         (5)   Park, shared ride 2         (6)   Park, shared ride 3+         (7)   Rental car, drive alone         (8)   Rental car, shared ride 2         (9)   Rental car, shared ride 3+         (10)  Taxi, drive alone         (11)  Taxi, shared ride 2         (12)  Taxi, shared ride 3+         (13)  Limo, drive alone         (14)  Limo, shared ride 2         (15)  Limo, shared ride 3+         (16)  Shared ride van, shared ride 3+         (17)  Hotel shuttle, shared ride 3+         (18)  Charter bus, shared ride 3+</p> <p>Five time-of-day-specific tables, each containing origin/destination vehicle  matrices for the following modes:            (1) drive alone (DA)            (2) shared ride 2 (SR2)            (3) shared ride 3+ (SR3)</p> Internal properties <p>_start_year _end_year _mode_groups: _out_names:</p> Source code in <code>tm2py/components/demand/air_passenger.py</code> <pre><code>class AirPassenger(Component):\n    \"\"\"Builds the airport trip matrices.\n\n    input: nonres/{year}_{tofrom}{airport}.csv\n    output: five time-of-day-specific OMX files with matrices DA, SR2, SR3\n\n    Notes:\n    These are independent of level-of-service.\n\n    Note that the reference names, years, file paths and other key details\n    are controlled via the config, air_passenger section. See the\n    AirPassengerConfig doc for details on specifying these inputs.\n\n    The following details are based on the default config values.\n\n    Creates air passenger vehicle trip tables for the Bay Area's three major\n    airports, namely SFO, OAK, and SJC.  Geoff Gosling, a consultant, created\n    vehicle trip tables segmented by time of day, travel mode, and access/egress\n    direction (i.e. to the airport or from the airport) for years 2007 and 2035.\n    The tables are based on a 2006 Air Passenger survey, which was conducted\n    at SFO and OAK (but not SJC).\n\n    The travel modes are as follows:\n        (a) escort (drive alone, shared ride 2, and shared ride 3+)\n        (b) park (da, sr2, &amp; sr3+)\n        (c) rental car (da, sr2, &amp; sr3+)\n        (d) taxi ((da, sr2, &amp; sr3+)\n        (e) limo (da, sr2, &amp; sr3+)\n        (f) shared ride van (all assumed to be sr3);\n        (g) hotel shuttle (all assumed to be sr3); and,\n        (h) charter bus (all assumed to be sr3).\n\n    The shared ride van, hotel shuttle, and charter bus modes are assumed to\n    have no deadhead travel. The return escort trip is included, as are the\n    deadhead limo and taxi trips.\n\n    The scripts reads in csv files adapted from Mr. Gosling's Excel files,\n    and creates a highway-assignment ready OMX matrix file for each time-of-day\n    interval.\n\n    Assumes that no air passengers use HOT lanes (probably not exactly true\n    in certain future year scenarios, but the assumption is made here as a\n    simplification).  Simple linear interpolations are used to estimate vehicle\n    demand in years other than 2007 and 2035, including 2015, 2020, 2025, 2030,\n    and 2040.\n\n    Transit travel to the airports is not included in these vehicle trip tables.\n\n    Input:\n        Year-, access/egress-, and airport-specific database file with 90 columns\n        of data for each TAZ.  There are 18 columns for each time-of-day interval\n        as follows:\n                (1)   Escort, drive alone\n                (2)   Escort, shared ride 2\n                (3)   Escort, shared ride 3+\n                (4)   Park, drive alone\n                (5)   Park, shared ride 2\n                (6)   Park, shared ride 3+\n                (7)   Rental car, drive alone\n                (8)   Rental car, shared ride 2\n                (9)   Rental car, shared ride 3+\n                (10)  Taxi, drive alone\n                (11)  Taxi, shared ride 2\n                (12)  Taxi, shared ride 3+\n                (13)  Limo, drive alone\n                (14)  Limo, shared ride 2\n                (15)  Limo, shared ride 3+\n                (16)  Shared ride van, shared ride 3+\n                (17)  Hotel shuttle, shared ride 3+\n                (18)  Charter bus, shared ride 3+\n\n     Output:\n     Five time-of-day-specific tables, each containing origin/destination vehicle\n     matrices for the following modes:\n               (1) drive alone (DA)\n               (2) shared ride 2 (SR2)\n               (3) shared ride 3+ (SR3)\n\n    Internal properties:\n        _start_year\n        _end_year\n        _mode_groups:\n        _out_names:\n    \"\"\"\n\n    def __init__(self, controller: RunController):\n        \"\"\"Build the airport trip matrices.\n\n        Args:\n            controller: parent Controller object\n        \"\"\"\n        super().__init__(controller)\n\n        self.config = self.controller.config.air_passenger\n\n        self.start_year = self.config.reference_start_year\n        self.end_year = self.config.reference_end_year\n        self.scenario_year = self.controller.config.scenario.year\n\n        self.airports = self.controller.config.air_passenger.airport_names\n\n        self._demand_classes = None\n        self._access_mode_groups = None\n        self._class_modes = None\n\n    @property\n    def classes(self):\n        return [c.name for c in self.config.demand_aggregation]\n\n    @property\n    def demand_classes(self):\n        if not self._demand_classes:\n            self._demand_classes = {c.name: c for c in self.config.demand_aggregation}\n        return self._demand_classes\n\n    @property\n    def access_mode_groups(self):\n        if not self._access_mode_groups:\n            self._access_mode_groups = {\n                c_name: c.access_modes for c_name, c in self.demand_classes.items()\n            }\n        return self._access_mode_groups\n\n    @property\n    def class_modes(self):\n        if self._class_modes is None:\n            self._class_modes = {\n                c_name: c.mode for c_name, c in self.demand_classes.items()\n            }\n        return self._class_modes\n\n    def validate_inputs(self):\n        \"\"\"Validate the inputs.\"\"\"\n        # TODO\n        pass\n\n    @LogStartEnd()\n    def run(self):\n        \"\"\"Run the Air Passenger Demand model to generate the demand matrices.\n\n        Steps:\n            1. Load the demand data from the CSV files.\n            2. Aggregate the demand data into the assignable classes.\n            3. Create the demand matrices be interpolating the demand data.\n            4. Write the demand matrices to OMX files.\n        \"\"\"\n\n        input_demand = self._load_air_pax_demand()\n        aggr_demand = self._aggregate_demand(input_demand)\n\n        demand = interpolate_dfs(\n            aggr_demand,\n            [self.start_year, self.end_year],\n            self.scenario_year,\n        )\n        self._export_result(demand)\n\n    def _load_air_pax_demand(self) -&gt; pd.DataFrame:\n        \"\"\"Loads demand from the CSV files into single pandas dataframe.\n\n        Uses the following configs to determine the input file names and paths:\n        - self.config.air_passenger.input_demand_folder\n        - self.config.air_passenger.airport_names\n        - self.config.air_passenger.reference_start_year\n        - self.config.air_passenger.reference_end_year\n\n        Using the pattern: f\"{year}_{direction}{airport}.csv\"\n\n        Returns: pandas dataframe with the following columns:\n            (1) airport\n            (2) time_of_day\n            (3) access_mode\n            (4) demand\n        \"\"\"\n\n        _start_demand_df = self._get_air_demand_for_year(self.start_year)\n        _end_demand_df = self._get_air_demand_for_year(self.end_year)\n\n        _air_pax_demand_df = pd.merge(\n            _start_demand_df,\n            _end_demand_df,\n            how=\"outer\",\n            suffixes=(f\"_{self.start_year}\", f\"_{self.end_year}\"),\n            on=[\"ORIG\", \"DEST\"],\n        )\n\n        _grouped_air_pax_demand_df = _air_pax_demand_df.groupby([\"ORIG\", \"DEST\"]).sum()\n        return _grouped_air_pax_demand_df\n\n    def _input_demand_filename(self, airport, year, direction):\n        _file_name = self.config.input_demand_filename_tmpl.format(\n            airport=airport, year=year, direction=direction\n        )\n\n        return os.path.join(\n            self.get_abs_path(self.config.input_demand_folder), _file_name\n        )\n\n    def _get_air_demand_for_year(self, year) -&gt; pd.DataFrame:\n        \"\"\"Creates a dataframe of concatenated data from CSVs for all airport x direction combos.\n\n        Args:\n            year (str): year of demand\n\n        Returns:\n            pd.DataFrame: concatenation of all CSVs that were read in as a dataframe\n        \"\"\"\n        _airport_direction = itertools.product(\n            self.airports,\n            [\"to\", \"from\"],\n        )\n        demand_df = None\n        for airport, direction in _airport_direction:\n            _df = pd.read_csv(self._input_demand_filename(airport, year, direction))\n            if demand_df is not None:\n                demand_df = pd.concat([demand_df, _df])\n            else:\n                demand_df = _df\n\n        return demand_df\n\n    def _aggregate_demand(self, input_demand: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Aggregate demand accross access modes to assignable classes for each year.\n\n        Args:\n            input_demand: pandas dataframe with the columns for each combo of:\n                {_period}_{_access}_{_group}_{_year}\n        \"\"\"\n        aggr_demand = pd.DataFrame()\n\n        _year_tp_group_accessmode = itertools.product(\n            [self.start_year, self.end_year],\n            self.time_period_names,\n            self.access_mode_groups.items(),\n        )\n\n        # TODO This should be done entirely in pandas using group-by\n        for _year, _period, (_class, _access_modes) in _year_tp_group_accessmode:\n            data = input_demand[\n                [f\"{_period}_{_access}_{_class}_{_year}\" for _access in _access_modes]\n            ]\n            aggr_demand[f\"{_period}_{_class}_{_year}\"] = data.sum(axis=1)\n\n        return aggr_demand\n\n    def _export_result(self, demand_df: pd.DataFrame):\n        \"\"\"Export resulting model year demand to OMX files by period.\"\"\"\n        path_tmplt = self.get_abs_path(self.config.output_trip_table_directory)\n        os.makedirs(os.path.dirname(path_tmplt), exist_ok=True)\n\n        for _period in self.time_period_names:\n            _file_path = os.path.join(\n                path_tmplt, self.config.outfile_trip_table_tmp.format(period=_period)\n            )\n            df_to_omx(\n                demand_df,\n                {\n                    _mode: f\"{_period}_{_class}\"\n                    for _class, _mode in self.class_modes.items()\n                },\n                _file_path,\n                orig_column=\"ORIG\",\n                dest_column=\"DEST\",\n            )\n</code></pre>"},{"location":"api/#tm2py.components.demand.air_passenger.AirPassenger.__init__","title":"<code>__init__(controller)</code>","text":"<p>Build the airport trip matrices.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>parent Controller object</p> required Source code in <code>tm2py/components/demand/air_passenger.py</code> <pre><code>def __init__(self, controller: RunController):\n    \"\"\"Build the airport trip matrices.\n\n    Args:\n        controller: parent Controller object\n    \"\"\"\n    super().__init__(controller)\n\n    self.config = self.controller.config.air_passenger\n\n    self.start_year = self.config.reference_start_year\n    self.end_year = self.config.reference_end_year\n    self.scenario_year = self.controller.config.scenario.year\n\n    self.airports = self.controller.config.air_passenger.airport_names\n\n    self._demand_classes = None\n    self._access_mode_groups = None\n    self._class_modes = None\n</code></pre>"},{"location":"api/#tm2py.components.demand.air_passenger.AirPassenger.run","title":"<code>run()</code>","text":"<p>Run the Air Passenger Demand model to generate the demand matrices.</p> Steps <ol> <li>Load the demand data from the CSV files.</li> <li>Aggregate the demand data into the assignable classes.</li> <li>Create the demand matrices be interpolating the demand data.</li> <li>Write the demand matrices to OMX files.</li> </ol> Source code in <code>tm2py/components/demand/air_passenger.py</code> <pre><code>@LogStartEnd()\ndef run(self):\n    \"\"\"Run the Air Passenger Demand model to generate the demand matrices.\n\n    Steps:\n        1. Load the demand data from the CSV files.\n        2. Aggregate the demand data into the assignable classes.\n        3. Create the demand matrices be interpolating the demand data.\n        4. Write the demand matrices to OMX files.\n    \"\"\"\n\n    input_demand = self._load_air_pax_demand()\n    aggr_demand = self._aggregate_demand(input_demand)\n\n    demand = interpolate_dfs(\n        aggr_demand,\n        [self.start_year, self.end_year],\n        self.scenario_year,\n    )\n    self._export_result(demand)\n</code></pre>"},{"location":"api/#tm2py.components.demand.air_passenger.AirPassenger.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate the inputs.</p> Source code in <code>tm2py/components/demand/air_passenger.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate the inputs.\"\"\"\n    # TODO\n    pass\n</code></pre>"},{"location":"api/#commercial-demand","title":"Commercial Demand","text":"<p>Commercial vehicle / truck model module.</p> <p>               Bases: <code>ConfigItem</code></p> <p>Truck model parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TruckConfig(ConfigItem):\n    \"\"\"Truck model parameters.\"\"\"\n\n    classes: List[TruckClassConfig]\n    impedances: List[ImpedanceConfig]\n    trip_gen: TripGenerationConfig\n    trip_dist: TripDistributionConfig\n    time_of_day: TimeOfDayConfig\n    toll_choice: TollChoiceConfig\n    output_trip_table_directory: pathlib.Path\n    outfile_trip_table_tmp: str\n    highway_demand_file: str\n\n    \"\"\"\n    @validator(\"classes\")\n    def class_consistency(cls, v, values):\n        # TODO Can't get to work righ tnow\n        _class_names = [c.name for c in v]\n        _gen_classes = [c.name for c in values[\"trip_gen\"]]\n        _dist_classes = [c.name for c in values[\"trip_dist\"]]\n        _time_classes = [c.name for c in values[\"time_split\"]]\n        _toll_classes = [c.name for c in values[\"toll_choice\"]]\n\n        assert (\n            _class_names == _gen_classes\n        ), \"truck.classes ({_class_names}) doesn't equal\\\n            class names in truck.trip_gen ({_gen_classes}).\"\n        assert (\n            _class_names == _dist_classes\n        ), \"truck.classes ({_class_names}) doesn't  equal\\\n            class names in truck.trip_dist ({_dist_classes}).\"\n        assert (\n            _class_names == _time_classes\n        ), \"truck.classes ({_class_names}) doesn't  equal\\\n            class names in truck.time_split ({_time_classes}).\"\n        assert (\n            _class_names == _toll_classes\n        ), \"truck.classes ({_class_names}) doesn't equal\\\n            class names in truck.toll_choice ({_toll_classes}).\"\n\n        return v\n    \"\"\"\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleModel","title":"<code>CommercialVehicleModel</code>","text":"<p>               Bases: <code>Component</code></p> <p>Commercial Vehicle demand model.</p> Generates truck demand matrices from <ul> <li>land use</li> <li>highway network impedances</li> <li>parameters</li> </ul> Segmented into four truck types <p>(1) very small trucks (two-axle, four-tire), (2) small trucks (two-axle, six-tire), (3) medium trucks (three-axle), (4) large or combination (four or more axle) trucks.</p> (1) MAZ csv data file with the employment and household counts. <p>(2) Skims (3) K-Factors (4)</p> <p>Notes: (1) Based on the BAYCAST truck model, no significant updates. (2) Combined Chuck\u2019s calibration adjustments into the NAICS-based model coefficients.</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>class CommercialVehicleModel(Component):\n    \"\"\"Commercial Vehicle demand model.\n\n    Generates truck demand matrices from:\n        - land use\n        - highway network impedances\n        - parameters\n\n    Segmented into four truck types:\n        (1) very small trucks (two-axle, four-tire),\n        (2) small trucks (two-axle, six-tire),\n        (3) medium trucks (three-axle),\n        (4) large or combination (four or more axle) trucks.\n\n    Input:  (1) MAZ csv data file with the employment and household counts.\n            (2) Skims\n            (3) K-Factors\n            (4)\n    Output:\n\n    Notes:\n    (1) Based on the BAYCAST truck model, no significant updates.\n    (2) Combined Chuck's calibration adjustments into the NAICS-based model coefficients.\n    \"\"\"\n\n    def __init__(self, controller: RunController):\n        \"\"\"Constructor for the CommercialVehicleTripGeneration component.\n\n        Args:\n            controller (RunController): Run controller for model run.\n        \"\"\"\n        super().__init__(controller)\n\n        self.config = self.controller.config.truck\n        self.sub_components = {\n            \"trip generation\": CommercialVehicleTripGeneration(controller, self),\n            \"trip distribution\": CommercialVehicleTripDistribution(controller, self),\n            \"time of day\": CommercialVehicleTimeOfDay(controller, self),\n            \"toll choice\": CommercialVehicleTollChoice(controller, self),\n        }\n\n        self.trk_impedances = {imp.name: imp for imp in self.config.impedances}\n\n        # Emme matrix management (lazily evaluated)\n        self._matrix_cache = None\n\n        # Interim Results\n        self.total_tripends_df = None\n        self.daily_demand_dict = None\n        self.trkclass_tp_demand_dict = None\n        self.trkclass_tp_toll_demand_dict = None\n\n    @property\n    def purposes(self):\n        return list(\n            set([trk_class.purpose for trk_class in self.config.trip_gen.classes])\n        )\n\n    @property\n    def classes(self):\n        return [trk_class.name for trk_class in self.config.classes]\n\n    def validate_inputs(self):\n        \"\"\"Validate the inputs.\"\"\"\n        # TODO\n\n    @LogStartEnd()\n    def run(self):\n        \"\"\"Run commercial vehicle model.\"\"\"\n        self.total_tripends_df = self.sub_components[\"trip generation\"].run()\n        self.daily_demand_dict = self.sub_components[\"trip distribution\"].run(\n            self.total_tripends_df\n        )\n        self.trkclass_tp_demand_dict = self.sub_components[\"time of day\"].run(\n            self.daily_demand_dict\n        )\n        self.trkclass_tp_toll_demand_dict = self.sub_components[\"toll choice\"].run(\n            self.trkclass_tp_demand_dict\n        )\n        self._export_results_as_omx(self.trkclass_tp_toll_demand_dict)\n\n    @property\n    def emmebank(self):\n        \"\"\"Reference to highway assignment Emmebank.\n\n        TODO\n            This should really be in the controller?\n            Or part of network.skims?\n        \"\"\"\n        self._emmebank = self.controller.emme_manager.highway_emmebank\n        return self._emmebank\n\n    @property\n    def emme_scenario(self):\n        \"\"\"Return emme scenario from emmebank.\n\n        Use first valid scenario for reference Zone IDs.\n\n        TODO\n            This should really be in the controller?\n            Or part of network.skims?\n        \"\"\"\n        _ref_scenario_name = self.controller.config.time_periods[0].name\n        return self.emmebank.scenario(_ref_scenario_name)\n\n    @property\n    def matrix_cache(self):\n        \"\"\"Access to MatrixCache to Emmebank for given emme_scenario.\"\"\"\n        if self._matrix_cache is None:\n            self._matrix_cache = MatrixCache(self.emme_scenario)\n        return self._matrix_cache\n\n    @LogStartEnd(level=\"DEBUG\")\n    def _export_results_as_omx(self, class_demand):\n        \"\"\"Export assignable class demands to OMX files by time-of-day.\"\"\"\n        outdir = self.get_abs_path(self.config.output_trip_table_directory)\n        os.makedirs(os.path.dirname(outdir), exist_ok=True)\n        for period, matrices in class_demand.items():\n            with OMXManager(\n                os.path.join(\n                    outdir, self.config.outfile_trip_table_tmp.format(period=period)\n                ),\n                \"w\",\n            ) as output_file:\n                for name, data in matrices.items():\n                    output_file.write_array(data, name)\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleModel.emme_scenario","title":"<code>emme_scenario</code>  <code>property</code>","text":"<p>Return emme scenario from emmebank.</p> <p>Use first valid scenario for reference Zone IDs.</p> <p>TODO     This should really be in the controller?     Or part of network.skims?</p>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleModel.emmebank","title":"<code>emmebank</code>  <code>property</code>","text":"<p>Reference to highway assignment Emmebank.</p> <p>TODO     This should really be in the controller?     Or part of network.skims?</p>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleModel.matrix_cache","title":"<code>matrix_cache</code>  <code>property</code>","text":"<p>Access to MatrixCache to Emmebank for given emme_scenario.</p>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleModel.__init__","title":"<code>__init__(controller)</code>","text":"<p>Constructor for the CommercialVehicleTripGeneration component.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>Run controller for model run.</p> required Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>def __init__(self, controller: RunController):\n    \"\"\"Constructor for the CommercialVehicleTripGeneration component.\n\n    Args:\n        controller (RunController): Run controller for model run.\n    \"\"\"\n    super().__init__(controller)\n\n    self.config = self.controller.config.truck\n    self.sub_components = {\n        \"trip generation\": CommercialVehicleTripGeneration(controller, self),\n        \"trip distribution\": CommercialVehicleTripDistribution(controller, self),\n        \"time of day\": CommercialVehicleTimeOfDay(controller, self),\n        \"toll choice\": CommercialVehicleTollChoice(controller, self),\n    }\n\n    self.trk_impedances = {imp.name: imp for imp in self.config.impedances}\n\n    # Emme matrix management (lazily evaluated)\n    self._matrix_cache = None\n\n    # Interim Results\n    self.total_tripends_df = None\n    self.daily_demand_dict = None\n    self.trkclass_tp_demand_dict = None\n    self.trkclass_tp_toll_demand_dict = None\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleModel.run","title":"<code>run()</code>","text":"<p>Run commercial vehicle model.</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>@LogStartEnd()\ndef run(self):\n    \"\"\"Run commercial vehicle model.\"\"\"\n    self.total_tripends_df = self.sub_components[\"trip generation\"].run()\n    self.daily_demand_dict = self.sub_components[\"trip distribution\"].run(\n        self.total_tripends_df\n    )\n    self.trkclass_tp_demand_dict = self.sub_components[\"time of day\"].run(\n        self.daily_demand_dict\n    )\n    self.trkclass_tp_toll_demand_dict = self.sub_components[\"toll choice\"].run(\n        self.trkclass_tp_demand_dict\n    )\n    self._export_results_as_omx(self.trkclass_tp_toll_demand_dict)\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleModel.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate the inputs.</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate the inputs.\"\"\"\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTimeOfDay","title":"<code>CommercialVehicleTimeOfDay</code>","text":"<p>               Bases: <code>Subcomponent</code></p> <p>Commercial vehicle (truck) Time of Day Split for 4 sizes of truck.</p> <p>Input:  Trips origin and destination matrices by 4 truck sizes Ouput:  20 trips origin and destination matrices by 4 truck sizes by 5 times periods</p> Note <p>The diurnal factors are taken from the BAYCAST-90 model with adjustments made</p> <p>during calibration to the very small truck values to better match counts.</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>class CommercialVehicleTimeOfDay(Subcomponent):\n    \"\"\"Commercial vehicle (truck) Time of Day Split for 4 sizes of truck.\n\n    Input:  Trips origin and destination matrices by 4 truck sizes\n    Ouput:  20 trips origin and destination matrices by 4 truck sizes by 5 times periods\n\n    Note:\n        The diurnal factors are taken from the BAYCAST-90 model with adjustments made\n    during calibration to the very small truck values to better match counts.\n    \"\"\"\n\n    def __init__(self, controller: RunController, component: Component):\n        \"\"\"Constructor for the CommercialVehicleTimeOfDay component.\n\n        Args:\n            controller (RunController): Run controller for model run.\n            component (Component): Parent component of sub-component\n        \"\"\"\n        super().__init__(controller, component)\n\n        self.config = self.component.config.time_of_day\n\n        self.split_factor = \"od\"\n        self._class_configs = None\n        self._class_period_splits = None\n\n    @property\n    def time_periods(self):\n        return self.controller.config.time_periods\n\n    @property\n    def classes(self):\n        return [trk_class.name for trk_class in self.config.classes]\n\n    @property\n    def class_configs(self):\n        if not self._class_configs:\n            self._class_configs = {c.name: c for c in self.config.classes}\n        return self._class_configs\n\n    @property\n    def class_period_splits(self):\n        \"\"\"Returns split fraction dictonary mapped to [time period class][time period].\"\"\"\n        if not self._class_period_splits:\n            self._class_period_splits = {\n                c_name: {c.time_period: c for c in config.time_period_split}\n                for c_name, config in self.class_configs.items()\n            }\n\n        return self._class_period_splits\n\n    def validate_inputs(self):\n        \"\"\"Validate the inputs.\"\"\"\n        # TODO\n        pass\n\n    @LogStartEnd()\n    def run(\n        self, daily_demand: Dict[str, NumpyArray]\n    ) -&gt; Dict[str, Dict[str, NumpyArray]]:\n        \"\"\"Splits the daily demand by time of day based on factors in the config.\n\n        Uses self.config.truck.classes.{class_name}.time_of_day_split to split the daily demand.\n\n        #TODO use TimePeriodSplit\n        Args:\n            daily_demand: dictionary of truck type name to numpy array of\n                truck type daily demand\n\n        Returns:\n             Nested dictionary of truck class: time period name =&gt; numpy array of demand\n        \"\"\"\n        trkclass_tp_demand_dict = defaultdict(dict)\n\n        _class_timeperiod = itertools.product(self.classes, self.time_period_names)\n\n        for _t_class, _tp in _class_timeperiod:\n            trkclass_tp_demand_dict[_t_class][_tp] = np.around(\n                self.class_period_splits[_t_class][_tp.lower()][self.split_factor]\n                * daily_demand[_t_class],\n                decimals=2,\n            )\n\n        return trkclass_tp_demand_dict\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTimeOfDay.class_period_splits","title":"<code>class_period_splits</code>  <code>property</code>","text":"<p>Returns split fraction dictonary mapped to [time period class][time period].</p>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTimeOfDay.__init__","title":"<code>__init__(controller, component)</code>","text":"<p>Constructor for the CommercialVehicleTimeOfDay component.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>Run controller for model run.</p> required <code>component</code> <code>Component</code> <p>Parent component of sub-component</p> required Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>def __init__(self, controller: RunController, component: Component):\n    \"\"\"Constructor for the CommercialVehicleTimeOfDay component.\n\n    Args:\n        controller (RunController): Run controller for model run.\n        component (Component): Parent component of sub-component\n    \"\"\"\n    super().__init__(controller, component)\n\n    self.config = self.component.config.time_of_day\n\n    self.split_factor = \"od\"\n    self._class_configs = None\n    self._class_period_splits = None\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTimeOfDay.run","title":"<code>run(daily_demand)</code>","text":"<p>Splits the daily demand by time of day based on factors in the config.</p> <p>Uses self.config.truck.classes.{class_name}.time_of_day_split to split the daily demand.</p>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTimeOfDay.run--todo-use-timeperiodsplit","title":"TODO use TimePeriodSplit","text":"<p>Args:     daily_demand: dictionary of truck type name to numpy array of         truck type daily demand</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, NumpyArray]]</code> <p>Nested dictionary of truck class: time period name =&gt; numpy array of demand</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>@LogStartEnd()\ndef run(\n    self, daily_demand: Dict[str, NumpyArray]\n) -&gt; Dict[str, Dict[str, NumpyArray]]:\n    \"\"\"Splits the daily demand by time of day based on factors in the config.\n\n    Uses self.config.truck.classes.{class_name}.time_of_day_split to split the daily demand.\n\n    #TODO use TimePeriodSplit\n    Args:\n        daily_demand: dictionary of truck type name to numpy array of\n            truck type daily demand\n\n    Returns:\n         Nested dictionary of truck class: time period name =&gt; numpy array of demand\n    \"\"\"\n    trkclass_tp_demand_dict = defaultdict(dict)\n\n    _class_timeperiod = itertools.product(self.classes, self.time_period_names)\n\n    for _t_class, _tp in _class_timeperiod:\n        trkclass_tp_demand_dict[_t_class][_tp] = np.around(\n            self.class_period_splits[_t_class][_tp.lower()][self.split_factor]\n            * daily_demand[_t_class],\n            decimals=2,\n        )\n\n    return trkclass_tp_demand_dict\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTimeOfDay.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate the inputs.</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate the inputs.\"\"\"\n    # TODO\n    pass\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTollChoice","title":"<code>CommercialVehicleTollChoice</code>","text":"<p>               Bases: <code>Subcomponent</code></p> <p>Commercial vehicle (truck) toll choice.</p> <p>A binomial choice model for very small, small, medium, and large trucks. A separate value toll paying versus no value toll paying path choice model is applied to each of the twenty time period and vehicle type combinations.</p> (1) Trip tables by time of day and truck class <p>(2) Skims providing the time and cost for value toll and non-value toll paths for each; the matrix names in the OMX files are:     \u201c{period}{cls_name}_time\u201d     \u201c{period}{cls_name}dist\u201d     \u201c{period}{cls_name}bridgetoll{grp_name}\u201d     \u201c{period}{cls_name}toll_time\u201d     \u201c{period}{cls_name}toll_dist\u201d     \u201c{period}{cls_name}toll_bridgetoll{grp_name}\u201d     \u201c{period}_{cls_name}toll_valuetoll{grp_name}\u201d Where period is the assignment period, cls_name is the truck assignment class name (as very small, small and medium truck are assigned as the same class) and grp_name is the truck type name (as the tolls are calculated separately for very small, small and medium).</p> (1)  TOLLCLASS is a code, 1 through 10 are reserved for bridges; 11 and up is <p>reserved for value toll facilities.</p> <pre><code>    (2)  All costs should be coded in year 2000 cents\n    (3)  The 2-axle fee is used for very small trucks\n    (4)  The 2-axle fee is used for small trucks\n    (5)  The 3-axle fee is used for medium trucks\n    (6)  The average of the 5-axle and 6-axle fee is used for large trucks\n         (about the midpoint of the fee schedule).\n    (7)  The in-vehicle time coefficient is from the work trip mode choice model.\n</code></pre> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>class CommercialVehicleTollChoice(Subcomponent):\n    \"\"\"Commercial vehicle (truck) toll choice.\n\n    A binomial choice model for very small, small, medium, and large trucks.\n    A separate value toll paying versus no value toll paying path choice\n    model is applied to each of the twenty time period and vehicle type combinations.\n\n    Input:  (1) Trip tables by time of day and truck class\n            (2) Skims providing the time and cost for value toll and non-value toll paths\n            for each; the matrix names in the OMX files are:\n                \"{period}_{cls_name}_time\"\n                \"{period}_{cls_name}_dist\"\n                \"{period}_{cls_name}_bridgetoll{grp_name}\"\n                \"{period}_{cls_name}toll_time\"\n                \"{period}_{cls_name}toll_dist\"\n                \"{period}_{cls_name}toll_bridgetoll{grp_name}\"\n                \"{period}_{cls_name}toll_valuetoll{grp_name}\"\n            Where period is the assignment period, cls_name is the truck assignment\n            class name (as very small, small and medium truck are assigned as the\n            same class) and grp_name is the truck type name (as the tolls are\n            calculated separately for very small, small and medium).\n\n    Results: a total of forty demand matrices, by time of day, truck type and toll/non-toll.\n\n    Notes:  (1)  TOLLCLASS is a code, 1 through 10 are reserved for bridges; 11 and up is\n                 reserved for value toll facilities.\n            (2)  All costs should be coded in year 2000 cents\n            (3)  The 2-axle fee is used for very small trucks\n            (4)  The 2-axle fee is used for small trucks\n            (5)  The 3-axle fee is used for medium trucks\n            (6)  The average of the 5-axle and 6-axle fee is used for large trucks\n                 (about the midpoint of the fee schedule).\n            (7)  The in-vehicle time coefficient is from the work trip mode choice model.\n    \"\"\"\n\n    def __init__(self, controller, component):\n        \"\"\"Constructor for Commercial Vehicle Toll Choice.\n\n        Also calls Subclass __init__().\n\n        Args:\n            controller: model run controller\n            component: parent component\n        \"\"\"\n        super().__init__(controller, component)\n\n        self.config = self.component.config.toll_choice\n\n        self.sub_components = {\n            \"toll choice calculator\": TollChoiceCalculator(\n                controller,\n                self,\n                self.config,\n            ),\n        }\n\n        # shortcut\n        self._toll_choice = self.sub_components[\"toll choice calculator\"]\n        self._toll_choice.toll_skim_suffix = \"trk\"\n\n    def validate_inputs(self):\n        \"\"\"Validate the inputs.\"\"\"\n        # TODO\n        pass\n\n    @LogStartEnd()\n    def run(self, trkclass_tp_demand_dict):\n        \"\"\"Split per-period truck demands into nontoll and toll classes.\n\n        Uses OMX skims output from highway assignment: traffic_skims_{period}.omx\"\"\"\n\n        _tclass_time_combos = itertools.product(\n            self.time_period_names, self.config.classes\n        )\n\n        class_demands = defaultdict(dict)\n        for _time_period, _tclass in _tclass_time_combos:\n            _split_demand = self._toll_choice.run(\n                trkclass_tp_demand_dict[_tclass.name][_time_period],\n                _tclass.name,\n                _time_period,\n            )\n\n            class_demands[_time_period][_tclass.name] = _split_demand[\"non toll\"]\n            class_demands[_time_period][f\"{_tclass.name}toll\"] = _split_demand[\"toll\"]\n        return class_demands\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTollChoice.__init__","title":"<code>__init__(controller, component)</code>","text":"<p>Constructor for Commercial Vehicle Toll Choice.</p> <p>Also calls Subclass init().</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <p>model run controller</p> required <code>component</code> <p>parent component</p> required Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>def __init__(self, controller, component):\n    \"\"\"Constructor for Commercial Vehicle Toll Choice.\n\n    Also calls Subclass __init__().\n\n    Args:\n        controller: model run controller\n        component: parent component\n    \"\"\"\n    super().__init__(controller, component)\n\n    self.config = self.component.config.toll_choice\n\n    self.sub_components = {\n        \"toll choice calculator\": TollChoiceCalculator(\n            controller,\n            self,\n            self.config,\n        ),\n    }\n\n    # shortcut\n    self._toll_choice = self.sub_components[\"toll choice calculator\"]\n    self._toll_choice.toll_skim_suffix = \"trk\"\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTollChoice.run","title":"<code>run(trkclass_tp_demand_dict)</code>","text":"<p>Split per-period truck demands into nontoll and toll classes.</p> <p>Uses OMX skims output from highway assignment: traffic_skims_{period}.omx</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>@LogStartEnd()\ndef run(self, trkclass_tp_demand_dict):\n    \"\"\"Split per-period truck demands into nontoll and toll classes.\n\n    Uses OMX skims output from highway assignment: traffic_skims_{period}.omx\"\"\"\n\n    _tclass_time_combos = itertools.product(\n        self.time_period_names, self.config.classes\n    )\n\n    class_demands = defaultdict(dict)\n    for _time_period, _tclass in _tclass_time_combos:\n        _split_demand = self._toll_choice.run(\n            trkclass_tp_demand_dict[_tclass.name][_time_period],\n            _tclass.name,\n            _time_period,\n        )\n\n        class_demands[_time_period][_tclass.name] = _split_demand[\"non toll\"]\n        class_demands[_time_period][f\"{_tclass.name}toll\"] = _split_demand[\"toll\"]\n    return class_demands\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTollChoice.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate the inputs.</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate the inputs.\"\"\"\n    # TODO\n    pass\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTripDistribution","title":"<code>CommercialVehicleTripDistribution</code>","text":"<p>               Bases: <code>Subcomponent</code></p> <p>Commercial vehicle (truck) Trip Distribution for 4 sizes of truck.</p> The four truck types are <p>(1) very small trucks (two-axle, four-tire), (2) small trucks (two-axle, six-tire), (3) medium trucks (three-axle), (4) large or combination (four or more axle) trucks.</p> (1) Trips by 4 truck sizes <p>(2) highway skims for truck, time, distance, bridgetoll and value toll (3) friction factors lookup table (4) k-factors matrix</p> <p>A simple gravity model is used to distribute the truck trips, with separate friction factors used for each class of truck.</p> <p>A blended travel time is used as the impedance measure, specifically the weighted average of the AM travel time (one-third weight) and the midday travel time (two-thirds weight).</p> Input <p>Level-of-service matrices for the AM peak period (6 am to 10 am) and midday period (10 am to 3 pm) which contain truck-class specific estimates of congested travel time (in minutes)</p> <p>A matrix of k-factors, as calibrated by Chuck Purvis.  Note the very small truck model does not use k-factors; the small, medium, and large trucks use the same k-factors.</p> <p>A table of friction factors in text format with the following fields, space separated: - impedance measure (blended travel time); - friction factors for very small trucks; - friction factors for small trucks; - friction factors for medium trucks; and, - friction factors for large trucks.</p> Notes on distribution steps <p>load nonres/truck_kfactors_taz.csv load nonres/truckFF.dat Apply friction factors and kfactors to produce balancing matrix apply the gravity models using friction factors from nonres/truckFF.dat (note the very small trucks do not use the K-factors) Can use Emme matrix balancing for this - important note: reference matrices by name and ensure names are unique Trips rounded to 0.01, causes some instability in results</p> <p>Notes: (1) Based on the BAYCAST truck model, no significant updates. (2) Combined Chuck\u2019s calibration adjustments into the NAICS-based model coefficients.</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>class CommercialVehicleTripDistribution(Subcomponent):\n    \"\"\"Commercial vehicle (truck) Trip Distribution for 4 sizes of truck.\n\n    The four truck types are:\n        (1) very small trucks (two-axle, four-tire),\n        (2) small trucks (two-axle, six-tire),\n        (3) medium trucks (three-axle),\n        (4) large or combination (four or more axle) trucks.\n\n    Input:  (1) Trips by 4 truck sizes\n            (2) highway skims for truck, time, distance, bridgetoll and value toll\n            (3) friction factors lookup table\n            (4) k-factors matrix\n    Ouput:  Trips origin and destination matrices by 4 truck sizes\n\n    A simple gravity model is used to distribute the truck trips, with\n    separate friction factors used for each class of truck.\n\n    A blended travel time is used as the impedance measure, specifically the weighted average\n    of the AM travel time (one-third weight) and the midday travel time (two-thirds weight).\n\n    Input:\n        Level-of-service matrices for the AM peak period (6 am to 10 am) and midday\n        period (10 am to 3 pm) which contain truck-class specific estimates of\n        congested travel time (in minutes)\n\n        A matrix of k-factors, as calibrated by Chuck Purvis.  Note the very small truck model\n        does not use k-factors; the small, medium, and large trucks use the same k-factors.\n\n        A table of friction factors in text format with the following fields, space separated:\n        - impedance measure (blended travel time);\n        - friction factors for very small trucks;\n        - friction factors for small trucks;\n        - friction factors for medium trucks; and,\n        - friction factors for large trucks.\n\n    Notes on distribution steps:\n        load nonres/truck_kfactors_taz.csv\n        load nonres/truckFF.dat\n        Apply friction factors and kfactors to produce balancing matrix\n        apply the gravity models using friction factors from nonres/truckFF.dat\n        (note the very small trucks do not use the K-factors)\n        Can use Emme matrix balancing for this - important note: reference\n        matrices by name and ensure names are unique\n        Trips rounded to 0.01, causes some instability in results\n\n    Results: four total daily trips by truck type\n\n    Notes:\n    (1) Based on the BAYCAST truck model, no significant updates.\n    (2) Combined Chuck's calibration adjustments into the NAICS-based model coefficients.\n\n    \"\"\"\n\n    def __init__(self, controller: RunController, component: Component):\n        \"\"\"Constructor for the CommercialVehicleTripDistribution component.\n\n        Args:\n            controller (RunController): Run controller for model run.\n            component (Component): Parent component of sub-component\n        \"\"\"\n        super().__init__(controller, component)\n\n        self.config = self.component.config.trip_dist\n        self._k_factors = None\n        self._blended_skims = {}\n        self._friction_factors = None\n        self._friction_factor_matrices = {}\n\n        self._class_config = None\n\n    @property\n    def class_config(self):\n        if not self._class_config:\n            self._class_config = {c.name: c for c in self.config.classes}\n\n        return self._class_config\n\n    @property\n    def k_factors(self):\n        \"\"\"Zone-to-zone values of truck K factors.\n\n        Returns:\n             NumpyArray: Zone-to-zone values of truck K factors.\n        \"\"\"\n        if self._k_factors is None:\n            self._k_factors = self._load_k_factors()\n        return self._k_factors\n\n    def _load_k_factors(self):\n        \"\"\"Loads k-factors from self.config.truck.k_factors_file csv file.\n\n        Returns:\n            NumpyArray: Zone-to-zone values of truck K factors.\n\n        \"\"\"\n        \"\"\"return zonal_csv_to_matrices(\n            self.get_abs_path(self.config.k_factors_file),\n            i_column=\"I_taz_tm2_v2_2\",\n            j_column=\"J_taz_tm2_v2_2\",\n            value_columns=\"truck_k\",\n            fill_zones=True,\n            default_value=0,\n            max_zone=max(self.component.emme_scenario.zone_numbers),\n        )[\"truck_k\"].values\"\"\"\n        data = pd.read_csv(self.get_abs_path(self.config.k_factors_file))\n        zones = np.unique(data[\"I_taz_tm2_v2_2\"])\n        num_data_zones = len(zones)\n        row_index = np.searchsorted(zones, data[\"I_taz_tm2_v2_2\"])\n        col_index = np.searchsorted(zones, data[\"J_taz_tm2_v2_2\"])\n        k_factors = np.zeros((num_data_zones, num_data_zones))\n        k_factors[row_index, col_index] = data[\"truck_k\"]\n        num_zones = len(self.component.emme_scenario.zone_numbers)\n        padding = ((0, num_zones - num_data_zones), (0, num_zones - num_data_zones))\n        k_factors = np.pad(k_factors, padding)\n\n        return k_factors\n\n    def blended_skims(self, mode: str):\n        \"\"\"Get blended skim. Creates it if doesn't already exist.\n\n        Args:\n            mode (str): Mode for skim\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        if mode not in self._blended_skims:\n            self._blended_skims[mode] = get_blended_skim(\n                self.controller,\n                mode=mode,\n                blend=self.component.trk_impedances[mode][\"time_blend\"],\n            )\n        return self._blended_skims[mode]\n\n    def friction_factor_matrices(\n        self, trk_class: str, k_factors: Union[None, NumpyArray] = None\n    ) -&gt; NumpyArray:\n        \"\"\"Zone to zone NumpyArray of impedances for a given truck class.\n\n        Args:\n            trk_class (str): Truck class abbreviated name\n            k_factors (Union[None,NumpyArray]): If not None, gives an zone-by-zone array of\n                k-factors--additive impedances to be added on top of friciton factors.\n                Defaults to None.\n\n        Returns:\n            NumpyArray: Zone-by-zone matrix of friction factors\n        \"\"\"\n        if trk_class not in self._friction_factor_matrices.keys():\n            self._friction_factor_matrices[\n                trk_class\n            ] = self._calculate_friction_factor_matrix(\n                trk_class,\n                self.class_config[trk_class].impedance,\n                self.k_factors,\n                self.class_config[trk_class].use_k_factors,\n            )\n\n        return self._friction_factor_matrices[trk_class]\n\n    @LogStartEnd(level=\"DEBUG\")\n    def _calculate_friction_factor_matrix(\n        self,\n        segment_name,\n        blended_skim_name: str,\n        k_factors: Union[None, NumpyArray] = None,\n        use_k_factors: bool = False,\n    ):\n        \"\"\"Calculates friction matrix by interpolating time; optionally multiplying by k_factors.\n\n        Args:\n            segment_name: Name of the segment to calculate the friction factors for (i.e. vstruck)\n            blended_skim_name (str): Name of blended skim\n            k_factors (Union[None,NumpyArray): Optional k-factors matrix\n\n        Returns:\n            friction_matrix NumpyArray: friction matrix for a truck class\n        \"\"\"\n        _friction_matrix = np.interp(\n            self.blended_skims(blended_skim_name),\n            self.friction_factors[\"time\"].tolist(),\n            self.friction_factors[segment_name],\n        )\n\n        if use_k_factors:\n            if k_factors is not None:\n                _friction_matrix = _friction_matrix * k_factors\n\n        return _friction_matrix\n\n    @property\n    def friction_factors(self):\n        \"\"\"Table of friction factors for each time band by truck class.\n\n        Returns:\n            pd.DataFrame: DataFrame of friction factors read from disk.\n        \"\"\"\n        if self._friction_factors is None:\n            self._friction_factors = self._read_ffactors()\n        return self._friction_factors\n\n    def _read_ffactors(self) -&gt; pd.DataFrame:\n        \"\"\"Load friction factors lookup tables from csv file to dataframe.\n\n        Reads from file: config.truck.friction_factors_file with following assumed column order:\n            time: Time\n            vsmtrk: Very Small Truck FF\n            smltrk: Small Truck FF\n            medtrk: Medium Truck FF\n            lrgtrk: Large Truck FF\n        \"\"\"\n        _file_path = self.get_abs_path(self.config.friction_factors_file)\n        return pd.read_csv(_file_path)\n\n    def validate_inputs(self):\n        \"\"\"Validate the inputs.\"\"\"\n        # TODO\n        pass\n\n    @LogStartEnd()\n    def run(self, tripends_df) -&gt; Dict[str, NumpyArray]:\n        \"\"\"Run commercial vehicle trip distribution.\"\"\"\n        daily_demand_dict = {\n            tc: self._distribute_ods(tripends_df, tc) for tc in self.component.classes\n        }\n\n        return daily_demand_dict\n\n    @LogStartEnd(level=\"DEBUG\")\n    def _distribute_ods(\n        self,\n        tripends_df: pd.DataFrame,\n        trk_class: str,\n        orig_factor: float = 0.5,\n        dest_factor: float = 0.5,\n    ) -&gt; NumpyArray:\n        \"\"\"Distribute a trip ends for a given a truck class.\n\n        Args:\n            tripends_df: dataframe with trip ends as \"{trk_class}_prod\" and{trk_class}_attr\".\n            trk_class: name of truck class to distribute.\n            orig_factor (float, optional): Amount to factor towards origins. Defaults to 0.5.\n            dest_factor (float, optional): Amount to factor towards destinations. Defaults to 0.5.\n\n        Returns:\n            NumpyArray: Distributed trip ends for given truck class\n        \"\"\"\n        if orig_factor + dest_factor != 1.0:\n            raise ValueError(\n                \"orig_factor ({orig_factor}) and dest_factor ({dest_factor}) must\\\n                sum to 1.0\"\n            )\n\n        _prod_attr_matrix = self._matrix_balancing(\n            tripends_df[f\"{trk_class}_productions\"].to_numpy(),\n            tripends_df[f\"{trk_class}_attractions\"].to_numpy(),\n            trk_class,\n        )\n        daily_demand = (\n            orig_factor * _prod_attr_matrix\n            + dest_factor * _prod_attr_matrix.transpose()\n        )\n\n        self.logger.log(\n            f\"{trk_class}, prod sum: {_prod_attr_matrix.sum()}, \"\n            f\"daily sum: {daily_demand.sum()}\",\n            level=\"DEBUG\",\n        )\n\n        return daily_demand\n\n    def _matrix_balancing(\n        self,\n        orig_totals: NumpyArray,\n        dest_totals: NumpyArray,\n        trk_class: str,\n    ) -&gt; NumpyArray:\n        \"\"\"Distribute origins and destinations based on friction factors for a givein truck class.\n\n        Args:\n            orig_totals: Total demand for origins as a numpy array\n            dest_totals: Total demand for destinations as a numpy array\n            trk_class (str): Truck class name\n\n\n\n        \"\"\"\n        matrix_balancing = self.controller.emme_manager.modeller.tool(\n            \"inro.emme.matrix_calculation.matrix_balancing\"\n        )\n        matrix_round = self.controller.emme_manager.modeller.tool(\n            \"inro.emme.matrix_calculation.matrix_controlled_rounding\"\n        )\n\n        # Transfer numpy to emmebank\n        _ff_emme_mx_name = self.component.matrix_cache.set_data(\n            f\"{trk_class}_friction\",\n            self.friction_factor_matrices(trk_class),\n            matrix_type=\"FULL\",\n        ).name\n\n        _orig_tots_emme_mx_name = self.component.matrix_cache.set_data(\n            f\"{trk_class}_prod\", orig_totals, matrix_type=\"ORIGIN\"\n        ).name\n\n        _dest_tots_emme_mx_name = self.component.matrix_cache.set_data(\n            f\"{trk_class}_attr\", dest_totals, matrix_type=\"DESTINATION\"\n        ).name\n\n        # Create a destination matrix for output to live in Emmebank\n        _result_emme_mx_name = self.component.matrix_cache.get_or_init_matrix(\n            f\"{trk_class}_daily_demand\"\n        ).name\n\n        spec = {\n            \"od_values_to_balance\": _ff_emme_mx_name,\n            \"origin_totals\": _orig_tots_emme_mx_name,\n            \"destination_totals\": _dest_tots_emme_mx_name,\n            \"allowable_difference\": 0.01,\n            \"max_relative_error\": self.config.max_balance_relative_error,\n            \"max_iterations\": self.config.max_balance_iterations,\n            \"results\": {\"od_balanced_values\": _result_emme_mx_name},\n            \"performance_settings\": {\n                \"allowed_memory\": None,\n                \"number_of_processors\": self.controller.num_processors,\n            },\n            \"type\": \"MATRIX_BALANCING\",\n        }\n        matrix_balancing(spec, scenario=self.component.emme_scenario)\n\n        matrix_round(\n            _result_emme_mx_name,\n            _result_emme_mx_name,\n            min_demand=0.01,\n            values_to_round=\"ALL_NON_ZERO\",\n            scenario=self.component.emme_scenario,\n        )\n\n        return self.component.matrix_cache.get_data(_result_emme_mx_name)\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTripDistribution.friction_factors","title":"<code>friction_factors</code>  <code>property</code>","text":"<p>Table of friction factors for each time band by truck class.</p> <p>Returns:</p> Type Description <p>pd.DataFrame: DataFrame of friction factors read from disk.</p>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTripDistribution.k_factors","title":"<code>k_factors</code>  <code>property</code>","text":"<p>Zone-to-zone values of truck K factors.</p> <p>Returns:</p> Name Type Description <code>NumpyArray</code> <p>Zone-to-zone values of truck K factors.</p>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTripDistribution.__init__","title":"<code>__init__(controller, component)</code>","text":"<p>Constructor for the CommercialVehicleTripDistribution component.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>Run controller for model run.</p> required <code>component</code> <code>Component</code> <p>Parent component of sub-component</p> required Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>def __init__(self, controller: RunController, component: Component):\n    \"\"\"Constructor for the CommercialVehicleTripDistribution component.\n\n    Args:\n        controller (RunController): Run controller for model run.\n        component (Component): Parent component of sub-component\n    \"\"\"\n    super().__init__(controller, component)\n\n    self.config = self.component.config.trip_dist\n    self._k_factors = None\n    self._blended_skims = {}\n    self._friction_factors = None\n    self._friction_factor_matrices = {}\n\n    self._class_config = None\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTripDistribution.blended_skims","title":"<code>blended_skims(mode)</code>","text":"<p>Get blended skim. Creates it if doesn\u2019t already exist.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Mode for skim</p> required <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>def blended_skims(self, mode: str):\n    \"\"\"Get blended skim. Creates it if doesn't already exist.\n\n    Args:\n        mode (str): Mode for skim\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    if mode not in self._blended_skims:\n        self._blended_skims[mode] = get_blended_skim(\n            self.controller,\n            mode=mode,\n            blend=self.component.trk_impedances[mode][\"time_blend\"],\n        )\n    return self._blended_skims[mode]\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTripDistribution.friction_factor_matrices","title":"<code>friction_factor_matrices(trk_class, k_factors=None)</code>","text":"<p>Zone to zone NumpyArray of impedances for a given truck class.</p> <p>Parameters:</p> Name Type Description Default <code>trk_class</code> <code>str</code> <p>Truck class abbreviated name</p> required <code>k_factors</code> <code>Union[None, NumpyArray]</code> <p>If not None, gives an zone-by-zone array of k-factors\u2013additive impedances to be added on top of friciton factors. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>NumpyArray</code> <code>NumpyArray</code> <p>Zone-by-zone matrix of friction factors</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>def friction_factor_matrices(\n    self, trk_class: str, k_factors: Union[None, NumpyArray] = None\n) -&gt; NumpyArray:\n    \"\"\"Zone to zone NumpyArray of impedances for a given truck class.\n\n    Args:\n        trk_class (str): Truck class abbreviated name\n        k_factors (Union[None,NumpyArray]): If not None, gives an zone-by-zone array of\n            k-factors--additive impedances to be added on top of friciton factors.\n            Defaults to None.\n\n    Returns:\n        NumpyArray: Zone-by-zone matrix of friction factors\n    \"\"\"\n    if trk_class not in self._friction_factor_matrices.keys():\n        self._friction_factor_matrices[\n            trk_class\n        ] = self._calculate_friction_factor_matrix(\n            trk_class,\n            self.class_config[trk_class].impedance,\n            self.k_factors,\n            self.class_config[trk_class].use_k_factors,\n        )\n\n    return self._friction_factor_matrices[trk_class]\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTripDistribution.run","title":"<code>run(tripends_df)</code>","text":"<p>Run commercial vehicle trip distribution.</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>@LogStartEnd()\ndef run(self, tripends_df) -&gt; Dict[str, NumpyArray]:\n    \"\"\"Run commercial vehicle trip distribution.\"\"\"\n    daily_demand_dict = {\n        tc: self._distribute_ods(tripends_df, tc) for tc in self.component.classes\n    }\n\n    return daily_demand_dict\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTripDistribution.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate the inputs.</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate the inputs.\"\"\"\n    # TODO\n    pass\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTripGeneration","title":"<code>CommercialVehicleTripGeneration</code>","text":"<p>               Bases: <code>Subcomponent</code></p> <p>Commercial vehicle (truck) Trip Generation for 4 sizes of truck.</p> The four truck types are <p>(1) very small trucks (two-axle, four-tire), (2) small trucks (two-axle, six-tire), (3) medium trucks (three-axle), (4) large or combination (four or more axle) trucks.</p>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTripGeneration--trip-generation","title":"Trip generation","text":"<p>Use linear regression models to generate trip ends, balancing attractions to productions. Based on BAYCAST truck model.</p> <p>The truck trip generation models for small trucks (two-axle, six tire), medium trucks (three-axle), and large or combination (four or more axle) trucks are taken directly from the study: \u201cI-880 Intermodal Corridor Study: Truck Travel in the San Francisco Bay Area\u201d, prepared by Barton Aschman in December 1992.  The coefficients are on page 223 of this report.</p> <p>The very small truck generation model is based on the Phoenix four-tire truck model documented in the TMIP Quick Response Freight Manual.</p> <p>Note that certain production models previously used SIC-based employment categories.  To both maintain consistency with the BAYCAST truck model and update the model to use NAICS-based employment categories, new regression models were estimated relating the NAICS-based employment data with the SIC-based-predicted trips.  The goal here is not to create a new truck model, but to mimic the old model with the available data.  Please see the excel spreadsheet TruckModel.xlsx for details.  The NAICS-based model results replicate the SIC-based model results quite well.</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>class CommercialVehicleTripGeneration(Subcomponent):\n    \"\"\"Commercial vehicle (truck) Trip Generation for 4 sizes of truck.\n\n    The four truck types are:\n        (1) very small trucks (two-axle, four-tire),\n        (2) small trucks (two-axle, six-tire),\n        (3) medium trucks (three-axle),\n        (4) large or combination (four or more axle) trucks.\n\n    Input:  (1) MAZ csv data file with the employment and household counts.\n    Ouput:  Trips by 4 truck sizes\n\n    Trip generation\n    ---------------\n    Use linear regression models to generate trip ends,\n    balancing attractions to productions. Based on BAYCAST truck model.\n\n    The truck trip generation models for small trucks (two-axle, six tire),\n    medium trucks (three-axle), and large or combination (four or more axle)\n    trucks are taken directly from the study: \"I-880 Intermodal Corridor Study:\n    Truck Travel in the San Francisco Bay Area\", prepared by Barton Aschman in\n    December 1992.  The coefficients are on page 223 of this report.\n\n    The very small truck generation model is based on the Phoenix four-tire\n    truck model documented in the TMIP Quick Response Freight Manual.\n\n    Note that certain production models previously used SIC-based employment\n    categories.  To both maintain consistency with the BAYCAST truck model and\n    update the model to use NAICS-based employment categories, new regression\n    models were estimated relating the NAICS-based employment data with the\n    SIC-based-predicted trips.  The goal here is not to create a new truck\n    model, but to mimic the old model with the available data.  Please see\n    the excel spreadsheet TruckModel.xlsx for details.  The NAICS-based model\n    results replicate the SIC-based model results quite well.\n    \"\"\"\n\n    def __init__(self, controller: RunController, component: Component):\n        \"\"\"Constructor for the CommercialVehicleTripGeneration component.\n\n        Args:\n            controller (RunController): Run controller for model run.\n            component (Component): Parent component of sub-component\n        \"\"\"\n        super().__init__(controller, component)\n        self.config = self.component.config.trip_gen\n\n    def validate_inputs(self):\n        \"\"\"Validate the inputs.\"\"\"\n        # TODO\n        pass\n\n    @LogStartEnd()\n    def run(self):\n        \"\"\"Run commercial vehicle trip distribution.\"\"\"\n        _landuse_df = self._aggregate_landuse()\n        _unbalanced_tripends_df = self._generate_trip_ends(_landuse_df)\n        _balanced_tripends_df = self._balance_pa(_unbalanced_tripends_df)\n        total_tripends_df = self._aggregate_by_class(_balanced_tripends_df)\n        return total_tripends_df\n\n    @LogStartEnd(level=\"DEBUG\")\n    def _aggregate_landuse(self) -&gt; pd.DataFrame:\n        \"\"\"Aggregates landuse data from input CSV by MAZ to TAZ and employment groups.\n\n        TOTEMP, total employment (same regardless of classification system)\n        RETEMPN, retail trade employment per the NAICS classification system\n        FPSEMPN, financial and professional services employment per NAICS\n        HEREMPN, health, educational, and recreational employment per  NAICS\n        OTHEMPN, other employment per the NAICS classification system\n        AGREMPN, agricultural employment per the NAICS classificatin system\n        MWTEMPN, manufacturing, warehousing, and transportation employment per NAICS\n        TOTHH, total households\n        \"\"\"\n        maz_data_file = self.get_abs_path(\n            self.controller.config.scenario.maz_landuse_file\n        )\n        maz_input_data = pd.read_csv(maz_data_file)\n        zones = self.component.emme_scenario.zone_numbers\n        maz_input_data = maz_input_data[maz_input_data[\"TAZ_ORIGINAL\"].isin(zones)]\n        taz_input_data = maz_input_data.groupby([\"TAZ_ORIGINAL\"]).sum()\n        taz_input_data = taz_input_data.sort_values(by=\"TAZ_ORIGINAL\")\n        # combine categories\n        taz_landuse = pd.DataFrame()\n        for total_column, sub_categories in _land_use_aggregation.items():\n            taz_landuse[total_column] = taz_input_data[sub_categories].sum(axis=1)\n        taz_landuse.reset_index(inplace=True)\n        return taz_landuse\n\n    @LogStartEnd(level=\"DEBUG\")\n    def _generate_trip_ends(self, landuse_df: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Generate productions and attractions by class based on landuse and truck trip rates.\n\n        Args:\n            landuse_df (pd.DataFrame): DataFrame with aggregated landuse data.\n                Expected columns for landuse are: AGREMPN, RETEMPN, FPSEMPN, HEREMPN,\n                MWTEMPN, OTHEMPN, TOTEMP, TOTHH\n\n        Returns:\n            pd.DataFrame: DataFrame with unbalanced production and attraction trip ends.\n        \"\"\"\n        tripends_df = pd.DataFrame()\n\n        _class_pa = itertools.product(\n            self.config.classes,\n            [\"production_formula\", \"attraction_formula\"],\n        )\n\n        # TODO Do this with multi-indexing rather than relying on column naming\n\n        for _c, _pa in _class_pa:\n            _trip_type = _c.purpose\n            _trk_class = _c.name\n\n            if _pa.endswith(\"_formula\"):\n                _pa_short = _pa.split(\"_\")[0]\n\n            # linked trips (non-garage-based) - attractions (equal productions)\n            if (_trip_type == \"linked\") &amp; (_pa_short == \"attraction\"):\n                tripends_df[f\"{_trip_type}_{_trk_class}_{_pa_short}s\"] = tripends_df[\n                    f\"{_trip_type}_{_trk_class}_productions\"\n                ]\n            else:\n                _constant = _c[_pa].constant\n                _multiplier = _c[_pa].multiplier\n\n                land_use_rates = pd.DataFrame(_c[_pa].land_use_rates).T\n                land_use_rates = land_use_rates.rename(\n                    columns=land_use_rates.loc[\"property\"]\n                ).drop(\"property\", axis=0)\n\n                _rate_trips_df = landuse_df.mul(land_use_rates.iloc[0])\n                _trips_df = _rate_trips_df * _multiplier + _constant\n\n                # TODO fix this at the source\n                # at this point our data frame is completely object types (not numeric) \n                # it is a series of float objects not a float series\n                # for now we can call pd to_numeric but maybe fix at source if it causes errors\n                # update: this is because pandas 2.x is stricter about types\n                tripends_df[f\"{_trip_type}_{_trk_class}_{_pa_short}s\"] = pd.to_numeric(\n                    _trips_df.sum(axis=1)\n                ).round()\n\n        return tripends_df\n\n    @LogStartEnd(level=\"DEBUG\")\n    def _balance_pa(self, tripends_df: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Balance production and attractions.\n\n        Args:\n            tripends_df (pd.DataFrame): DataFrame with unbalanced production and attraction\n                trip ends.\n\n        Returns:\n            pd.DataFrame: DataFrame with balanced production and attraction trip ends.\n        \"\"\"\n\n        for _c in self.config.classes:\n            _trip_type = _c.purpose\n            _trk_class = _c.name\n            _balance_to = _c.balance_to\n\n            _tots = {\n                \"attractions\": tripends_df[\n                    f\"{_trip_type}_{_trk_class}_attractions\"\n                ].sum(),\n                \"productions\": tripends_df[\n                    f\"{_trip_type}_{_trk_class}_productions\"\n                ].sum(),\n            }\n\n            # if productions OR attractions are zero, fill one with other\n            if not _tots[\"attractions\"]:\n                tripends_df[f\"{_trip_type}_{_trk_class}_attractions\"] = tripends_df[\n                    f\"{_trip_type}_{_trk_class}_productions\"\n                ]\n\n            elif not _tots[\"productions\"]:\n                tripends_df[f\"{_trip_type}_{_trk_class}_productions\"] = tripends_df[\n                    f\"{_trip_type}_{_trk_class}_attractions\"\n                ]\n\n            # otherwise balance based on sums\n            elif _balance_to == \"productions\":\n                tripends_df[f\"{_trip_type}_{_trk_class}_attractions\"] = tripends_df[\n                    f\"{_trip_type}_{_trk_class}_attractions\"\n                ] * (_tots[\"productions\"] / _tots[\"attractions\"])\n\n            elif _balance_to == \"attractions\":\n                tripends_df[f\"{_trip_type}_{_trk_class}_productions\"] = tripends_df[\n                    f\"{_trip_type}_{_trk_class}_productions\"\n                ] * (_tots[\"attractions\"] / _tots[\"productions\"])\n            else:\n                raise ValueError(f\"{_balance_to} is not a valid balance_to value\")\n        return tripends_df\n\n    @LogStartEnd(level=\"DEBUG\")\n    def _aggregate_by_class(self, tripends_df: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Sum tripends by class across trip purpose.\n\n        Args:\n            tripends_df (pd.DataFrame): DataFrame with balanced production and attraction\n\n        Returns:\n            pd.DataFrame: DataFrame with aggregated tripends by truck class. Returned columns are:\n                vsmtrk_prod, vsmtrk_attr,\n                smltrk_prod, smltrk_attr,\n                medtrk_prod, medtrk_attr,\n                lrgtrk_prod, lrgtrk_attr\n        \"\"\"\n        agg_tripends_df = pd.DataFrame()\n\n        _class_pa = itertools.product(\n            self.component.classes,\n            [\"productions\", \"attractions\"],\n        )\n\n        for _trk_class, _pa in _class_pa:\n            _sum_cols = [\n                c for c in tripends_df.columns if c.endswith(f\"_{_trk_class}_{_pa}\")\n            ]\n            agg_tripends_df[f\"{_trk_class}_{_pa}\"] = pd.Series(\n                tripends_df[_sum_cols].sum(axis=1)\n            )\n\n        agg_tripends_df.round(decimals=7)\n\n        self.logger.log(agg_tripends_df.describe().to_string(), level=\"DEBUG\")\n\n        return agg_tripends_df\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTripGeneration.__init__","title":"<code>__init__(controller, component)</code>","text":"<p>Constructor for the CommercialVehicleTripGeneration component.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>Run controller for model run.</p> required <code>component</code> <code>Component</code> <p>Parent component of sub-component</p> required Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>def __init__(self, controller: RunController, component: Component):\n    \"\"\"Constructor for the CommercialVehicleTripGeneration component.\n\n    Args:\n        controller (RunController): Run controller for model run.\n        component (Component): Parent component of sub-component\n    \"\"\"\n    super().__init__(controller, component)\n    self.config = self.component.config.trip_gen\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTripGeneration.run","title":"<code>run()</code>","text":"<p>Run commercial vehicle trip distribution.</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>@LogStartEnd()\ndef run(self):\n    \"\"\"Run commercial vehicle trip distribution.\"\"\"\n    _landuse_df = self._aggregate_landuse()\n    _unbalanced_tripends_df = self._generate_trip_ends(_landuse_df)\n    _balanced_tripends_df = self._balance_pa(_unbalanced_tripends_df)\n    total_tripends_df = self._aggregate_by_class(_balanced_tripends_df)\n    return total_tripends_df\n</code></pre>"},{"location":"api/#tm2py.components.demand.commercial.CommercialVehicleTripGeneration.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate the inputs.</p> Source code in <code>tm2py/components/demand/commercial.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate the inputs.\"\"\"\n    # TODO\n    pass\n</code></pre>"},{"location":"api/#tm2py.config.TruckConfig.highway_demand_file","title":"<code>highway_demand_file: str</code>  <code>instance-attribute</code>","text":"<p>@validator(\u201cclasses\u201d) def class_consistency(cls, v, values):     # TODO Can\u2019t get to work righ tnow     _class_names = [c.name for c in v]     _gen_classes = [c.name for c in values[\u201ctrip_gen\u201d]]     _dist_classes = [c.name for c in values[\u201ctrip_dist\u201d]]     _time_classes = [c.name for c in values[\u201ctime_split\u201d]]     _toll_classes = [c.name for c in values[\u201ctoll_choice\u201d]]</p> <pre><code>assert (\n    _class_names == _gen_classes\n), \"truck.classes ({_class_names}) doesn't equal            class names in truck.trip_gen ({_gen_classes}).\"\nassert (\n    _class_names == _dist_classes\n), \"truck.classes ({_class_names}) doesn't  equal            class names in truck.trip_dist ({_dist_classes}).\"\nassert (\n    _class_names == _time_classes\n), \"truck.classes ({_class_names}) doesn't  equal            class names in truck.time_split ({_time_classes}).\"\nassert (\n    _class_names == _toll_classes\n), \"truck.classes ({_class_names}) doesn't equal            class names in truck.toll_choice ({_toll_classes}).\"\n\nreturn v\n</code></pre>"},{"location":"api/#inter-regional-demand","title":"Inter-regional Demand","text":"<p>Module containing Internal &lt;-&gt; External trip model.</p> <p>               Bases: <code>ConfigItem</code></p> <p>Internal &lt;-&gt; External model parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass InternalExternalConfig(ConfigItem):\n    \"\"\"Internal &lt;-&gt; External model parameters.\"\"\"\n\n    output_trip_table_directory: pathlib.Path\n    outfile_trip_table_tmp: str\n    highway_demand_file: str\n    modes: List[str]\n    demand: DemandGrowth\n    time_of_day: TimeOfDayConfig\n    toll_choice: TollChoiceConfig\n</code></pre>"},{"location":"api/#tm2py.components.demand.internal_external.ExternalDemand","title":"<code>ExternalDemand</code>","text":"<p>               Bases: <code>Subcomponent</code></p> <p>Forecast of daily internal&lt;-&gt;external demand based on growth from a base year.</p> <p>Create a daily matrix that includes internal/external, external/internal, and external/external passenger vehicle travel (based on Census 2000 journey-to-work flows). These trip tables are based on total traffic counts, which include trucks, but trucks are not explicitly segmented from passenger vehicles.  This short-coming is a hold-over from BAYCAST and will be addressed in the next model update.</p> <p>The row and column totals are taken from count station data provided by Caltrans.  The BAYCAST 2006 IX matrix is used as the base matrix and scaled to match forecast year growth assumptions. The script generates estimates for the model forecast year; the growth rates were discussed with neighboring MPOs as part of the SB 375 target setting process.</p> <p>Input:  (1)  Station-specific assumed growth rates for each forecast year (the lack of               external/external movements through the region allows simple factoring of               cells without re-balancing);          (2)  An input base matrix derived from the Census journey-to-work data.</p> <p>Output: (1) Four-table, forecast-year specific trip tables containing internal/external,              external/internal, and external/external vehicle (xxx or person xxx) travel.</p> <p>Governed by class DemandGrowth Config: <pre><code>    highway_demand_file:\n    input_demand_file:\n    input_demand_matrixname_tmpl:\n    modes:\n    reference_year:\n    annual_growth_rate:\n    special_gateway_adjust:\n</code></pre></p> Source code in <code>tm2py/components/demand/internal_external.py</code> <pre><code>class ExternalDemand(Subcomponent):\n    \"\"\"Forecast of daily internal&lt;-&gt;external demand based on growth from a base year.\n\n    Create a daily matrix that includes internal/external, external/internal,\n    and external/external passenger vehicle travel (based on Census 2000 journey-to-work flows).\n    These trip tables are based on total traffic counts, which include trucks, but trucks are\n    not explicitly segmented from passenger vehicles.  This short-coming is a hold-over from\n    BAYCAST and will be addressed in the next model update.\n\n    The row and column totals are taken from count station data provided by Caltrans.  The\n    BAYCAST 2006 IX matrix is used as the base matrix and scaled to match forecast year growth\n    assumptions. The script generates estimates for the model forecast year; the growth rates\n    were discussed with neighboring MPOs as part of the SB 375 target setting process.\n\n     Input:  (1)  Station-specific assumed growth rates for each forecast year (the lack of\n                  external/external movements through the region allows simple factoring of\n                  cells without re-balancing);\n             (2)  An input base matrix derived from the Census journey-to-work data.\n\n     Output: (1) Four-table, forecast-year specific trip tables containing internal/external,\n                 external/internal, and external/external vehicle (xxx or person xxx) travel.\n\n\n    Governed by class DemandGrowth Config:\n    ```\n        highway_demand_file:\n        input_demand_file:\n        input_demand_matrixname_tmpl:\n        modes:\n        reference_year:\n        annual_growth_rate:\n        special_gateway_adjust:\n    ```\n    \"\"\"\n\n    def __init__(self, controller, component):\n        super().__init__(controller, component)\n        self.config = self.component.config.demand\n        # Loaded lazily\n        self._base_demand = None\n\n    @property\n    def year(self):\n        return self.controller.config.scenario.year\n\n    @property\n    def modes(self):\n        return self.component.classes\n\n    @property\n    def input_demand_file(self):\n        return self.get_abs_path(self.config.input_demand_file)\n\n    @property\n    def base_demand(self):\n        if self._base_demand is None:\n            self._load_base_demand()\n        return self._base_demand\n\n    def validate_inputs(self):\n        # TODO\n        pass\n\n    def _load_base_demand(self):\n        \"\"\"Load reference matrices from .omx to self._base_demand\n\n        input file template: self.config.internal_external.input_demand_matrixname_tmpl\n        modes: self.config.internal_external.modes\n        \"\"\"\n        _mx_name_tmpl = self.config.input_demand_matrixname_tmpl\n        _matrices = {m: _mx_name_tmpl.format(mode=m.upper()) for m in self.modes}\n\n        self._base_demand = omx_to_dict(self.input_demand_file, matrices=_matrices)\n\n    def run(self, base_demand: Dict[str, NumpyArray] = None) -&gt; Dict[str, NumpyArray]:\n        \"\"\"Calculate adjusted demand based on scenario year and growth rates.\n\n        Steps:\n        - 1.1 apply special factors to certain gateways based on ID\n        - 1.2 apply gateway-specific annual growth rates to results of step 1\n           to generate year specific forecast\n\n        Args:\n            demand: dictionary of input daily demand matrices (numpy arrays)\n\n        Returns:\n             Dictionary of Numpy matrices of daily PA by class mode\n        \"\"\"\n        # Build adjustment matrix to be applied to all input matrices\n        # special gateway adjustments based on zone index\n        if base_demand is None:\n            base_demand = self.base_demand\n        _num_years = self.year - self.config.reference_year\n        _adj_matrix = np.ones(base_demand[\"da\"].shape)\n\n        _adj_matrix = create_matrix_factors(\n            default_matrix=_adj_matrix,\n            matrix_factors=self.config.special_gateway_adjust,\n        )\n\n        _adj_matrix = create_matrix_factors(\n            default_matrix=_adj_matrix,\n            matrix_factors=self.config.annual_growth_rate,\n            periods=_num_years,\n        )\n\n        daily_prod_attract = dict(\n            (_mode, _demand * _adj_matrix) for _mode, _demand in base_demand.items()\n        )\n        return daily_prod_attract\n</code></pre>"},{"location":"api/#tm2py.components.demand.internal_external.ExternalDemand.run","title":"<code>run(base_demand=None)</code>","text":"<p>Calculate adjusted demand based on scenario year and growth rates.</p> <p>Steps: - 1.1 apply special factors to certain gateways based on ID - 1.2 apply gateway-specific annual growth rates to results of step 1    to generate year specific forecast</p> <p>Parameters:</p> Name Type Description Default <code>demand</code> <p>dictionary of input daily demand matrices (numpy arrays)</p> required <p>Returns:</p> Type Description <code>Dict[str, NumpyArray]</code> <p>Dictionary of Numpy matrices of daily PA by class mode</p> Source code in <code>tm2py/components/demand/internal_external.py</code> <pre><code>def run(self, base_demand: Dict[str, NumpyArray] = None) -&gt; Dict[str, NumpyArray]:\n    \"\"\"Calculate adjusted demand based on scenario year and growth rates.\n\n    Steps:\n    - 1.1 apply special factors to certain gateways based on ID\n    - 1.2 apply gateway-specific annual growth rates to results of step 1\n       to generate year specific forecast\n\n    Args:\n        demand: dictionary of input daily demand matrices (numpy arrays)\n\n    Returns:\n         Dictionary of Numpy matrices of daily PA by class mode\n    \"\"\"\n    # Build adjustment matrix to be applied to all input matrices\n    # special gateway adjustments based on zone index\n    if base_demand is None:\n        base_demand = self.base_demand\n    _num_years = self.year - self.config.reference_year\n    _adj_matrix = np.ones(base_demand[\"da\"].shape)\n\n    _adj_matrix = create_matrix_factors(\n        default_matrix=_adj_matrix,\n        matrix_factors=self.config.special_gateway_adjust,\n    )\n\n    _adj_matrix = create_matrix_factors(\n        default_matrix=_adj_matrix,\n        matrix_factors=self.config.annual_growth_rate,\n        periods=_num_years,\n    )\n\n    daily_prod_attract = dict(\n        (_mode, _demand * _adj_matrix) for _mode, _demand in base_demand.items()\n    )\n    return daily_prod_attract\n</code></pre>"},{"location":"api/#tm2py.components.demand.internal_external.ExternalTollChoice","title":"<code>ExternalTollChoice</code>","text":"<p>               Bases: <code>Subcomponent</code></p>"},{"location":"api/#tm2py.components.demand.internal_external.ExternalTollChoice--toll-choice","title":"Toll choice","text":"<p>Apply a binomial choice model for drive alone, shared ride 2, and shared ride 3 internal/external personal vehicle travel.</p> (1) Time-period-specific origin/destination matrices of drive alone, shared ride 2, <p>and share ride 3+ internal/external trip tables.</p> <pre><code>    (2) Skims providing the time and cost for value toll and non-value toll paths for each\n\n        traffic_skims_{period}.omx, where {period} is the time period ID,\n        {class} is the class name da, sr2, sr2, with the following matrix names\n          Non-value-toll paying time: {period}_{class}_time,\n          Non-value-toll distance: {period}_{class}_dist,\n          Non-value-toll bridge toll is: {period}_{class}_bridgetoll_{class},\n          Value-toll paying time is: {period}_{class}toll_time,\n          Value-toll paying distance is: {period}_{class}toll_dist,\n          Value-toll bridge toll is: {period}_{class}toll_bridgetoll_{class},\n          Value-toll value toll is: {period}_{class}toll_valuetoll_{class},\n</code></pre> <p>Output: Five, six-table trip matrices, one for each time period.  Two tables for each vehicle          class representing value-toll paying path trips and non-value-toll paying path trips</p> <p>Governed by TollClassConfig:</p> <pre><code>```\nclasses:\nvalue_of_time:\noperating_cost_per_mile:\nproperty_to_skim_toll:\nproperty_to_skim_notoll:\nutility:\n```\n</code></pre> Source code in <code>tm2py/components/demand/internal_external.py</code> <pre><code>class ExternalTollChoice(Subcomponent):\n    \"\"\"Toll choice\n    -----------\n    Apply a binomial choice model for drive alone, shared ride 2, and shared ride 3\n    internal/external personal vehicle travel.\n\n    Input:  (1) Time-period-specific origin/destination matrices of drive alone, shared ride 2,\n                and share ride 3+ internal/external trip tables.\n            (2) Skims providing the time and cost for value toll and non-value toll paths for each\n\n                traffic_skims_{period}.omx, where {period} is the time period ID,\n                {class} is the class name da, sr2, sr2, with the following matrix names\n                  Non-value-toll paying time: {period}_{class}_time,\n                  Non-value-toll distance: {period}_{class}_dist,\n                  Non-value-toll bridge toll is: {period}_{class}_bridgetoll_{class},\n                  Value-toll paying time is: {period}_{class}toll_time,\n                  Value-toll paying distance is: {period}_{class}toll_dist,\n                  Value-toll bridge toll is: {period}_{class}toll_bridgetoll_{class},\n                  Value-toll value toll is: {period}_{class}toll_valuetoll_{class},\n\n     Output: Five, six-table trip matrices, one for each time period.  Two tables for each vehicle\n             class representing value-toll paying path trips and non-value-toll paying path trips\n\n    Governed by TollClassConfig:\n\n        ```\n        classes:\n        value_of_time:\n        operating_cost_per_mile:\n        property_to_skim_toll:\n        property_to_skim_notoll:\n        utility:\n        ```\n    \"\"\"\n\n    def __init__(self, controller, component):\n        super().__init__(controller, component)\n\n        self.config = self.component.config.toll_choice\n\n        self.sub_components = {\n            \"toll choice calculator\": TollChoiceCalculator(\n                controller, component, self.config\n            ),\n        }\n\n        # shortcut\n        self._toll_choice = self.sub_components[\"toll choice calculator\"]\n        self._toll_choice.toll_skim_suffix = \"trk\"\n\n    def validate_inputs(self):\n        # TODO\n        pass\n\n    @LogStartEnd()\n    def run(\n        self, period_demand: Dict[str, Dict[str, NumpyArray]]\n    ) -&gt; Dict[str, Dict[str, NumpyArray]]:\n        \"\"\"Binary toll / non-toll choice model by class.\n\n        input: result of _ix_time_of_day\n        skims:\n            traffic_skims_{period}.omx, where {period} is the time period ID,\n            {class} is the class name da, sr2, sr2, with the following matrix names\n              Non-value-toll paying time: {period}_{class}_time,\n              Non-value-toll distance: {period}_{class}_dist,\n              Non-value-toll bridge toll is: {period}_{class}_bridgetoll_{class},\n              Value-toll paying time is: {period}_{class}toll_time,\n              Value-toll paying distance is: {period}_{class}toll_dist,\n              Value-toll bridge toll is: {period}_{class}toll_bridgetoll_{class},\n              Value-toll value toll is: {period}_{class}toll_valuetoll_{class},\n\n        STEPS:\n        3.1: For each time of day, for each da, sr2, sr3, calculate\n             - utility of toll and nontoll\n             - probability of toll / nontoll\n             - split demand into toll and nontoll matrices\n\n        \"\"\"\n\n        _time_class_combos = itertools.product(\n            self.time_period_names, self.component.classes\n        )\n\n        class_demands = defaultdict(dict)\n        for _time_period, _class in _time_class_combos:\n            if _time_period in period_demand.keys():\n                None\n            elif _time_period.lower() in period_demand.keys():\n                _time_period = _time_period.lower()\n            elif _time_period.upper() in period_demand.keys():\n                _time_period = _time_period.upper()\n            else:\n                raise ValueError(\n                    f\"Period {_time_period} not an available time period.\\\n                    Available periods are:  {period_demand.keys()}\"\n                )\n\n            _split_demand = self._toll_choice.run(\n                period_demand[_time_period][_class], _class, _time_period\n            )\n\n            class_demands[_time_period][_class] = _split_demand[\"non toll\"]\n            class_demands[_time_period][f\"{_class}toll\"] = _split_demand[\"toll\"]\n        return class_demands\n</code></pre>"},{"location":"api/#tm2py.components.demand.internal_external.ExternalTollChoice.run","title":"<code>run(period_demand)</code>","text":"<p>Binary toll / non-toll choice model by class.</p> <p>input: result of ix_time_of_day skims:     traffic_skims{period}.omx, where {period} is the time period ID,     {class} is the class name da, sr2, sr2, with the following matrix names       Non-value-toll paying time: {period}{class}_time,       Non-value-toll distance: {period}{class}dist,       Non-value-toll bridge toll is: {period}{class}bridgetoll{class},       Value-toll paying time is: {period}{class}toll_time,       Value-toll paying distance is: {period}{class}toll_dist,       Value-toll bridge toll is: {period}{class}toll_bridgetoll{class},       Value-toll value toll is: {period}{class}toll_valuetoll{class},</p> <p>STEPS: 3.1: For each time of day, for each da, sr2, sr3, calculate      - utility of toll and nontoll      - probability of toll / nontoll      - split demand into toll and nontoll matrices</p> Source code in <code>tm2py/components/demand/internal_external.py</code> <pre><code>@LogStartEnd()\ndef run(\n    self, period_demand: Dict[str, Dict[str, NumpyArray]]\n) -&gt; Dict[str, Dict[str, NumpyArray]]:\n    \"\"\"Binary toll / non-toll choice model by class.\n\n    input: result of _ix_time_of_day\n    skims:\n        traffic_skims_{period}.omx, where {period} is the time period ID,\n        {class} is the class name da, sr2, sr2, with the following matrix names\n          Non-value-toll paying time: {period}_{class}_time,\n          Non-value-toll distance: {period}_{class}_dist,\n          Non-value-toll bridge toll is: {period}_{class}_bridgetoll_{class},\n          Value-toll paying time is: {period}_{class}toll_time,\n          Value-toll paying distance is: {period}_{class}toll_dist,\n          Value-toll bridge toll is: {period}_{class}toll_bridgetoll_{class},\n          Value-toll value toll is: {period}_{class}toll_valuetoll_{class},\n\n    STEPS:\n    3.1: For each time of day, for each da, sr2, sr3, calculate\n         - utility of toll and nontoll\n         - probability of toll / nontoll\n         - split demand into toll and nontoll matrices\n\n    \"\"\"\n\n    _time_class_combos = itertools.product(\n        self.time_period_names, self.component.classes\n    )\n\n    class_demands = defaultdict(dict)\n    for _time_period, _class in _time_class_combos:\n        if _time_period in period_demand.keys():\n            None\n        elif _time_period.lower() in period_demand.keys():\n            _time_period = _time_period.lower()\n        elif _time_period.upper() in period_demand.keys():\n            _time_period = _time_period.upper()\n        else:\n            raise ValueError(\n                f\"Period {_time_period} not an available time period.\\\n                Available periods are:  {period_demand.keys()}\"\n            )\n\n        _split_demand = self._toll_choice.run(\n            period_demand[_time_period][_class], _class, _time_period\n        )\n\n        class_demands[_time_period][_class] = _split_demand[\"non toll\"]\n        class_demands[_time_period][f\"{_class}toll\"] = _split_demand[\"toll\"]\n    return class_demands\n</code></pre>"},{"location":"api/#tm2py.components.demand.internal_external.InternalExternal","title":"<code>InternalExternal</code>","text":"<p>               Bases: <code>Component</code></p> <p>Develop Internal &lt;-&gt; External trip tables from land use and impedances.</p> <ol> <li>Grow demand from base year using static rates ::ExternalDemand</li> <li>Split by time of day using static factors ::TimePeriodSplit</li> <li>Apply basic toll binomial choice model: ::ExternalTollChoice</li> </ol> Governed by InternalExternalConfig Source code in <code>tm2py/components/demand/internal_external.py</code> <pre><code>class InternalExternal(Component):\n    \"\"\"Develop Internal &lt;-&gt; External trip tables from land use and impedances.\n\n    1. Grow demand from base year using static rates ::ExternalDemand\n    2. Split by time of day using static factors ::TimePeriodSplit\n    3. Apply basic toll binomial choice model: ::ExternalTollChoice\n\n    Governed by InternalExternalConfig:\n        highway_demand_file:\n        input_demand_file:\n        input_demand_matrixname_tmpl:\n        modes:\n        reference_year:\n        annual_growth_rate: List[MatrixFactorConfig]\n        time_of_day: TimeOfDayConfig\n        toll_choice: TollChoiceConfig\n        special_gateway_adjust: Optional[List[MatrixFactorConfig]]\n    \"\"\"\n\n    def __init__(self, controller: \"RunController\"):\n        super().__init__(controller)\n        self.config = self.controller.config.internal_external\n\n        self.sub_components = {\n            \"demand forecast\": ExternalDemand(controller, self),\n            \"time of day\": TimePeriodSplit(\n                controller, self, self.config.time_of_day.classes[0].time_period_split\n            ),\n            \"toll choice\": ExternalTollChoice(controller, self),\n        }\n\n    @property\n    def classes(self):\n        return self.config.modes\n\n    def validate_inputs(self):\n        \"\"\"Validate inputs to component.\"\"\"\n        ## TODO\n        pass\n\n    @LogStartEnd()\n    def run(self):\n        \"\"\"Run internal/external travel demand component.\"\"\"\n\n        daily_demand = self.sub_components[\"demand forecast\"].run()\n        period_demand = self.sub_components[\"time of day\"].run(daily_demand)\n        class_demands = self.sub_components[\"toll choice\"].run(period_demand)\n        self._export_results(class_demands)\n\n    @LogStartEnd()\n    def _export_results(self, demand: Dict[str, Dict[str, NumpyArray]]):\n        \"\"\"Export assignable class demands to OMX files by time-of-day.\"\"\"\n        outdir = self.get_abs_path(self.config.output_trip_table_directory)\n        os.makedirs(outdir, exist_ok=True)\n        for period, matrices in demand.items():\n            with OMXManager(\n                os.path.join(\n                    outdir, self.config.outfile_trip_table_tmp.format(period=period)\n                ),\n                \"w\",\n            ) as output_file:\n                for name, data in matrices.items():\n                    output_file.write_array(data, name)\n</code></pre>"},{"location":"api/#tm2py.components.demand.internal_external.InternalExternal.run","title":"<code>run()</code>","text":"<p>Run internal/external travel demand component.</p> Source code in <code>tm2py/components/demand/internal_external.py</code> <pre><code>@LogStartEnd()\ndef run(self):\n    \"\"\"Run internal/external travel demand component.\"\"\"\n\n    daily_demand = self.sub_components[\"demand forecast\"].run()\n    period_demand = self.sub_components[\"time of day\"].run(daily_demand)\n    class_demands = self.sub_components[\"toll choice\"].run(period_demand)\n    self._export_results(class_demands)\n</code></pre>"},{"location":"api/#tm2py.components.demand.internal_external.InternalExternal.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate inputs to component.</p> Source code in <code>tm2py/components/demand/internal_external.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate inputs to component.\"\"\"\n    ## TODO\n    pass\n</code></pre>"},{"location":"api/#visitor-demand","title":"Visitor Demand","text":"<p>Visitor module.</p>"},{"location":"api/#highway-network-components","title":"Highway Network Components","text":"<p>Module for highway network preparation steps.</p> <p>Creates required attributes and populates input values needed for highway assignments. The toll values, VDFs, per-class cost (tolls+operating costs), modes and skim link attributes are calculated.</p> The following link attributes are used as input <ul> <li>\u201c@capclass\u201d: link capclass index</li> <li>\u201clength\u201d: standard link length, in miles</li> <li>\u201c@tollbooth\u201d: label to separate bridgetolls from valuetolls</li> <li>\u201c@tollseg\u201d: toll segment, used to index toll value lookups from the toll file     (under config.highway.tolls.file_path)</li> <li>\u201c@ft\u201d: functional class, used to assign VDFs</li> </ul> The following keys and tables are used from the config <p>highway.tolls.file_path: relative path to input toll file highway.tolls.src_vehicle_group_names: names used in tolls file for     toll class values highway.tolls.dst_vehicle_group_names: corresponding names used in     network attributes toll classes highway.tolls.valuetoll_start_tollbooth_code: index to split point bridge tolls     (&lt; this value) from distance value tolls (&gt;= this value) highway.classes: the list of assignment classes, see the notes under     highway_assign for detailed explanation highway.capclass_lookup: the lookup table mapping the link @capclass setting     to capacity (@capacity), free_flow_speed (@free_flow_speec) and     critical_speed (used to calculate @ja for akcelik type functions) highway.generic_highway_mode_code: unique (with other mode_codes) single     character used to label entire auto network in Emme highway.maz_to_maz.mode_code: unique (with other mode_codes) single     character used to label MAZ local auto network including connectors</p> <p>The following link attributes are created (overwritten) and are subsequently used in the highway assignments.     - \u201c@flow_XX\u201d: link PCE flows per class, where XX is the class name in the config     - \u201c@maz_flow\u201d: Assigned MAZ-to-MAZ flow</p> The following attributes are calculated <ul> <li>vdf: volume delay function to use</li> <li>\u201c@capacity\u201d: total link capacity</li> <li>\u201c@ja\u201d: akcelik delay parameter</li> <li>\u201c@hov_length\u201d: length with HOV lanes</li> <li>\u201c@toll_length\u201d: length with tolls</li> <li>\u201c@bridgetoll_YY\u201d: the bridge toll for class subgroup YY</li> <li>\u201c@valuetoll_YY\u201d: the \u201cvalue\u201d, non-bridge toll for class subgroup YY</li> <li>\u201c@cost_YY\u201d: total cost for class YY</li> </ul> <p>Highway assignment and skim component.</p> <p>Performs equilibrium traffic assignment and generates resulting skims. The assignmend is configured using the \u201chighway\u201d table in the source config. See the config documentation for details. The traffic assignment runs according to the list of assignment classes under highway.classes.</p> <p>Other relevant parameters from the config are: - emme.num_processors: number of processors as integer or \u201cMAX\u201d or \u201cMAX-N\u201d - time_periods[].emme_scenario_id: Emme scenario number to use for each period - time_periods[].highway_capacity_factor</p> <p>The Emme network must have the following attributes available:</p> <p>Link - attributes: - \u201clength\u201d in feet - \u201cvdf\u201d, volume delay function (volume delay functions must also be setup) - \u201c@useclass\u201d, vehicle-class restrictions classification, auto-only, HOV only - \u201c@free_flow_time\u201d, the free flow time (in minutes) - \u201c@tollXX_YY\u201d, the toll for period XX and class subgroup (see truck     class) named YY, used together with @tollbooth to generate @bridgetoll_YY     and @valuetoll_YY - \u201c@maz_flow\u201d, the background traffic MAZ-to-MAZ SP assigned flow from highway_maz,     if controller.iteration &gt; 0 - modes: must be set on links and match the specified mode codes in     the traffic config</p> <p>Network results - attributes: - @flow_XX: link PCE flows per class, where XX is the class name in the config - timau: auto travel time - volau: total assigned flow in PCE</p> <p>Notes: - Output matrices are in miles, minutes, and cents (2010 dollars) and are stored/ as real values; - Intrazonal distance/time is one half the distance/time to the nearest neighbor; - Intrazonal bridge and value tolls are assumed to be zero</p> <p>               Bases: <code>ConfigItem</code></p> <p>Highway assignment and skims parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HighwayConfig(ConfigItem):\n    \"\"\"Highway assignment and skims parameters.\n\n    Properties:\n        generic_highway_mode_code: single character unique mode ID for entire\n            highway network (no excluded_links)\n        relative_gaps: relative gaps for assignment convergence, specific to global iteration, see HighwayRelativeGapConfig\n        max_iterations: maximum iterations stopping criteria\n        area_type_buffer_dist_miles: used to in calculation to categorize link @areatype\n            The area type is determined based on the average density of nearby\n            (within this buffer distance) MAZs, using (pop+jobs*2.5)/acres\n        drive_access_output_skim_path: relative path for drive access to transit skims\n        output_skim_path: relative path template from run dir for OMX output skims\n        output_skim_filename_tmpl: template for OMX filename for a time period. Must include\n            {time_period} in the string and end in '.omx'.\n        output_skim_matrixname_tmpl: template for matrix names within OMX output skims.\n            Should include {time_period}, {mode}, and {property}\n        tolls: input toll specification, see HighwayTollsConfig\n        maz_to_maz: maz-to-maz shortest path assignment and skim specification,\n            see HighwayMazToMazConfig\n        classes: highway assignment multi-class setup and skim specification,\n            see HighwayClassConfig\n        capclass_lookup: index cross-reference table from the link @capclass value\n            to the free-flow speed, capacity, and critical speed values\n        interchange_nodes_file: relative path to the interchange nodes file, this is\n            used for calculating highway reliability\n        apply_msa_demand: average highway demand with previous iterations'. Default to True.\n        reliability: bool to skim highway reliability. Default to true. If true, assignment\n            will be run twice in global iterations 0 (warmstart) and 1, to calculate reliability,\n            assignment will be run only once in global iterations 2 and 3,\n            reliability skim will stay the same as global iteration 1.\n            If false, reliability will not be calculated nor skimmed in all global\n            iterations, and the resulting reliability skims will be 0.\n    \"\"\"\n\n    generic_highway_mode_code: str = Field(min_length=1, max_length=1)\n    relative_gaps: Tuple[HighwayRelativeGapConfig, ...] = Field()\n    max_iterations: int = Field(ge=0)\n    network_acceleration: bool = Field()\n    area_type_buffer_dist_miles: float = Field(gt=0)\n    drive_access_output_skim_path: Optional[str] = Field(default=None)\n    output_skim_path: pathlib.Path = Field()\n    output_skim_filename_tmpl: str = Field()\n    output_skim_matrixname_tmpl: str = Field()\n    tolls: HighwayTollsConfig = Field()\n    maz_to_maz: HighwayMazToMazConfig = Field()\n    classes: Tuple[HighwayClassConfig, ...] = Field()\n    capclass_lookup: Tuple[HighwayCapClassConfig, ...] = Field()\n    interchange_nodes_file: str = Field()\n    apply_msa_demand: bool = True\n    reliability: bool = Field(default=True)\n\n    @validator(\"output_skim_filename_tmpl\")\n    def valid_skim_template(value):\n        \"\"\"Validate skim template has correct {} and extension.\"\"\"\n        assert (\n            \"{time_period\" in value\n        ), f\"-&gt; output_skim_filename_tmpl must have {{time_period}}', found {value}.\"\n        assert (\n            value[-4:].lower() == \".omx\"\n        ), f\"-&gt; 'output_skim_filename_tmpl must end in '.omx', found {value[-4:].lower() }\"\n        return value\n\n    @validator(\"output_skim_matrixname_tmpl\")\n    def valid_skim_matrix_name_template(value):\n        \"\"\"Validate skim matrix template has correct {}.\"\"\"\n        assert (\n            \"{time_period\" in value\n        ), \"-&gt; 'output_skim_matrixname_tmpl must have {time_period}, found {value}.\"\n        assert (\n            \"{property\" in value\n        ), \"-&gt; 'output_skim_matrixname_tmpl must have {property}, found {value}.\"\n        assert (\n            \"{mode\" in value\n        ), \"-&gt; 'output_skim_matrixname_tmpl must have {mode}, found {value}.\"\n        return value\n\n    @validator(\"capclass_lookup\")\n    def unique_capclass_numbers(cls, value):\n        \"\"\"Validate list of capclass_lookup has unique .capclass values.\"\"\"\n        capclass_ids = [i.capclass for i in value]\n        error_msg = \"-&gt; capclass value must be unique in list\"\n        assert len(capclass_ids) == len(set(capclass_ids)), error_msg\n        return value\n\n    @validator(\"classes\", pre=True)\n    def unique_class_names(cls, value):\n        \"\"\"Validate list of classes has unique .name values.\"\"\"\n        class_names = [highway_class[\"name\"] for highway_class in value]\n        error_msg = \"-&gt; name value must be unique in list\"\n        assert len(class_names) == len(set(class_names)), error_msg\n        return value\n\n    @validator(\"classes\")\n    def validate_class_mode_excluded_links(cls, value, values):\n        \"\"\"Validate list of classes has unique .mode_code or .excluded_links match.\"\"\"\n        # validate if any mode IDs are used twice, that they have the same excluded links sets\n        mode_excluded_links = {}\n        for i, highway_class in enumerate(value):\n            # maz_to_maz.mode_code must be unique\n            if \"maz_to_maz\" in values:\n                assert (\n                    highway_class[\"mode_code\"] != values[\"maz_to_maz\"][\"mode_code\"]\n                ), f\"-&gt; {i} -&gt; mode_code: cannot be the same as the highway.maz_to_maz.mode_code\"\n            # make sure that if any mode IDs are used twice, they have the same excluded links sets\n            if highway_class.mode_code in mode_excluded_links:\n                ex_links1 = highway_class[\"excluded_links\"]\n                ex_links2 = mode_excluded_links[highway_class[\"mode_code\"]]\n                error_msg = (\n                    f\"-&gt; {i}: duplicated mode codes ('{highway_class['mode_code']}') \"\n                    f\"with different excluded links: {ex_links1} and {ex_links2}\"\n                )\n                assert ex_links1 == ex_links2, error_msg\n            mode_excluded_links[highway_class.mode_code] = highway_class.excluded_links\n        return value\n\n    @validator(\"classes\")\n    def validate_class_keyword_lists(cls, value, values):\n        \"\"\"Validate classes .skims, .toll, and .excluded_links values.\"\"\"\n        if \"tolls\" not in values:\n            return value\n        avail_skims = [\n            \"time\",\n            \"dist\",\n            \"hovdist\",\n            \"tolldist\",\n            \"freeflowtime\",\n            \"rlbty\",\n            \"autotime\",\n        ]\n        available_link_sets = [\"is_sr\", \"is_sr2\", \"is_sr3\", \"is_auto_only\"]\n        avail_toll_attrs = []\n        for name in values[\"tolls\"].dst_vehicle_group_names:\n            toll_types = [f\"bridgetoll_{name}\", f\"valuetoll_{name}\"]\n            avail_skims.extend(toll_types)\n            avail_toll_attrs.extend([\"@\" + name for name in toll_types])\n            available_link_sets.append(f\"is_toll_{name}\")\n\n        # validate class skim name list and toll attribute against toll setup\n        def check_keywords(class_num, key, val, available):\n            extra_keys = set(val) - set(available)\n            error_msg = (\n                f\" -&gt; {class_num} -&gt; {key}: unrecognized {key} name(s): \"\n                f\"{','.join(extra_keys)}.  Available names are: {', '.join(available)}\"\n            )\n            assert not extra_keys, error_msg\n\n        for i, highway_class in enumerate(value):\n            check_keywords(i, \"skim\", highway_class[\"skims\"], avail_skims)\n            check_keywords(i, \"toll\", highway_class[\"toll\"], avail_toll_attrs)\n            check_keywords(\n                i,\n                \"excluded_links\",\n                highway_class[\"excluded_links\"],\n                available_link_sets,\n            )\n        return value\n</code></pre> <p>               Bases: <code>ConfigItem</code></p> <p>Highway assignment class definition.</p> <p>Note that excluded_links, skims and toll attribute names include vehicle groups (\u201c{vehicle}\u201d) which reference the list of highway.toll.dst_vehicle_group_names (see HighwayTollsConfig). The default example model config uses: \u201cda\u201d, \u201csr2\u201d, \u201csr3\u201d, \u201cvsm\u201d, sml\u201d, \u201cmed\u201d, \u201clrg\u201d</p> Example single class config <p>name = \u201cda\u201d description= \u201cdrive alone\u201d mode_code= \u201cd\u201d [[highway.classes.demand]]     source = \u201chousehold\u201d     name = \u201cSOV_GP_{period}\u201d [[highway.classes.demand]]     source = \u201cair_passenger\u201d     name = \u201cda\u201d [[highway.classes.demand]]     source = \u201cinternal_external\u201d     name = \u201cda\u201d excluded_links = [\u201cis_toll_da\u201d, \u201cis_sr2\u201d], value_of_time = 18.93,  # $ / hr operating_cost_per_mile = 17.23,  # cents / mile toll = [\u201c@bridgetoll_da\u201d] skims = [\u201ctime\u201d, \u201cdist\u201d, \u201cfreeflowtime\u201d, \u201cbridgetoll_da\u201d],</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HighwayClassConfig(ConfigItem):\n    \"\"\"Highway assignment class definition.\n\n    Note that excluded_links, skims and toll attribute names include\n    vehicle groups (\"{vehicle}\") which reference the list of\n    highway.toll.dst_vehicle_group_names (see HighwayTollsConfig).\n    The default example model config uses:\n    \"da\", \"sr2\", \"sr3\", \"vsm\", sml\", \"med\", \"lrg\"\n\n    Example single class config:\n        name = \"da\"\n        description= \"drive alone\"\n        mode_code= \"d\"\n        [[highway.classes.demand]]\n            source = \"household\"\n            name = \"SOV_GP_{period}\"\n        [[highway.classes.demand]]\n            source = \"air_passenger\"\n            name = \"da\"\n        [[highway.classes.demand]]\n            source = \"internal_external\"\n            name = \"da\"\n        excluded_links = [\"is_toll_da\", \"is_sr2\"],\n        value_of_time = 18.93,  # $ / hr\n        operating_cost_per_mile = 17.23,  # cents / mile\n        toll = [\"@bridgetoll_da\"]\n        skims = [\"time\", \"dist\", \"freeflowtime\", \"bridgetoll_da\"],\n\n    Properties:\n        name: short (up to 10 character) unique reference name for the class.\n            used in attribute and matrix names\n        description: longer text used in attribute and matrix descriptions\n        mode_code: single character mode, used to generate link.modes to\n            identify subnetwork, generated from \"excluded_links\" keywords.\n            Should be unique in list of :es, unless multiple classes\n            have identical excluded_links specification. Cannot be the\n            same as used for highway.maz_to_maz.mode_code.\n        value_of_time: value of time for this class in $ / hr\n        operating_cost_per_mile: vehicle operating cost in cents / mile\n        demand: list of OMX file and matrix keyname references,\n            see ClassDemandConfig\n        excluded_links: list of keywords to identify links to exclude from\n            this class' available subnetwork (generate link.modes)\n            Options are:\n                - \"is_sr\": is reserved for shared ride (@useclass in 2,3)\n                - \"is_sr2\": is reserved for shared ride 2+ (@useclass == 2)\n                - \"is_sr3\": is reserved for shared ride 3+ (@useclass == 3)\n                - \"is_auto_only\": is reserved for autos (non-truck) (@useclass != 1)\n                - \"is_toll_{vehicle}\": has a value (non-bridge) toll for the {vehicle} toll group\n        toll: list of additional toll cost link attribute (values stored in cents),\n            summed, one of \"@bridgetoll_{vehicle}\", \"@valuetoll_{vehicle}\"\n        toll_factor: optional, factor to apply to toll values in cost calculation\n        pce: optional, passenger car equivalent to convert assigned demand in\n            PCE units to vehicles for total assigned vehicle calculations\n        skims: list of skim matrices to generate\n            Options are:\n                \"time\": pure travel time in minutes\n                \"dist\": distance in miles\n                \"hovdist\": distance on HOV facilities (is_sr2 or is_sr3)\n                \"tolldist\": distance on toll facilities\n                    (@tollbooth &gt; highway.tolls.valuetoll_start_tollbooth_code)\n                \"freeflowtime\": free flow travel time in minutes\n                \"bridgetoll_{vehicle}\": bridge tolls, {vehicle} refers to toll group\n                \"valuetoll_{vehicle}\": other, non-bridge tolls, {vehicle} refers to toll group\n    \"\"\"\n\n    name: str = Field(min_length=1, max_length=10)\n    veh_group_name: str = Field(min_length=1, max_length=10)\n    description: Optional[str] = Field(default=\"\")\n    mode_code: str = Field(min_length=1, max_length=1)\n    value_of_time: float = Field(gt=0)\n    operating_cost_per_mile: float = Field(ge=0)\n    pce: Optional[float] = Field(default=1.0, gt=0)\n    # Note that excluded_links, skims, and tolls validated under HighwayConfig to include\n    # highway.toll.dst_vehicle_group_names names\n    excluded_links: Tuple[str, ...] = Field()\n    skims: Tuple[str, ...] = Field()\n    toll: Tuple[str, ...] = Field()\n    toll_factor: Optional[float] = Field(default=None, gt=0)\n    demand: Tuple[ClassDemandConfig, ...] = Field()\n</code></pre> <p>               Bases: <code>ConfigItem</code></p> <p>Highway assignment and skim input tolls and related parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HighwayTollsConfig(ConfigItem):\n    \"\"\"Highway assignment and skim input tolls and related parameters.\n\n    Properties:\n        file_path: source relative file path for the highway tolls index CSV\n        valuetoll_start_tollbooth_code: tollbooth separates links with \"bridge\" tolls\n            (index &lt; this value) vs. \"value\" tolls. These toll attributes\n            can then be referenced separately in the highway.classes[].tolls\n            list\n        src_vehicle_group_names: name used for the vehicle toll CSV column IDs,\n            of the form \"toll{period}_{vehicle}\"\n        dst_vehicle_group_names: list of names used in destination network\n            for the corresponding vehicle group. Length of list must be the same\n            as src_vehicle_group_names. Used for toll related attributes and\n            resulting skim matrices. Cross-referenced in list of highway.classes[],\n            valid keywords for:\n                excluded_links: \"is_toll_{vehicle}\"\n                tolls: \"@bridgetoll_{vehicle}\", \"@valuetoll_{vehicle}\"\n                skims: \"bridgetoll_{vehicle}\", \"valuetoll_{vehicle}\"\n    \"\"\"\n\n    file_path: pathlib.Path = Field()\n    valuetoll_start_tollbooth_code: int = Field(gt=1)\n    src_vehicle_group_names: Tuple[str, ...] = Field()\n    dst_vehicle_group_names: Tuple[str, ...] = Field()\n\n    @validator(\"dst_vehicle_group_names\", always=True)\n    def dst_vehicle_group_names_length(cls, value, values):\n        \"\"\"Validate dst_vehicle_group_names has same length as src_vehicle_group_names.\"\"\"\n        if \"src_vehicle_group_names\" in values:\n            assert len(value) == len(\n                values[\"src_vehicle_group_names\"]\n            ), \"dst_vehicle_group_names must be same length as src_vehicle_group_names\"\n            assert all(\n                [len(v) &lt;= 4 for v in value]\n            ), \"dst_vehicle_group_names must be 4 characters or less\"\n        return value\n</code></pre> <p>               Bases: <code>ConfigItem</code></p> <p>Grouping of counties for assignment and demand files.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass DemandCountyGroupConfig(ConfigItem):\n    \"\"\"Grouping of counties for assignment and demand files.\n\n    Properties:\n        number: id number for this group, must be unique\n        counties: list of one or more county names\n    \"\"\"\n\n    number: int = Field()\n    counties: Tuple[COUNTY_NAMES, ...] = Field()\n</code></pre> <p>Assigns and skims MAZ-to-MAZ demand along shortest generalized cost path.</p> <p>MAZ to MAZ demand is read in from separate OMX matrices as defined under the config table highway.maz_to_maz.demand_county_groups,</p> <p>The demand is expected to be short distance (e.g. &lt;0.5 miles), or within the same TAZ. The demand is grouped into bins of origin -&gt; all destinations, by distance (straight-line) to furthest destination. This limits the size of the shortest path calculated to the minimum required. The bin edges have been predefined after testing as (in miles):     [0.0, 0.9, 1.2, 1.8, 2.5, 5.0, 10.0, max_dist]</p> <p>Input: Emme network with:     Link attributes:         - time attribute, either timau (resulting VDF congested time)           or @free_flow_time     Node attributes: @maz_id, x, y, and #node_county Demand matrices under highway.maz_to_maz.demand_file, and can have a placeholder     auto_{period}MAZ_AUTO{number}_{period}.omx</p> <p>Output: The resulting MAZ-MAZ flows are saved in link @maz_flow which is used as background traffic in the equilibrium Highway assignment.</p> <p>               Bases: <code>ConfigItem</code></p> <p>Highway MAZ to MAZ shortest path assignment and skim parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HighwayMazToMazConfig(ConfigItem):\n    \"\"\"Highway MAZ to MAZ shortest path assignment and skim parameters.\n\n    Properties:\n        mode_code: single character mode, used to generate link.modes to\n            identify subnetwork, generated from \"excluded_links\" keywords,\n            plus including MAZ connectors.\n        value_of_time: value of time for this class in $ / hr\n        operating_cost_per_mile: vehicle operating cost in cents / mile\n        max_skim_cost: max shortest path distance to search for MAZ-to-MAZ\n            skims, in generized costs units (includes operating cost\n            converted to minutes)\n        excluded_links: list of keywords to identify links to exclude from\n            MAZ-to-MAZ paths, see HighwayClassConfig.excluded_links\n        demand_file: relative path to find the input demand files\n            can have use a placeholder for {period} and {number}, where the\n            {period} is the time_period.name (see TimePeriodConfig)\n            and {number} is the demand_count_groups[].number\n            (see DemandCountyGroupConfig)\n            e.g.: auto_{period}_MAZ_AUTO_{number}_{period}.omx\n        demand_county_groups: List of demand county names and\n        skim_period: period name to use for the shotest path skims, must\n            match one of the names listed in the time_periods\n        output_skim_file: relative path to resulting MAZ-to-MAZ skims\n    \"\"\"\n\n    mode_code: str = Field(min_length=1, max_length=1)\n    value_of_time: float = Field(gt=0)\n    operating_cost_per_mile: float = Field(ge=0)\n    max_distance: float = Field(gt=0)\n    max_skim_cost: float = Field(gt=0)\n    excluded_links: Tuple[str, ...] = Field()\n    demand_file: pathlib.Path = Field()\n    demand_county_groups: Tuple[DemandCountyGroupConfig, ...] = Field()\n    skim_period: str = Field()\n    output_skim_file: pathlib.Path = Field()\n\n    @validator(\"demand_county_groups\")\n    def unique_group_numbers(cls, value):\n        \"\"\"Validate list of demand_county_groups has unique .number values.\"\"\"\n        group_ids = [group.number for group in value]\n        assert len(group_ids) == len(set(group_ids)), \"-&gt; number value must be unique\"\n        return value\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_network.PrepareNetwork","title":"<code>PrepareNetwork</code>","text":"<p>               Bases: <code>Component</code></p> <p>Highway network preparation.</p> Source code in <code>tm2py/components/network/highway/highway_network.py</code> <pre><code>class PrepareNetwork(Component):\n    \"\"\"Highway network preparation.\"\"\"\n\n    def __init__(self, controller: \"RunController\"):\n        \"\"\"Constructor for PPrepareNetwork.\n\n        Args:\n            controller (RunController): Reference to run controller object.\n        \"\"\"\n        super().__init__(controller)\n        self.config = self.controller.config.highway\n        self._emme_manager = self.controller.emme_manager\n        self._highway_emmebank = None\n        self._highway_scenarios = None\n\n    @LogStartEnd(\"Prepare network attributes and modes\")\n    def run(self):\n        \"\"\"Run network preparation step.\"\"\"\n        for time in self.time_period_names:\n            with self.controller.emme_manager.logbook_trace(\n                f\"prepare for highway assignment {time}\"\n            ):\n                scenario = self.highway_emmebank.scenario(time)\n                self._create_class_attributes(scenario, time)\n                network = scenario.get_network()\n                self._set_tolls(network, time)\n                self._set_vdf_attributes(network, time)\n                self._set_link_modes(network)\n                self._calc_link_skim_lengths(network)\n                self._calc_link_class_costs(network)\n                self._calc_interchange_distance(network)\n                self._calc_link_static_reliability(network)\n                scenario.publish_network(network)\n\n    @property\n    def highway_emmebank(self):\n        if not self._highway_emmebank:\n            self._highway_emmebank = self.controller.emme_manager.highway_emmebank\n        return self._highway_emmebank\n\n    @property\n    def highway_scenarios(self):\n        if self._highway_scenarios is None:\n            self._highway_scenarios = {\n                tp: self.highway_emmebank.scenario(tp) for tp in self.time_period_names\n            }\n        return self._highway_scenarios\n\n    def validate_inputs(self):\n        \"\"\"Validate inputs files are correct, raise if an error is found.\"\"\"\n        toll_file_path = self.get_abs_path(self.config.tolls.file_path)\n        if not os.path.exists(toll_file_path):\n            self.logger.log(\n                f\"Tolls file (config.highway.tolls.file_path) does not exist: {toll_file_path}\",\n                level=\"ERROR\",\n            )\n            raise FileNotFoundError(f\"Tolls file does not exist: {toll_file_path}\")\n        src_veh_groups = self.config.tolls.src_vehicle_group_names\n        columns = [\"fac_index\"]\n        for time in self.controller.config.time_periods:\n            for vehicle in src_veh_groups:\n                columns.append(f\"toll{time.name.lower()}_{vehicle}\")\n        with open(toll_file_path, \"r\", encoding=\"UTF8\") as toll_file:\n            header = set(h.strip() for h in next(toll_file).split(\",\"))\n            missing = []\n            for column in columns:\n                if column not in header:\n                    missing.append(column)\n                    self.logger.log(\n                        f\"Tolls file missing column: {column}\", level=\"ERROR\"\n                    )\n        if missing:\n            raise FileFormatError(\n                f\"Tolls file missing {len(missing)} columns: {', '.join(missing)}\"\n            )\n\n    def _create_class_attributes(self, scenario: EmmeScenario, time_period: str):\n        \"\"\"Create required network attributes including per-class cost and flow attributes.\"\"\"\n        create_attribute = self.controller.emme_manager.tool(\n            \"inro.emme.data.extra_attribute.create_extra_attribute\"\n        )\n        attributes = {\n            \"LINK\": [\n                (\"@capacity\", \"total link capacity\"),\n                (\"@ja\", \"akcelik delay parameter\"),\n                (\"@maz_flow\", \"Assigned MAZ-to-MAZ flow\"),\n                (\"@hov_length\", \"length with HOV lanes\"),\n                (\"@toll_length\", \"length with tolls\"),\n                (\"@intdist_down\", \"dist to the closest d-stream interchange\"),\n                (\"@intdist_up\", \"dist from the closest upstream int\"),\n                (\"@static_rel\", \"static reliability\"),\n                (\"@reliability\", \"link total reliability\"),\n                (\"@reliability_sq\", \"link total reliability variance\"),\n                (\"@auto_time\", \"link total reliability\"),\n            ],\n            \"NODE\": [\n                (\"@interchange\", \"interchange\"),\n            ],\n        }\n        # toll field attributes by bridge and value and toll definition\n        dst_veh_groups = self.config.tolls.dst_vehicle_group_names\n        for dst_veh in dst_veh_groups:\n            for toll_type in \"bridge\", \"value\":\n                attributes[\"LINK\"].append(\n                    (\n                        f\"@{toll_type}toll_{dst_veh}\",\n                        f\"{toll_type} toll value for {dst_veh}\",\n                    )\n                )\n        # results for link cost and assigned flow\n        for assign_class in self.config.classes:\n            attributes[\"LINK\"].append(\n                (\n                    f\"@cost_{assign_class.name.lower()}\",\n                    f'{time_period} {assign_class[\"description\"]} total costs'[:40],\n                )\n            )\n            attributes[\"LINK\"].append(\n                (\n                    f\"@flow_{assign_class.name.lower()}\",\n                    f'{time_period} {assign_class[\"description\"]} link volume'[:40],\n                )\n            )\n        for domain, attrs in attributes.items():\n            for name, desc in attrs:\n                create_attribute(domain, name, desc, overwrite=True, scenario=scenario)\n\n    def _set_tolls(self, network: EmmeNetwork, time_period: str):\n        \"\"\"Set the tolls in the network from the toll reference file.\"\"\"\n        toll_index = self._get_toll_indices()\n        src_veh_groups = self.config.tolls.src_vehicle_group_names\n        dst_veh_groups = self.config.tolls.dst_vehicle_group_names\n        valuetoll_start_tollbooth_code = (\n            self.config.tolls.valuetoll_start_tollbooth_code\n        )\n        for link in network.links():\n            # set bridgetoll\n            if (\n                link[\"@tollbooth\"] &gt; 0\n                and link[\"@tollbooth\"] &lt; valuetoll_start_tollbooth_code\n            ):\n                index = int(\n                    link[\"@tollbooth\"] * 1000\n                    + link[\"@tollseg\"] * 10\n                    + link[\"@useclass\"]\n                )\n                data_row = toll_index.get(index)\n                if data_row is None:\n                    self.logger.warn(\n                        f\"set tolls failed index lookup {index}, link {link.id}\",\n                        indent=True,\n                    )\n                    continue  # tolls will remain at zero\n                for src_veh, dst_veh in zip(src_veh_groups, dst_veh_groups):\n                    link[f\"@bridgetoll_{dst_veh}\"] = (\n                        float(data_row[f\"toll{time_period.lower()}_{src_veh}\"]) * 100\n                    )\n            # set valuetoll\n            elif link[\"@tollbooth\"] &gt;= valuetoll_start_tollbooth_code:\n                data_row = toll_index.get(index)\n                if data_row is None:\n                    self.logger.warn(\n                        f\"set tolls failed index lookup {index}, link {link.id}\",\n                        indent=True,\n                    )\n                    continue  # tolls will remain at zero\n                for src_veh, dst_veh in zip(src_veh_groups, dst_veh_groups):\n                    link[f\"@valuetoll_{dst_veh}\"] = (\n                        float(data_row[f\"toll{time_period.lower()}_{src_veh}\"])\n                        * link.length\n                        * 100\n                    )\n            else:\n                continue\n\n    def _get_toll_indices(self) -&gt; Dict[int, Dict[str, str]]:\n        \"\"\"Get the mapping of toll lookup table from the toll reference file.\"\"\"\n        toll_file_path = self.get_abs_path(self.config.tolls.file_path)\n        self.logger.debug(f\"toll_file_path {toll_file_path}\", indent=True)\n        tolls = {}\n        with open(toll_file_path, \"r\", encoding=\"UTF8\") as toll_file:\n            header = [h.strip() for h in next(toll_file).split(\",\")]\n            for line in toll_file:\n                data = dict(zip(header, line.split(\",\")))\n                tolls[int(data[\"fac_index\"])] = data\n        return tolls\n\n    def _set_vdf_attributes(self, network: EmmeNetwork, time_period: str):\n        \"\"\"Set capacity, VDF and critical speed on links.\"\"\"\n        capacity_map = {}\n        critical_speed_map = {}\n        for row in self.config.capclass_lookup:\n            if row.get(\"capacity\") is not None:\n                capacity_map[row[\"capclass\"]] = row.get(\"capacity\")\n            if row.get(\"critical_speed\") is not None:\n                critical_speed_map[row[\"capclass\"]] = row.get(\"critical_speed\")\n        tp_mapping = {\n            tp.name.upper(): tp.highway_capacity_factor\n            for tp in self.controller.config.time_periods\n        }\n        period_capacity_factor = tp_mapping[time_period]\n        akcelik_vdfs = [3, 4, 5, 7, 8, 10, 11, 12, 13, 14]\n        for link in network.links():\n            cap_lanehour = capacity_map[link[\"@capclass\"]]\n            link[\"@capacity\"] = cap_lanehour * period_capacity_factor * link[\"@lanes\"]\n            link.volume_delay_func = int(link[\"@ft\"])\n            # re-mapping links with type 99 to type 7 \"local road of minor importance\"\n            if link.volume_delay_func == 99:\n                link.volume_delay_func = 7\n            # num_lanes not used directly, but set for reference\n            link.num_lanes = max(min(9.9, link[\"@lanes\"]), 1.0)\n            if link.volume_delay_func in akcelik_vdfs and link[\"@free_flow_speed\"] &gt; 0:\n                dist = link.length\n                critical_speed = critical_speed_map[link[\"@capclass\"]]\n                t_c = dist / critical_speed\n                t_o = dist / link[\"@free_flow_speed\"]\n                link[\"@ja\"] = 16 * (t_c - t_o) ** 2\n\n    def _set_link_modes(self, network: EmmeNetwork):\n        \"\"\"Set the link modes based on the per-class 'excluded_links' set.\"\"\"\n        # first reset link modes (script run more than once)\n        # \"generic_highway_mode_code\" must already be created (in import to Emme script)\n        auto_mode = {network.mode(self.config.generic_highway_mode_code)}\n        used_modes = {\n            network.mode(assign_class.mode_code) for assign_class in self.config.classes\n        }\n        used_modes.add(network.mode(self.config.maz_to_maz.mode_code))\n        for link in network.links():\n            link.modes -= used_modes\n            if link[\"@drive_link\"]:\n                link.modes |= auto_mode\n        for mode in used_modes:\n            if mode is not None:\n                network.delete_mode(mode)\n\n        # Create special access/egress mode for MAZ connectors\n        maz_access_mode = network.create_mode(\n            \"AUX_AUTO\", self.config.maz_to_maz.mode_code\n        )\n        maz_access_mode.description = \"MAZ access\"\n        # create modes from class spec\n        # (duplicate mode codes allowed provided the excluded_links is the same)\n        mode_excluded_links = {}\n        for assign_class in self.config.classes:\n            if assign_class.mode_code in mode_excluded_links:\n                if (\n                    assign_class.excluded_links\n                    != mode_excluded_links[assign_class.mode_code]\n                ):\n                    ex_links1 = mode_excluded_links[assign_class.mode_code]\n                    ex_links2 = assign_class.excluded_links\n                    raise Exception(\n                        f\"config error: highway.classes, duplicated mode codes \"\n                        f\"('{assign_class.mode_code}') with different excluded \"\n                        f\"links: {ex_links1} and {ex_links2}\"\n                    )\n                continue\n            mode = network.create_mode(\"AUX_AUTO\", assign_class.mode_code)\n            mode.description = assign_class.name\n            mode_excluded_links[mode.id] = assign_class.excluded_links\n\n        dst_veh_groups = self.config.tolls.dst_vehicle_group_names\n        for link in network.links():\n            modes = set(m.id for m in link.modes)\n            if link.i_node[\"@maz_id\"] + link.j_node[\"@maz_id\"] &gt; 0:\n                modes.add(maz_access_mode.id)\n                link.modes = modes\n                continue\n            if not link[\"@drive_link\"]:\n                continue\n            exclude_links_map = {\n                \"is_sr\": link[\"@useclass\"] in [2, 3],\n                \"is_sr2\": link[\"@useclass\"] == 2,\n                \"is_sr3\": link[\"@useclass\"] == 3,\n                \"is_auto_only\": link[\"@useclass\"] in [2, 3, 4],\n            }\n            for dst_veh in dst_veh_groups:\n                exclude_links_map[f\"is_toll_{dst_veh}\"] = (\n                    link[f\"@valuetoll_{dst_veh}\"] &gt; 0\n                )\n            self._apply_exclusions(\n                self.config.maz_to_maz.excluded_links,\n                maz_access_mode.id,\n                modes,\n                exclude_links_map,\n            )\n            for assign_class in self.config.classes:\n                self._apply_exclusions(\n                    assign_class.excluded_links,\n                    assign_class.mode_code,\n                    modes,\n                    exclude_links_map,\n                )\n            link.modes = modes\n\n    @staticmethod\n    def _apply_exclusions(\n        excluded_links_criteria: List[str],\n        mode_code: str,\n        modes_set: Set[str],\n        link_values: Dict[str, bool],\n    ):\n        \"\"\"Apply the exclusion criteria to set the link modes.\"\"\"\n        for criteria in excluded_links_criteria:\n            if link_values[criteria]:\n                return\n        modes_set.add(mode_code)\n\n    def _calc_link_skim_lengths(self, network: EmmeNetwork):\n        \"\"\"Calculate the length attributes used in the highway skims.\"\"\"\n        valuetoll_start_tollbooth_code = (\n            self.config.tolls.valuetoll_start_tollbooth_code\n        )\n        for link in network.links():\n            # distance in hov lanes / facilities\n            if 2 &lt;= link[\"@useclass\"] &lt;= 3:\n                link[\"@hov_length\"] = link.length\n            else:\n                link[\"@hov_length\"] = 0\n            # distance on non-bridge toll facilities\n            if link[\"@tollbooth\"] &gt; valuetoll_start_tollbooth_code:\n                link[\"@toll_length\"] = link.length\n            else:\n                link[\"@toll_length\"] = 0\n\n    def _calc_link_class_costs(self, network: EmmeNetwork):\n        \"\"\"Calculate the per-class link cost from the tolls and operating costs.\"\"\"\n        for assign_class in self.config.classes:\n            cost_attr = f\"@cost_{assign_class.name.lower()}\"\n            op_cost = assign_class[\"operating_cost_per_mile\"]\n            toll_factor = assign_class.get(\"toll_factor\")\n            if toll_factor is None:\n                toll_factor = 1.0\n            for link in network.links():\n                try:\n                    toll_value = sum(\n                        link[toll_attr] for toll_attr in assign_class[\"toll\"]\n                    )\n                except:\n                    link\n                link[cost_attr] = link.length * op_cost + toll_value * toll_factor\n\n    def _calc_interchange_distance(self, network: EmmeNetwork):\n        \"\"\"\n        For highway reliability\n        Calculate upstream and downstream interchange distance\n        First, label the intersection nodes as nodes with freeway and freeway-to-freeway ramp\n        \"\"\"\n        # input interchange nodes file\n        # This is a file inherited from https://app.box.com/folder/148342877307, as implemented in the tm2.1\n        interchange_nodes_file = self.get_abs_path(self.config.interchange_nodes_file)\n        interchange_nodes_df = pd.read_csv(interchange_nodes_file)\n        interchange_nodes_df = interchange_nodes_df[interchange_nodes_df.intx &gt; 0]\n        interchange_points = interchange_nodes_df[\"N\"].tolist()\n        network.create_attribute(\"NODE\", \"is_interchange\")\n        for node in network.nodes():\n            if node[\"#node_id\"] in interchange_points:\n                node.is_interchange = True\n                node[\"@interchange\"] = node.is_interchange\n\n        mode_c = network.mode(\"c\")\n        for link in network.links():\n            if link[\"@ft\"] in [1, 2] and mode_c in link.modes:\n                link[\"@intdist_down\"] = PrepareNetwork.interchange_distance(\n                    link, \"DOWNSTREAM\"\n                )\n                link[\"@intdist_up\"] = PrepareNetwork.interchange_distance(\n                    link, \"UPSTREAM\"\n                )\n\n        network.delete_attribute(\"NODE\", \"is_interchange\")\n\n    @staticmethod\n    def interchange_distance(orig_link, direction):\n        visited = set([])\n        visited_add = visited.add\n        back_links = {}\n        heap = []\n        if direction == \"DOWNSTREAM\":\n            get_links = lambda l: l.j_node.outgoing_links()\n            check_far_node = lambda l: l.j_node.is_interchange\n        elif direction == \"UPSTREAM\":\n            get_links = lambda l: l.i_node.incoming_links()\n            check_far_node = lambda l: l.i_node.is_interchange\n        # Shortest path search for nearest interchange node along freeway\n        for link in get_links(orig_link):\n            _heapq.heappush(heap, (link[\"length\"], link[\"#link_id\"], link))\n        interchange_found = False\n\n        # Check first node\n        if check_far_node(orig_link):\n            interchange_found = True\n            link_cost = 0.0\n\n        try:\n            while not interchange_found:\n                link_cost, link_id, link = _heapq.heappop(heap)\n                if link in visited:\n                    continue\n                visited_add(link)\n                if check_far_node(link):\n                    interchange_found = True\n                    break\n                get_links_return = get_links(link)\n                for next_link in get_links_return:\n                    if next_link in visited:\n                        continue\n                    next_cost = link_cost + next_link[\"length\"]\n                    _heapq.heappush(heap, (next_cost, next_link[\"#link_id\"], next_link))\n        except TypeError:\n            # TypeError if the link type objects are compared in the tuples\n            # case where the path cost are the same\n            raise Exception(\"Path cost are the same, cannot compare Link objects\")\n        except IndexError:\n            # IndexError if heap is empty\n            # case where start / end of highway, dist = 99\n            return 99\n        return orig_link[\"length\"] / 2.0 + link_cost\n\n    def _calc_link_static_reliability(self, network: EmmeNetwork):\n        \"\"\"\n        For highway reliability\n        consists of: lane factor, interchange distance, speed factor\n        differentiated by freeway, artertial, and others\n        \"\"\"\n        # Static reliability parameters\n        # freeway coefficients\n        freeway_rel = {\n            \"intercept\": 0.1078,\n            \"speed&gt;70\": 0.01393,\n            \"upstream\": 0.011,\n            \"downstream\": 0.0005445,\n        }\n        # arterial/ramp/other coefficients\n        road_rel = {\n            \"intercept\": 0.0546552,\n            \"lanes\": {1: 0.0, 2: 0.0103589, 3: 0.0361211, 4: 0.0446958, 5: 0.0},\n            \"speed\": {\n                \"&lt;35\": 0,\n                35: 0.0075674,\n                40: 0.0091012,\n                45: 0.0080996,\n                50: -0.0022938,\n                \"&gt;50\": -0.0046211,\n            },\n        }\n        for link in network.links():\n            # if freeway apply freeway parameters to this link\n            if (link[\"@ft\"] in [1, 2]) and (link[\"@lanes\"] &gt; 0):\n                high_speed_factor = (\n                    freeway_rel[\"speed&gt;70\"] if link[\"@free_flow_speed\"] &gt;= 70 else 0\n                )\n                upstream_factor = freeway_rel[\"upstream\"] * 1 / link[\"@intdist_up\"]\n                downstream_factor = (\n                    freeway_rel[\"downstream\"] * 1 / link[\"@intdist_down\"]\n                )\n                link[\"@static_rel\"] = (\n                    freeway_rel[\"intercept\"]\n                    + high_speed_factor\n                    + upstream_factor\n                    + downstream_factor\n                )\n            # arterial/ramp/other apply road parameters\n            elif (link[\"@ft\"] &lt; 8) and (link[\"@lanes\"] &gt; 0):\n                lane_factor = road_rel[\"lanes\"].get(link[\"@lanes\"], 0)\n                speed_bin = link[\"@free_flow_speed\"]\n                if speed_bin &lt; 35:\n                    speed_bin = \"&lt;35\"\n                elif speed_bin &gt; 50:\n                    speed_bin = \"&gt;50\"\n                speed_factor = road_rel[\"speed\"][speed_bin]\n                link[\"@static_rel\"] = road_rel[\"intercept\"] + lane_factor + speed_factor\n            else:\n                link[\"@static_rel\"] = 0\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_network.PrepareNetwork.__init__","title":"<code>__init__(controller)</code>","text":"<p>Constructor for PPrepareNetwork.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>Reference to run controller object.</p> required Source code in <code>tm2py/components/network/highway/highway_network.py</code> <pre><code>def __init__(self, controller: \"RunController\"):\n    \"\"\"Constructor for PPrepareNetwork.\n\n    Args:\n        controller (RunController): Reference to run controller object.\n    \"\"\"\n    super().__init__(controller)\n    self.config = self.controller.config.highway\n    self._emme_manager = self.controller.emme_manager\n    self._highway_emmebank = None\n    self._highway_scenarios = None\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_network.PrepareNetwork.run","title":"<code>run()</code>","text":"<p>Run network preparation step.</p> Source code in <code>tm2py/components/network/highway/highway_network.py</code> <pre><code>@LogStartEnd(\"Prepare network attributes and modes\")\ndef run(self):\n    \"\"\"Run network preparation step.\"\"\"\n    for time in self.time_period_names:\n        with self.controller.emme_manager.logbook_trace(\n            f\"prepare for highway assignment {time}\"\n        ):\n            scenario = self.highway_emmebank.scenario(time)\n            self._create_class_attributes(scenario, time)\n            network = scenario.get_network()\n            self._set_tolls(network, time)\n            self._set_vdf_attributes(network, time)\n            self._set_link_modes(network)\n            self._calc_link_skim_lengths(network)\n            self._calc_link_class_costs(network)\n            self._calc_interchange_distance(network)\n            self._calc_link_static_reliability(network)\n            scenario.publish_network(network)\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_network.PrepareNetwork.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate inputs files are correct, raise if an error is found.</p> Source code in <code>tm2py/components/network/highway/highway_network.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate inputs files are correct, raise if an error is found.\"\"\"\n    toll_file_path = self.get_abs_path(self.config.tolls.file_path)\n    if not os.path.exists(toll_file_path):\n        self.logger.log(\n            f\"Tolls file (config.highway.tolls.file_path) does not exist: {toll_file_path}\",\n            level=\"ERROR\",\n        )\n        raise FileNotFoundError(f\"Tolls file does not exist: {toll_file_path}\")\n    src_veh_groups = self.config.tolls.src_vehicle_group_names\n    columns = [\"fac_index\"]\n    for time in self.controller.config.time_periods:\n        for vehicle in src_veh_groups:\n            columns.append(f\"toll{time.name.lower()}_{vehicle}\")\n    with open(toll_file_path, \"r\", encoding=\"UTF8\") as toll_file:\n        header = set(h.strip() for h in next(toll_file).split(\",\"))\n        missing = []\n        for column in columns:\n            if column not in header:\n                missing.append(column)\n                self.logger.log(\n                    f\"Tolls file missing column: {column}\", level=\"ERROR\"\n                )\n    if missing:\n        raise FileFormatError(\n            f\"Tolls file missing {len(missing)} columns: {', '.join(missing)}\"\n        )\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_assign.AssignmentLauncher","title":"<code>AssignmentLauncher</code>","text":"<p>               Bases: <code>BaseAssignmentLauncher</code></p> <p>Manages Emme-related data (matrices and scenarios) for multiple time periods and kicks off assignment in a subprocess.</p> Source code in <code>tm2py/components/network/highway/highway_assign.py</code> <pre><code>class AssignmentLauncher(BaseAssignmentLauncher):\n    \"\"\"\n    Manages Emme-related data (matrices and scenarios) for multiple time periods\n    and kicks off assignment in a subprocess.\n    \"\"\"\n\n    def get_assign_script_path(self):\n        return __file__\n\n    def get_config(self):\n        configs = []\n        params = zip(\n            self._times,\n            self._scenarios,\n            self._assign_specs,\n            self._skim_matrices,\n            self._demand_matrices,\n            self._omx_file_paths,\n        )\n        for time, scenario, spec, skims, demands, omx_path in params:\n            configs.append(\n                {\n                    \"project_path\": self._run_project_path,\n                    \"emmebank_path\": self._run_emmebank_path,\n                    \"scenario_id\": scenario.id,\n                    \"time\": time,\n                    \"iteration\": self._iteration,\n                    \"assign_spec\": spec,\n                    \"demand_matrices\": demands,\n                    \"skim_matrices\": skims,\n                    \"omx_file_path\": omx_path,\n                }\n            )\n        return configs\n\n    def get_result_attributes(self, scenario_id: str):\n        attrs = [\"auto_time\", \"auto_volume\"]\n        for scenario, spec in zip(self._scenarios, self._assign_specs):\n            if scenario.id == scenario_id:\n                attrs.extend([c[\"results\"][\"link_volumes\"] for c in spec[\"classes\"]])\n        return attrs\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_assign.AssignmentRunner","title":"<code>AssignmentRunner</code>","text":"Source code in <code>tm2py/components/network/highway/highway_assign.py</code> <pre><code>class AssignmentRunner:\n\n    def __init__(\n        self,\n        project_path: str,\n        emmebank_path: str,\n        scenario_id: Union[str, int],\n        time: str,\n        iteration: int,\n        assign_spec: Dict,\n        demand_matrices: List[str],\n        skim_matrices: List[str],\n        omx_file_path: str,\n        logger=None,\n    ):\n        \"\"\"\n        Constructor to run the highway assignment for the specified time period.\n\n        Args:\n            project_path (str): path to existing EMME project (*.emp file)\n            emmebank_path (str): path to existing EMME databsae (emmebank) file\n            scenario_id (str): existing scenario ID for assignment run\n            time (str): time period ID (only used for logging messages)\n            iteration (List[str]): global iteration number\n            assign_spec (Dict): EMME SOLA assignment specification\n            skim_matrices (List[str]): list of skim matrix ID.\n            omx_file_path (str): path to resulting output of skim matrices to OMX\n            logger (Logger): optional logger object if running in process.\n                If not specified a new logger reference is created.\n        \"\"\"\n        self.emme_manager = EmmeManagerLight(project_path, emmebank_path)\n        self.emmebank = Emmebank(emmebank_path)\n        self.scenario = self.emmebank.scenario(scenario_id)\n\n        self.time = time\n        self.iteration = iteration\n        self.assign_spec = assign_spec\n        self.skim_matrix_ids = skim_matrices\n        self.demand_matrix_ids = demand_matrices\n        self.omx_file_path = omx_file_path\n\n        self._matrix_cache = None\n        self._network_calculator = None\n        self._skim_matrix_objs = []\n        if logger:\n            self.logger = logger\n        else:\n            root = os.path.dirname(os.path.dirname(project_path))\n            name = f\"run_highway_{time}_{iteration}\"\n            run_log_file_path = os.path.join(root, f\"{name}.log\")\n            log_on_error_file_path = os.path.join(root, f\"{name}_error.log\")\n            self.logger = ProcessLogger(\n                run_log_file_path, log_on_error_file_path, self.emme_manager\n            )\n\n    def run(self):\n        \"Run time period highway assignment\"\n        with self._setup():\n            if self.iteration &gt; 0:\n                self._copy_maz_flow()\n            else:\n                self._reset_background_traffic()\n            for matrix_name in self.demand_matrix_ids:\n                if not self.emmebank.matrix(matrix_name):\n                    raise Exception(f\"demand matrix {matrix_name} does not exist\")\n\n            self._create_skim_matrices()\n            with self.logger._skip_emme_logging():\n                self.logger.log_dict(self.assign_spec, level=\"DEBUG\")\n            with self.logger.log_start_end(\n                \"Run SOLA assignment (no path analyses)\", level=\"INFO\"\n            ):\n                assign = self.emme_manager.tool(\n                    \"inro.emme.traffic_assignment.sola_traffic_assignment\"\n                )\n                assign(\n                    self.assign_spec_no_analysis, self.scenario, chart_log_interval=1\n                )\n\n            with self.logger.log_start_end(\n                \"Calculates link level LOS based reliability\", level=\"DETAIL\"\n            ):\n                exf_pars = self.scenario.emmebank.extra_function_parameters\n                vdfs = [\n                    f for f in self.emmebank.functions() if f.type == \"VOLUME_DELAY\"\n                ]\n                net_calc = self._network_calculator\n                for function in vdfs:\n                    expression = function.expression\n                    for el in [\"el1\", \"el2\", \"el3\", \"el4\"]:\n                        expression = expression.replace(el, getattr(exf_pars, el))\n                    if \"@static_rel\" in expression:\n                        # split function into time component and reliability component\n                        time_expr, reliability_expr = expression.split(\n                            \"*(1+@static_rel+\"\n                        )\n                        net_calc.add_calc(\n                            \"@auto_time\",\n                            time_expr,\n                            {\"link\": f\"vdf={function.id[2:]}\"},\n                        )\n                        net_calc.add_calc(\n                            \"@reliability\",\n                            f\"(@static_rel+{reliability_expr}\",\n                            {\"link\": f\"vdf={function.id[2:]}\"},\n                        )\n                net_calc.add_calc(\"@reliability_sq\", \"@reliability**2\")\n                net_calc.run()\n\n            with self.logger.log_start_end(\n                \"Run SOLA assignment with path analyses and highway reliability\",\n                level=\"INFO\",\n            ):\n                assign(self.assign_spec, self.scenario, chart_log_interval=1)\n\n            # Subtract non-time costs from gen cost to get the raw travel time\n            self._calc_time_skims()\n            # Set intra-zonal for time and dist to be 1/2 nearest neighbour\n            self._set_intrazonal_values()\n            self._export_skims()\n            # if self.logger.debug_enabled:\n            #     self._log_debug_report(scenario, time)\n\n    @property\n    def assign_spec_no_analysis(self):\n        \"\"\"Return modified SOLA assignment specification with no analyses.\"\"\"\n        spec = _copy(self.assign_spec)\n        for emme_cls_spec in spec[\"classes\"]:\n            del emme_cls_spec[\"path_analyses\"]\n        return spec\n\n    @_context\n    def _setup(self):\n        \"\"\"Setup and teardown for Emme Matrix cache and list of skim matrices.\"\"\"\n        with self.logger.log_start_end(\n            f\"Run {self.time} highway assignment\", level=\"STATUS\"\n        ):\n            self._matrix_cache = MatrixCache(self.scenario)\n            self._skim_matrix_objs = []\n            self._network_calculator = NetworkCalculator(\n                self.emme_manager, self.scenario\n            )\n            try:\n                yield\n            finally:\n                self._matrix_cache.clear()\n                self._matrix_cache = None\n                self._skim_matrix_objs = []\n                self._network_calculator = None\n\n    def _copy_maz_flow(self):\n        \"\"\"Copy maz_flow from MAZ demand assignment to ul1 for background traffic.\"\"\"\n        self._network_calculator(\"ul1\", \"0\")\n\n    def _reset_background_traffic(self):\n        \"\"\"Set ul1 for background traffic to 0 (no maz-maz flow).\"\"\"\n        self.logger.log(\n            \"Set ul1 to 0 for background traffic\", indent=True, level=\"DETAIL\"\n        )\n        self._network_calculator(\"ul1\", \"@maz_flow\")\n\n    def _create_skim_matrices(self):\n        \"\"\"Create matrices to store skim results in Emme database.\n\n        Also add the matrices to list of self._skim_matrix_objs.\n        \"\"\"\n        create_matrix = self.emme_manager.tool(\"inro.emme.data.matrix.create_matrix\")\n        with self.logger.log_start_end(\"Creating skim matrices\", level=\"DETAIL\"):\n            for matrix_name in self.skim_matrix_ids:\n                matrix = self.emmebank.matrix(f'mf\"{matrix_name}\"')\n                if not matrix:\n                    matrix = create_matrix(\n                        \"mf\", matrix_name, scenario=self.scenario, overwrite=True\n                    )\n                self._skim_matrix_objs.append(matrix)\n\n    def _calc_time_skims(self):\n        \"\"\"Calculate the real time skim =gen_cost-per_fac*link_costs.\"\"\"\n        for emme_class_spec in self.assign_spec[\"classes\"]:\n            od_travel_times = emme_class_spec[\"results\"][\"od_travel_times\"][\n                \"shortest_paths\"\n            ]\n            if od_travel_times is not None:\n                # Total link costs is always the first analysis\n                cost = emme_class_spec[\"path_analyses\"][0][\"results\"][\"od_values\"]\n                factor = emme_class_spec[\"generalized_cost\"][\"perception_factor\"]\n                gencost_data = self._matrix_cache.get_data(od_travel_times)\n                cost_data = self._matrix_cache.get_data(cost)\n                time_data = gencost_data - (factor * cost_data)\n                self._matrix_cache.set_data(od_travel_times, time_data)\n\n    def _set_intrazonal_values(self):\n        \"\"\"Set the intrazonal values to 1/2 nearest neighbour for time and distance skims.\"\"\"\n        for matrix in self._skim_matrix_objs:\n            if matrix.name.endswith((\"time\", \"dist\")):\n                self.logger.debug(f\"Setting intrazonals to 0.5*min for {matrix.name}\")\n                data = self._matrix_cache.get_data(matrix.name)\n                # NOTE: sets values for external zones as well\n                np.fill_diagonal(data, np.inf)\n                data[np.diag_indices_from(data)] = 0.5 * np.nanmin(data, 1)\n                self._matrix_cache.set_data(matrix.name, data)\n\n    def _export_skims(self):\n        \"\"\"Export skims to OMX files by period.\"\"\"\n        # NOTE: skims in separate file by period\n        self.logger.debug(\n            f\"export {len(self._skim_matrix_objs)} skim matrices to {self.omx_file_path}\"\n        )\n        os.makedirs(os.path.dirname(self.omx_file_path), exist_ok=True)\n        with OMXManager(\n            self.omx_file_path, \"w\", self.scenario, matrix_cache=self._matrix_cache\n        ) as omx_file:\n            omx_file.write_matrices(self._skim_matrix_objs)\n\n    def _log_debug_report(self, scenario: EmmeScenario, time_period: str):\n        num_zones = len(scenario.zone_numbers)\n        num_cells = num_zones * num_zones\n        self.logger.debug(f\"Highway skim summary for period {time_period}\")\n        self.logger.debug(\n            f\"Number of zones: {num_zones}. Number of O-D pairs: {num_cells}. \"\n            \"Values outside -9999999, 9999999 are masked in summaries.\"\n        )\n        self.logger.debug(\n            \"name                            min       max      mean           sum\"\n        )\n        for matrix in self._skim_matrix_objs:\n            values = self._matrix_cache.get_data(matrix.name)\n            data = np.ma.masked_outside(values, -9999999, 9999999)\n            stats = (\n                f\"{matrix.name:25} {data.min():9.4g} {data.max():9.4g} \"\n                f\"{data.mean():9.4g} {data.sum(): 13.7g}\"\n            )\n            self.logger.debug(stats)\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_assign.AssignmentRunner.assign_spec_no_analysis","title":"<code>assign_spec_no_analysis</code>  <code>property</code>","text":"<p>Return modified SOLA assignment specification with no analyses.</p>"},{"location":"api/#tm2py.components.network.highway.highway_assign.AssignmentRunner.__init__","title":"<code>__init__(project_path, emmebank_path, scenario_id, time, iteration, assign_spec, demand_matrices, skim_matrices, omx_file_path, logger=None)</code>","text":"<p>Constructor to run the highway assignment for the specified time period.</p> <p>Parameters:</p> Name Type Description Default <code>project_path</code> <code>str</code> <p>path to existing EMME project (*.emp file)</p> required <code>emmebank_path</code> <code>str</code> <p>path to existing EMME databsae (emmebank) file</p> required <code>scenario_id</code> <code>str</code> <p>existing scenario ID for assignment run</p> required <code>time</code> <code>str</code> <p>time period ID (only used for logging messages)</p> required <code>iteration</code> <code>List[str]</code> <p>global iteration number</p> required <code>assign_spec</code> <code>Dict</code> <p>EMME SOLA assignment specification</p> required <code>skim_matrices</code> <code>List[str]</code> <p>list of skim matrix ID.</p> required <code>omx_file_path</code> <code>str</code> <p>path to resulting output of skim matrices to OMX</p> required <code>logger</code> <code>Logger</code> <p>optional logger object if running in process. If not specified a new logger reference is created.</p> <code>None</code> Source code in <code>tm2py/components/network/highway/highway_assign.py</code> <pre><code>def __init__(\n    self,\n    project_path: str,\n    emmebank_path: str,\n    scenario_id: Union[str, int],\n    time: str,\n    iteration: int,\n    assign_spec: Dict,\n    demand_matrices: List[str],\n    skim_matrices: List[str],\n    omx_file_path: str,\n    logger=None,\n):\n    \"\"\"\n    Constructor to run the highway assignment for the specified time period.\n\n    Args:\n        project_path (str): path to existing EMME project (*.emp file)\n        emmebank_path (str): path to existing EMME databsae (emmebank) file\n        scenario_id (str): existing scenario ID for assignment run\n        time (str): time period ID (only used for logging messages)\n        iteration (List[str]): global iteration number\n        assign_spec (Dict): EMME SOLA assignment specification\n        skim_matrices (List[str]): list of skim matrix ID.\n        omx_file_path (str): path to resulting output of skim matrices to OMX\n        logger (Logger): optional logger object if running in process.\n            If not specified a new logger reference is created.\n    \"\"\"\n    self.emme_manager = EmmeManagerLight(project_path, emmebank_path)\n    self.emmebank = Emmebank(emmebank_path)\n    self.scenario = self.emmebank.scenario(scenario_id)\n\n    self.time = time\n    self.iteration = iteration\n    self.assign_spec = assign_spec\n    self.skim_matrix_ids = skim_matrices\n    self.demand_matrix_ids = demand_matrices\n    self.omx_file_path = omx_file_path\n\n    self._matrix_cache = None\n    self._network_calculator = None\n    self._skim_matrix_objs = []\n    if logger:\n        self.logger = logger\n    else:\n        root = os.path.dirname(os.path.dirname(project_path))\n        name = f\"run_highway_{time}_{iteration}\"\n        run_log_file_path = os.path.join(root, f\"{name}.log\")\n        log_on_error_file_path = os.path.join(root, f\"{name}_error.log\")\n        self.logger = ProcessLogger(\n            run_log_file_path, log_on_error_file_path, self.emme_manager\n        )\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_assign.AssignmentRunner.run","title":"<code>run()</code>","text":"<p>Run time period highway assignment</p> Source code in <code>tm2py/components/network/highway/highway_assign.py</code> <pre><code>def run(self):\n    \"Run time period highway assignment\"\n    with self._setup():\n        if self.iteration &gt; 0:\n            self._copy_maz_flow()\n        else:\n            self._reset_background_traffic()\n        for matrix_name in self.demand_matrix_ids:\n            if not self.emmebank.matrix(matrix_name):\n                raise Exception(f\"demand matrix {matrix_name} does not exist\")\n\n        self._create_skim_matrices()\n        with self.logger._skip_emme_logging():\n            self.logger.log_dict(self.assign_spec, level=\"DEBUG\")\n        with self.logger.log_start_end(\n            \"Run SOLA assignment (no path analyses)\", level=\"INFO\"\n        ):\n            assign = self.emme_manager.tool(\n                \"inro.emme.traffic_assignment.sola_traffic_assignment\"\n            )\n            assign(\n                self.assign_spec_no_analysis, self.scenario, chart_log_interval=1\n            )\n\n        with self.logger.log_start_end(\n            \"Calculates link level LOS based reliability\", level=\"DETAIL\"\n        ):\n            exf_pars = self.scenario.emmebank.extra_function_parameters\n            vdfs = [\n                f for f in self.emmebank.functions() if f.type == \"VOLUME_DELAY\"\n            ]\n            net_calc = self._network_calculator\n            for function in vdfs:\n                expression = function.expression\n                for el in [\"el1\", \"el2\", \"el3\", \"el4\"]:\n                    expression = expression.replace(el, getattr(exf_pars, el))\n                if \"@static_rel\" in expression:\n                    # split function into time component and reliability component\n                    time_expr, reliability_expr = expression.split(\n                        \"*(1+@static_rel+\"\n                    )\n                    net_calc.add_calc(\n                        \"@auto_time\",\n                        time_expr,\n                        {\"link\": f\"vdf={function.id[2:]}\"},\n                    )\n                    net_calc.add_calc(\n                        \"@reliability\",\n                        f\"(@static_rel+{reliability_expr}\",\n                        {\"link\": f\"vdf={function.id[2:]}\"},\n                    )\n            net_calc.add_calc(\"@reliability_sq\", \"@reliability**2\")\n            net_calc.run()\n\n        with self.logger.log_start_end(\n            \"Run SOLA assignment with path analyses and highway reliability\",\n            level=\"INFO\",\n        ):\n            assign(self.assign_spec, self.scenario, chart_log_interval=1)\n\n        # Subtract non-time costs from gen cost to get the raw travel time\n        self._calc_time_skims()\n        # Set intra-zonal for time and dist to be 1/2 nearest neighbour\n        self._set_intrazonal_values()\n        self._export_skims()\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_assign.HighwayAssignment","title":"<code>HighwayAssignment</code>","text":"<p>               Bases: <code>Component</code></p> <p>Highway assignment and skims. Args:     controller: parent RunController object</p> Source code in <code>tm2py/components/network/highway/highway_assign.py</code> <pre><code>class HighwayAssignment(Component):\n    \"\"\"Highway assignment and skims.\n    Args:\n        controller: parent RunController object\n    \"\"\"\n\n    def __init__(self, controller: \"RunController\"):\n        \"\"\"Constructor for HighwayAssignment components.\n\n        Args:\n            controller (RunController): Reference to current run controller.\n        \"\"\"\n        super().__init__(controller)\n\n        self.config = self.controller.config.highway\n        self._highway_emmebank = None\n        self._class_config = None\n\n    @property\n    def highway_emmebank(self):\n        \"The ProxyEmmebank object connect to the EMMEBANK for the highway assignment.\"\n        if not self._highway_emmebank:\n            self._highway_emmebank = self.controller.emme_manager.highway_emmebank\n        return self._highway_emmebank\n\n    @property\n    def classes(self):\n        \"The list of class names in the highway config\"\n        return [c.name for c in self.config.classes]\n\n    @property\n    def class_config(self):\n        \"Mapping of class names and config objs in the highway config.\"\n        if not self._class_config:\n            self._class_config = {c.name: c for c in self.config.classes}\n\n        return self._class_config\n\n    def validate_inputs(self):\n        \"\"\"Validate inputs files are correct, raise if an error is found.\"\"\"\n\n    @LogStartEnd(\"Highway assignment and skims\", level=\"STATUS\")\n    def run(self):\n        \"\"\"Run highway assignment.\"\"\"\n        demand = PrepareHighwayDemand(self.controller)\n        if self.controller.iteration == 0:\n            self.highway_emmebank.create_zero_matrix()\n            if self.controller.config.warmstart.warmstart:\n                if self.controller.config.warmstart.use_warmstart_demand:\n                    demand.run()\n        else:\n            demand.run()\n\n        distribution = self.controller.config.emme.highway_distribution\n        if distribution:\n            launchers = self.setup_process_launchers(distribution[:-1])\n            self.start_proccesses(launchers)\n            # Run last configuration in process\n            in_process_times = distribution[-1].time_periods\n            num_processors = distribution[-1].num_processors\n            self.run_in_process(in_process_times, num_processors)\n            self.wait_for_processes(launchers)\n        else:\n            num_processors = self.controller.emme_manager.num_processors\n            self.run_in_process(self.time_period_names, num_processors)\n\n    def run_in_process(self, times: List[str], num_processors: Union[int, str]):\n        \"Start highway assignments in same process\"\n        self.logger.status(\n            f\"Running highway assignments in process: {', '.join(times)}\"\n        )\n        iteration = self.controller.iteration\n        for time in times:\n            project_path = self.emme_manager.project_path\n            emmebank_path = self.highway_emmebank.path\n            params = self._get_assign_params(time, num_processors)\n            runner = AssignmentRunner(\n                project_path,\n                emmebank_path,\n                iteration=iteration,\n                logger=self.logger,\n                **params,\n            )\n            runner.run()\n\n    def setup_process_launchers(self, distribution):\n        \"Setup (copy data) databases for running assignments in separate processes\"\n        self.logger.status(\n            f\"Running highway assignments in {len(distribution)} separate processes\"\n        )\n        iteration = self.controller.iteration\n        launchers = []\n        time_params = {}\n        for config in distribution:\n            assign_launcher = AssignmentLauncher(\n                self.highway_emmebank.emmebank, iteration\n            )\n            launchers.append(assign_launcher)\n            for time in config.time_periods:\n                params = self._get_assign_params(time, config.num_processors)\n                assign_launcher.add_run(**params)\n                time_params[time] = params\n\n        # initialize all skim matrices - complete all periods in order\n        for time in self.time_period_names:\n            params = time_params.get(time)\n            if params:\n                for matrix_name in params[\"skim_matrices\"]:\n                    self.highway_emmebank.create_matrix(matrix_name, \"FULL\")\n\n        return launchers\n\n    def start_proccesses(self, launchers):\n        \"Start separate processes for running assignments\"\n        for i, assign_launcher in enumerate(launchers):\n            self.logger.status(\n                f\"Starting highway assignment process {i} {', '.join(assign_launcher.times)}\"\n            )\n            assign_launcher.setup()\n            assign_launcher.run()\n\n    def wait_for_processes(self, launchers):\n        self.logger.status(\"Waiting for highway assignments to complete...\")\n        while launchers:\n            _time.sleep(5)\n            for assign_launcher in launchers[:]:\n                if not assign_launcher.is_running:\n                    self.logger.status(\n                        \"... assignment process complete for time(s): \"\n                        f\"{', '.join(assign_launcher.times)}\"\n                    )\n                    assign_launcher.teardown()\n                    launchers.remove(assign_launcher)\n\n    def _get_assign_params(self, time, num_processors):\n        iteration = self.controller.iteration\n        warmstart = self.controller.config.warmstart.warmstart\n        builder = AssignmentSpecBuilder(\n            time, iteration, warmstart, self.config, num_processors\n        )\n        # Must match signature of manager.BaseAssignmentLauncher.add_run\n        #       time, scenario, assign_spec, demand_matrices, skim_matrices, omx_file_path\n        params = dict(\n            time=time,\n            scenario_id=self.highway_emmebank.scenario(time).id,\n            assign_spec=builder.assignment_spec,\n            demand_matrices=builder.demand_matrices,\n            skim_matrices=builder.skim_matrices,\n            omx_file_path=self.get_abs_path(\n                self.config.output_skim_path\n                / self.config.output_skim_filename_tmpl.format(time_period=time)\n            ),\n        )\n        self.logger.debug(\n            f\"_get_assign_params: self.config.output_skim_path:{self.config.output_skim_path}\"\n        )\n        with self.logger._skip_emme_logging():\n            self.logger.debug(\"_get_assign_params: params dictionary\")\n            self.logger.log_dict(params, level=\"DEBUG\")\n        return params\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_assign.HighwayAssignment.class_config","title":"<code>class_config</code>  <code>property</code>","text":"<p>Mapping of class names and config objs in the highway config.</p>"},{"location":"api/#tm2py.components.network.highway.highway_assign.HighwayAssignment.classes","title":"<code>classes</code>  <code>property</code>","text":"<p>The list of class names in the highway config</p>"},{"location":"api/#tm2py.components.network.highway.highway_assign.HighwayAssignment.highway_emmebank","title":"<code>highway_emmebank</code>  <code>property</code>","text":"<p>The ProxyEmmebank object connect to the EMMEBANK for the highway assignment.</p>"},{"location":"api/#tm2py.components.network.highway.highway_assign.HighwayAssignment.__init__","title":"<code>__init__(controller)</code>","text":"<p>Constructor for HighwayAssignment components.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>Reference to current run controller.</p> required Source code in <code>tm2py/components/network/highway/highway_assign.py</code> <pre><code>def __init__(self, controller: \"RunController\"):\n    \"\"\"Constructor for HighwayAssignment components.\n\n    Args:\n        controller (RunController): Reference to current run controller.\n    \"\"\"\n    super().__init__(controller)\n\n    self.config = self.controller.config.highway\n    self._highway_emmebank = None\n    self._class_config = None\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_assign.HighwayAssignment.run","title":"<code>run()</code>","text":"<p>Run highway assignment.</p> Source code in <code>tm2py/components/network/highway/highway_assign.py</code> <pre><code>@LogStartEnd(\"Highway assignment and skims\", level=\"STATUS\")\ndef run(self):\n    \"\"\"Run highway assignment.\"\"\"\n    demand = PrepareHighwayDemand(self.controller)\n    if self.controller.iteration == 0:\n        self.highway_emmebank.create_zero_matrix()\n        if self.controller.config.warmstart.warmstart:\n            if self.controller.config.warmstart.use_warmstart_demand:\n                demand.run()\n    else:\n        demand.run()\n\n    distribution = self.controller.config.emme.highway_distribution\n    if distribution:\n        launchers = self.setup_process_launchers(distribution[:-1])\n        self.start_proccesses(launchers)\n        # Run last configuration in process\n        in_process_times = distribution[-1].time_periods\n        num_processors = distribution[-1].num_processors\n        self.run_in_process(in_process_times, num_processors)\n        self.wait_for_processes(launchers)\n    else:\n        num_processors = self.controller.emme_manager.num_processors\n        self.run_in_process(self.time_period_names, num_processors)\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_assign.HighwayAssignment.run_in_process","title":"<code>run_in_process(times, num_processors)</code>","text":"<p>Start highway assignments in same process</p> Source code in <code>tm2py/components/network/highway/highway_assign.py</code> <pre><code>def run_in_process(self, times: List[str], num_processors: Union[int, str]):\n    \"Start highway assignments in same process\"\n    self.logger.status(\n        f\"Running highway assignments in process: {', '.join(times)}\"\n    )\n    iteration = self.controller.iteration\n    for time in times:\n        project_path = self.emme_manager.project_path\n        emmebank_path = self.highway_emmebank.path\n        params = self._get_assign_params(time, num_processors)\n        runner = AssignmentRunner(\n            project_path,\n            emmebank_path,\n            iteration=iteration,\n            logger=self.logger,\n            **params,\n        )\n        runner.run()\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_assign.HighwayAssignment.setup_process_launchers","title":"<code>setup_process_launchers(distribution)</code>","text":"<p>Setup (copy data) databases for running assignments in separate processes</p> Source code in <code>tm2py/components/network/highway/highway_assign.py</code> <pre><code>def setup_process_launchers(self, distribution):\n    \"Setup (copy data) databases for running assignments in separate processes\"\n    self.logger.status(\n        f\"Running highway assignments in {len(distribution)} separate processes\"\n    )\n    iteration = self.controller.iteration\n    launchers = []\n    time_params = {}\n    for config in distribution:\n        assign_launcher = AssignmentLauncher(\n            self.highway_emmebank.emmebank, iteration\n        )\n        launchers.append(assign_launcher)\n        for time in config.time_periods:\n            params = self._get_assign_params(time, config.num_processors)\n            assign_launcher.add_run(**params)\n            time_params[time] = params\n\n    # initialize all skim matrices - complete all periods in order\n    for time in self.time_period_names:\n        params = time_params.get(time)\n        if params:\n            for matrix_name in params[\"skim_matrices\"]:\n                self.highway_emmebank.create_matrix(matrix_name, \"FULL\")\n\n    return launchers\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_assign.HighwayAssignment.start_proccesses","title":"<code>start_proccesses(launchers)</code>","text":"<p>Start separate processes for running assignments</p> Source code in <code>tm2py/components/network/highway/highway_assign.py</code> <pre><code>def start_proccesses(self, launchers):\n    \"Start separate processes for running assignments\"\n    for i, assign_launcher in enumerate(launchers):\n        self.logger.status(\n            f\"Starting highway assignment process {i} {', '.join(assign_launcher.times)}\"\n        )\n        assign_launcher.setup()\n        assign_launcher.run()\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_assign.HighwayAssignment.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate inputs files are correct, raise if an error is found.</p> Source code in <code>tm2py/components/network/highway/highway_assign.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate inputs files are correct, raise if an error is found.\"\"\"\n</code></pre>"},{"location":"api/#tm2py.config.HighwayConfig.unique_capclass_numbers","title":"<code>unique_capclass_numbers(value)</code>","text":"<p>Validate list of capclass_lookup has unique .capclass values.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"capclass_lookup\")\ndef unique_capclass_numbers(cls, value):\n    \"\"\"Validate list of capclass_lookup has unique .capclass values.\"\"\"\n    capclass_ids = [i.capclass for i in value]\n    error_msg = \"-&gt; capclass value must be unique in list\"\n    assert len(capclass_ids) == len(set(capclass_ids)), error_msg\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayConfig.unique_class_names","title":"<code>unique_class_names(value)</code>","text":"<p>Validate list of classes has unique .name values.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"classes\", pre=True)\ndef unique_class_names(cls, value):\n    \"\"\"Validate list of classes has unique .name values.\"\"\"\n    class_names = [highway_class[\"name\"] for highway_class in value]\n    error_msg = \"-&gt; name value must be unique in list\"\n    assert len(class_names) == len(set(class_names)), error_msg\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayConfig.valid_skim_matrix_name_template","title":"<code>valid_skim_matrix_name_template(value)</code>","text":"<p>Validate skim matrix template has correct {}.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"output_skim_matrixname_tmpl\")\ndef valid_skim_matrix_name_template(value):\n    \"\"\"Validate skim matrix template has correct {}.\"\"\"\n    assert (\n        \"{time_period\" in value\n    ), \"-&gt; 'output_skim_matrixname_tmpl must have {time_period}, found {value}.\"\n    assert (\n        \"{property\" in value\n    ), \"-&gt; 'output_skim_matrixname_tmpl must have {property}, found {value}.\"\n    assert (\n        \"{mode\" in value\n    ), \"-&gt; 'output_skim_matrixname_tmpl must have {mode}, found {value}.\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayConfig.valid_skim_template","title":"<code>valid_skim_template(value)</code>","text":"<p>Validate skim template has correct {} and extension.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"output_skim_filename_tmpl\")\ndef valid_skim_template(value):\n    \"\"\"Validate skim template has correct {} and extension.\"\"\"\n    assert (\n        \"{time_period\" in value\n    ), f\"-&gt; output_skim_filename_tmpl must have {{time_period}}', found {value}.\"\n    assert (\n        value[-4:].lower() == \".omx\"\n    ), f\"-&gt; 'output_skim_filename_tmpl must end in '.omx', found {value[-4:].lower() }\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayConfig.validate_class_keyword_lists","title":"<code>validate_class_keyword_lists(value, values)</code>","text":"<p>Validate classes .skims, .toll, and .excluded_links values.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"classes\")\ndef validate_class_keyword_lists(cls, value, values):\n    \"\"\"Validate classes .skims, .toll, and .excluded_links values.\"\"\"\n    if \"tolls\" not in values:\n        return value\n    avail_skims = [\n        \"time\",\n        \"dist\",\n        \"hovdist\",\n        \"tolldist\",\n        \"freeflowtime\",\n        \"rlbty\",\n        \"autotime\",\n    ]\n    available_link_sets = [\"is_sr\", \"is_sr2\", \"is_sr3\", \"is_auto_only\"]\n    avail_toll_attrs = []\n    for name in values[\"tolls\"].dst_vehicle_group_names:\n        toll_types = [f\"bridgetoll_{name}\", f\"valuetoll_{name}\"]\n        avail_skims.extend(toll_types)\n        avail_toll_attrs.extend([\"@\" + name for name in toll_types])\n        available_link_sets.append(f\"is_toll_{name}\")\n\n    # validate class skim name list and toll attribute against toll setup\n    def check_keywords(class_num, key, val, available):\n        extra_keys = set(val) - set(available)\n        error_msg = (\n            f\" -&gt; {class_num} -&gt; {key}: unrecognized {key} name(s): \"\n            f\"{','.join(extra_keys)}.  Available names are: {', '.join(available)}\"\n        )\n        assert not extra_keys, error_msg\n\n    for i, highway_class in enumerate(value):\n        check_keywords(i, \"skim\", highway_class[\"skims\"], avail_skims)\n        check_keywords(i, \"toll\", highway_class[\"toll\"], avail_toll_attrs)\n        check_keywords(\n            i,\n            \"excluded_links\",\n            highway_class[\"excluded_links\"],\n            available_link_sets,\n        )\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayConfig.validate_class_mode_excluded_links","title":"<code>validate_class_mode_excluded_links(value, values)</code>","text":"<p>Validate list of classes has unique .mode_code or .excluded_links match.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"classes\")\ndef validate_class_mode_excluded_links(cls, value, values):\n    \"\"\"Validate list of classes has unique .mode_code or .excluded_links match.\"\"\"\n    # validate if any mode IDs are used twice, that they have the same excluded links sets\n    mode_excluded_links = {}\n    for i, highway_class in enumerate(value):\n        # maz_to_maz.mode_code must be unique\n        if \"maz_to_maz\" in values:\n            assert (\n                highway_class[\"mode_code\"] != values[\"maz_to_maz\"][\"mode_code\"]\n            ), f\"-&gt; {i} -&gt; mode_code: cannot be the same as the highway.maz_to_maz.mode_code\"\n        # make sure that if any mode IDs are used twice, they have the same excluded links sets\n        if highway_class.mode_code in mode_excluded_links:\n            ex_links1 = highway_class[\"excluded_links\"]\n            ex_links2 = mode_excluded_links[highway_class[\"mode_code\"]]\n            error_msg = (\n                f\"-&gt; {i}: duplicated mode codes ('{highway_class['mode_code']}') \"\n                f\"with different excluded links: {ex_links1} and {ex_links2}\"\n            )\n            assert ex_links1 == ex_links2, error_msg\n        mode_excluded_links[highway_class.mode_code] = highway_class.excluded_links\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.HighwayTollsConfig.dst_vehicle_group_names_length","title":"<code>dst_vehicle_group_names_length(value, values)</code>","text":"<p>Validate dst_vehicle_group_names has same length as src_vehicle_group_names.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"dst_vehicle_group_names\", always=True)\ndef dst_vehicle_group_names_length(cls, value, values):\n    \"\"\"Validate dst_vehicle_group_names has same length as src_vehicle_group_names.\"\"\"\n    if \"src_vehicle_group_names\" in values:\n        assert len(value) == len(\n            values[\"src_vehicle_group_names\"]\n        ), \"dst_vehicle_group_names must be same length as src_vehicle_group_names\"\n        assert all(\n            [len(v) &lt;= 4 for v in value]\n        ), \"dst_vehicle_group_names must be 4 characters or less\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_maz.AssignMAZSPDemand","title":"<code>AssignMAZSPDemand</code>","text":"<p>               Bases: <code>Component</code></p> <p>MAZ-to-MAZ shortest-path highway assignment.</p> <p>Calculates shortest path between MAZs with demand in the Emme network and assigns flow.</p> Source code in <code>tm2py/components/network/highway/highway_maz.py</code> <pre><code>class AssignMAZSPDemand(Component):\n    \"\"\"MAZ-to-MAZ shortest-path highway assignment.\n\n    Calculates shortest path between MAZs with demand in the Emme network\n    and assigns flow.\n    \"\"\"\n\n    # skip Too many instance attributes recommendation, it is OK as is\n    # pylint: disable=R0902\n\n    def __init__(self, controller: RunController):\n        \"\"\"MAZ-to-MAZ shortest-path highway assignment.\n\n        Args:\n            controller: parent Controller object\n        \"\"\"\n\n        super().__init__(controller)\n        self.config = self.controller.config.highway.maz_to_maz\n        self._debug = False\n\n        # bins: performance parameter: crow-fly distance bins\n        #       to limit shortest path calculation by origin to furthest destination\n        #       semi-exposed for performance testing\n        self._bin_edges = _default_bin_edges\n\n        # Lazily-loaded Emme Properties\n        self._highway_emmebank = None\n        self._eb_dir = None\n\n        # Internal attributes to track data through the sequence of steps\n        self._scenario = None\n        self._mazs = None\n        self._demand = _defaultdict(lambda: [])\n        self._max_dist = 0\n        self._network = None\n        self._root_index = None\n        self._leaf_index = None\n\n    @property\n    def highway_emmebank(self):\n        if self._highway_emmebank is None:\n            self._highway_emmebank = self.controller.emme_manager.highway_emmebank\n        return self._highway_emmebank\n\n    @property\n    def eb_dir(self):\n        if self._eb_dir is None:\n            self._eb_dir = os.path.dirname(self.highway_emmebank.path)\n        return self._eb_dir\n\n    def validate_inputs(self):\n        \"\"\"Validate inputs files are correct, raise if an error is found.\"\"\"\n        # TODO\n        pass\n\n    @LogStartEnd()\n    def run(self):\n        \"\"\"Run MAZ-to-MAZ shortest path assignment.\"\"\"\n\n        county_groups = {}\n        for group in self.config.demand_county_groups:\n            county_groups[group.number] = group.counties\n        for time in self.time_period_names:\n            self._scenario = self.highway_emmebank.scenario(time)\n            with self._setup(time):\n                self._prepare_network()\n                for i, names in county_groups.items():\n                    maz_ids = self._get_county_mazs(names)\n                    if len(maz_ids) == 0:\n                        self.logger.log(\n                            f\"warning: no mazs for counties {', '.join(names)}\"\n                        )\n                        continue\n                    self._process_demand(time, i, maz_ids)\n                demand_bins = self._group_demand()\n                for i, demand_group in enumerate(demand_bins):\n                    self._find_roots_and_leaves(demand_group[\"demand\"])\n                    self._set_link_cost_maz()\n                    self._run_shortest_path(time, i, demand_group[\"dist\"])\n                    self._assign_flow(time, i, demand_group[\"demand\"])\n\n    @_context\n    def _setup(self, time: str):\n        \"\"\"Context setup / teardown, initializes internal attributes.\n\n        Args:\n            time: name of the time period\n        \"\"\"\n        self._mazs = None\n        self._demand = _defaultdict(lambda: [])\n        self._max_dist = 0\n        self._network = None\n        self._root_index = None\n        self._leaf_index = None\n        attributes = [\n            (\"LINK\", \"@link_cost\", \"total cost MAZ-MAZ\"),\n            (\"LINK\", \"@link_cost_maz\", \"cost MAZ-MAZ, unused MAZs blocked\"),\n            (\"NODE\", \"@maz_root\", \"Flag for MAZs which are roots\"),\n            (\"NODE\", \"@maz_leaf\", \"Flag for MAZs which are leaves\"),\n        ]\n        for domain, name, desc in attributes:\n            self.logger.log(f\"Create temp {domain} attr: {name}, {desc}\", level=\"TRACE\")\n        with self.controller.emme_manager.temp_attributes_and_restore(\n            self._scenario, attributes\n        ):\n            try:\n                with self.logger.log_start_end(\n                    f\"MAZ assign for period {time} scenario {self._scenario}\"\n                ):\n                    yield\n            finally:\n                if not self._debug:\n                    self._mazs = None\n                    self._demand = None\n                    self._network = None\n                    self._root_index = None\n                    self._leaf_index = None\n                    # delete sp path files\n                    for bin_no in range(len(self._bin_edges)):\n                        file_path = os.path.join(self.eb_dir, f\"sp_{time}_{bin_no}.ebp\")\n                        if os.path.exists(file_path):\n                            os.remove(file_path)\n\n    def _prepare_network(self):\n        \"\"\"Calculate link cost (travel time + bridge tolls + operating cost) and load network.\n\n        Reads Emme network from disk for later node lookups. Optimized to only load\n        attribute values of interest, additional attributes must be added in\n        order to be read from disk.\n        \"\"\"\n        if self._scenario.has_traffic_results:\n            time_attr = \"(@free_flow_time.max.timau)\"\n        else:\n            time_attr = \"@free_flow_time\"\n        self.logger.log(f\"Calculating link costs using time {time_attr}\", level=\"DEBUG\")\n        vot = self.config.value_of_time\n        op_cost = self.config.operating_cost_per_mile\n        net_calc = NetworkCalculator(self.controller.emme_manager, self._scenario)\n        report = net_calc(\n            \"@link_cost\", f\"{time_attr} + 0.6 / {vot} * (length * {op_cost})\"\n        )\n        self.logger.log(\"Link cost calculation report\", level=\"TRACE\")\n        self.logger.log_dict(report, level=\"TRACE\")\n        self._network = self.controller.emme_manager.get_network(\n            self._scenario, {\"NODE\": [\"@maz_id\", \"x\", \"y\", \"#node_county\"], \"LINK\": []}\n        )\n        self._network.create_attribute(\"LINK\", \"temp_flow\")\n\n    def _get_county_mazs(self, counties: List[str]) -&gt; List[EmmeNode]:\n        \"\"\"Get all MAZ nodes which are located in one of these counties.\n\n        Used the node attribute #node_county to identify the node location.\n        Name must be an exact match. Catches a mapping of the county names\n        to nodes so nodes are processed only once.\n\n        Args:\n            counties: list of county names\n\n        Returns:\n            List of MAZ nodes (Emme Node) which are in these counties.\n        \"\"\"\n        self.logger.log(\n            f\"Processing county MAZs for {', '.join(counties)}\", level=\"DETAIL\"\n        )\n        network = self._network\n        # maz data\n        # maz_file = self.get_abs_path(self.controller.config.scenario.maz_landuse_file)\n        # maz_df = pd.read_csv(maz_file)\n        # maz_county_dict = dict(zip(maz_df[\"MAZ_ORIGINAL\"], maz_df[\"CountyName\"]))\n        # NOTE: every maz must have a valid #node_county\n        if self._mazs is None:\n            self._mazs = _defaultdict(lambda: [])\n            for node in network.nodes():\n                if node[\"@maz_id\"]:\n                    # self._mazs[maz_county_dict[node[\"@maz_id\"]]].append(node)\n                    self._mazs[node[\"#node_county\"]].append(node)\n        mazs = []\n        for county in counties:\n            mazs.extend(self._mazs[county])\n        # highway emme network does not include the 5 inaccessiable MAZs, but the trip table is indexed by the full MAZ list\n        # https://app.asana.com/0/12291104512575/1199091221400653/f\n        if \"San Francisco\" in counties:\n            mazs.extend(\n                [\n                    {\"@maz_id\": 10186},\n                    {\"@maz_id\": 16084},\n                    {\"@maz_id\": 111432},\n                    {\"@maz_id\": 111433},\n                ]\n            )\n        if \"Contra Costa\" in counties:\n            mazs.extend([{\"@maz_id\": 411178}])\n        self.logger.log(f\"Num MAZs {len(mazs)}\", level=\"DEBUG\")\n        return sorted(mazs, key=lambda n: n[\"@maz_id\"])\n\n    def _process_demand(self, time: str, index: int, maz_ids: List[EmmeNode]):\n        \"\"\"Loads the demand from file and groups by origin node.\n\n        Sets the demand to self._demand for later processing, grouping the demand in\n        a dictionary by origin node (Emme Node object) to list of dictionaries\n        {\"orig\": orig_node, \"dest\": dest_node, \"dem\": demand, \"dist\": dist}\n\n        Args:\n            time: time period name\n            index: group index of the demand file, used to find the file by name\n            maz_ids: indexed list of MAZ ID nodes for the county group\n                (active counties for this demand file)\n        \"\"\"\n        self.logger.log(\n            f\"Process demand for time period {time} index {index}\", level=\"DETAIL\"\n        )\n        data = self._read_demand_array(time, index)\n        origins, destinations = data.nonzero()\n        self.logger.log(\n            f\"non-zero origins {len(origins)} destinations {len(destinations)}\",\n            level=\"DEBUG\",\n        )\n        total_demand = 0\n        for orig, dest in zip(origins, destinations):\n            # skip intra-maz demand\n            if orig == dest:\n                continue\n            if orig &gt; len(maz_ids) - 1:\n                self.logger.log(\n                    f\"Network MAZ @maz_id={orig} #county_name does not match its county name in the input MAZ SE data.\",\n                    level=\"DEBUG\",\n                )\n                continue\n            if dest &gt; len(maz_ids) - 1:\n                self.logger.log(\n                    f\"Network MAZ @maz_id={dest} #county_name does not match its county name in the input MAZ SE data.\",\n                    level=\"DEBUG\",\n                )\n                continue\n            check = maz_ids[99]\n            orig_node = maz_ids[orig]\n            dest_node = maz_ids[dest]\n            dist = _sqrt(\n                (dest_node.x - orig_node.x) ** 2 + (dest_node.y - orig_node.y) ** 2\n            )\n            if (dist / 5280) &gt; self.config.max_distance:\n                self.logger.log(\n                    f\"MAZ demand from {orig} to {dest} is over {self.config.max_distance} miles, do not assign\",\n                    level=\"DEBUG\",\n                )\n                continue\n            if dist &gt; self._max_dist:\n                self._max_dist = dist\n            demand = data[orig][dest]\n            total_demand += demand\n            self._demand[orig_node].append(\n                {\n                    \"orig\": orig_node,\n                    \"dest\": dest_node,\n                    \"dem\": demand,\n                    \"dist\": dist,\n                }\n            )\n        self.logger.log(f\"Max distance found {self._max_dist}\", level=\"DEBUG\")\n        self.logger.log(f\"Total inter-zonal demand {total_demand}\", level=\"DEBUG\")\n\n    def _read_demand_array(self, time: str, index: int) -&gt; NumpyArray:\n        \"\"\"Load the demand from file with the specified time and index name.\n\n        Args:\n            time: time period name\n            index: group index of the demand file, used to find the file by name\n        \"\"\"\n        file_path_tmplt = self.get_abs_path(self.config.demand_file)\n        omx_file_path = self.get_abs_path(\n            file_path_tmplt.format(\n                period=time, number=index, iter=self.controller.iteration\n            )\n        )\n        self.logger.log(f\"Reading demand from {omx_file_path}\", level=\"DEBUG\")\n        with OMXManager(omx_file_path, \"r\") as omx_file:\n            demand_array = omx_file.read(f\"MAZ_AUTO_{index}_{time}\")\n            omx_file.close()\n        return demand_array\n\n    def _group_demand(\n        self,\n    ) -&gt; List[Dict[str, Union[float, List[Dict[str, Union[float, EmmeNode]]]]]]:\n        \"\"\"Process the demand loaded from files \\\n            and create groups based on the origin to the furthest destination with demand.\n\n        Returns:\n            List of dictionaries, containing the demand in the format\n                {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)}\n\n        \"\"\"\n        self.logger.log(\"Grouping demand in distance buckets\", level=\"DETAIL\")\n        # group demand from same origin into distance bins by furthest\n        # distance destination to limit shortest path search radius\n        bin_edges = self._bin_edges[:]\n        if bin_edges[-1] &lt; self._max_dist / 5280.0:\n            bin_edges.append(self._max_dist / 5280.0)\n\n        demand_groups = [\n            {\"dist\": edge, \"demand\": []} for i, edge in enumerate(bin_edges[1:])\n        ]\n        for data in self._demand.values():\n            max_dist = max(entry[\"dist\"] for entry in data) / 5280.0\n            for group in demand_groups:\n                if max_dist &lt; group[\"dist\"]:\n                    group[\"demand\"].extend(data)\n                    break\n        for group in demand_groups:\n            self.logger.log(\n                f\"bin dist {group['dist']}, size {len(group['demand'])}\", level=\"DEBUG\"\n            )\n        # Filter out groups without any demand\n        demand_groups = [group for group in demand_groups if group[\"demand\"]]\n        return demand_groups\n\n    def _find_roots_and_leaves(self, demand: List[Dict[str, Union[float, EmmeNode]]]):\n        \"\"\"Label available MAZ root nodes and leaf nodes for the path calculation.\n\n        The MAZ nodes which are found as origins in the demand are \"activated\"\n        by setting @maz_root to non-zero, and similarly the leaves have @maz_leaf\n        set to non-zero.\n\n        Args:\n            demand: list of dictionaries, containing the demand in the format\n                {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)}\n        \"\"\"\n        network = self._network\n        attrs_to_init = [(\"NODE\", [\"@maz_root\", \"@maz_leaf\"]), (\"LINK\", [\"maz_cost\"])]\n        for domain, attrs in attrs_to_init:\n            for name in attrs:\n                if name in network.attributes(domain):\n                    network.delete_attribute(domain, name)\n                network.create_attribute(domain, name)\n        root_maz_ids = {}\n        leaf_maz_ids = {}\n        for data in demand:\n            o_node, d_node = data[\"orig\"], data[\"dest\"]\n            root_maz_ids[o_node.number] = o_node[\"@maz_root\"] = o_node[\"@maz_id\"]\n            leaf_maz_ids[d_node.number] = d_node[\"@maz_leaf\"] = d_node[\"@maz_id\"]\n        self._root_index = {p: i for i, p in enumerate(sorted(root_maz_ids.keys()))}\n        self._leaf_index = {q: i for i, q in enumerate(sorted(leaf_maz_ids.keys()))}\n        self.controller.emme_manager.copy_attribute_values(\n            self._network, self._scenario, {\"NODE\": [\"@maz_root\", \"@maz_leaf\"]}\n        )\n\n    def _set_link_cost_maz(self):\n        \"\"\"Set link cost used in the shortest path forbidden using unavailable connectors.\n\n        Copy the pre-calculated cost @link_cost to @link_cost_maz,\n        setting value to 1e20 on connectors to unused zone leaves / from\n        unused roots.\n        \"\"\"\n        # forbid egress from MAZ nodes which are not demand roots /\n        #        access to MAZ nodes which are not demand leafs\n        net_calc = NetworkCalculator(self.controller.emme_manager, self._scenario)\n        net_calc.add_calc(\"@link_cost_maz\", \"@link_cost\")\n        net_calc.add_calc(\"@link_cost_maz\", \"1e20\", \"@maz_root=0 and !@maz_id=0\")\n        net_calc.add_calc(\"@link_cost_maz\", \"1e20\", \"@maz_leafj=0 and !@maz_idj=0\")\n        net_calc.run()\n\n    @LogStartEnd(level=\"DETAIL\")\n    def _run_shortest_path(self, time: str, bin_no: int, max_radius: float):\n        \"\"\"Run the shortest path tool to generate paths between the marked nodes.\n\n        Args:\n            time: time period name\n            bin_no: bin number (id) for this demand segment\n            max_radius: max unit coordinate distance to limit search tree\n        \"\"\"\n        shortest_paths_tool = self.controller.emme_manager.tool(\n            \"inro.emme.network_calculation.shortest_path\"\n        )\n        max_radius = max_radius * 5280 + 100  # add some buffer for rounding error\n        ext = \"ebp\" if _USE_BINARY else \"txt\"\n        file_name = f\"sp_{time}_{bin_no}.{ext}\"\n\n        spec = {\n            \"type\": \"SHORTEST_PATH\",\n            \"modes\": [self.config.mode_code],\n            \"root_nodes\": \"@maz_root\",\n            \"leaf_nodes\": \"@maz_leaf\",\n            \"link_cost\": \"@link_cost_maz\",\n            \"path_constraints\": {\n                \"max_radius\": max_radius,\n                \"uturn_allowed\": False,\n                \"through_leaves\": False,\n                \"through_centroids\": False,\n                \"exclude_forbidden_turns\": False,\n            },\n            \"results\": {\n                \"skim_output\": {\n                    \"file\": \"\",\n                    \"format\": \"TEXT\",\n                    \"return_numpy\": False,\n                    \"analyses\": [],\n                },\n                \"path_output\": {\n                    \"format\": \"BINARY\" if _USE_BINARY else \"TEXT\",\n                    \"file\": os.path.join(self.eb_dir, file_name),\n                },\n            },\n            \"performance_settings\": {\n                \"number_of_processors\": self.controller.num_processors,\n                \"direction\": \"FORWARD\",\n                \"method\": \"STANDARD\",\n            },\n        }\n        shortest_paths_tool(spec, self._scenario)\n\n    def _assign_flow(\n        self, time: str, bin_no: int, demand: List[Dict[str, Union[float, EmmeNode]]]\n    ):\n        \"\"\"Assign the demand along the paths generated from the shortest path tool.\n\n        Args:\n            time: time period name\n            bin_no: bin number (id) for this demand segment\n            demand: list of dictionaries, containing the demand in the format\n                {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)}\n        \"\"\"\n        if _USE_BINARY:\n            self._assign_flow_binary(time, bin_no, demand)\n        else:\n            self._assign_flow_text(time, bin_no, demand)\n\n    def _assign_flow_text(\n        self, time: str, bin_no: int, demand: List[Dict[str, Union[float, EmmeNode]]]\n    ):\n        \"\"\"Assign the demand along the paths generated from the shortest path tool.\n\n        The paths are read from a text format file, see Emme help for details.\n        Demand is summed in self._network (in memory) using temp_flow attribute\n        and written to scenario (Emmebank / disk) @maz_flow.\n\n        Args:\n            time: time period name\n            bin_no: bin number (id) for this demand segment\n            demand: list of dictionaries, containin the demand in the format\n                {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)}\n        \"\"\"\n        paths = self._load_text_format_paths(time, bin_no)\n        not_assigned, assigned = 0, 0\n        for data in demand:\n            orig, dest, dem = data[\"orig\"].number, data[\"dest\"].number, data[\"dem\"]\n            path = paths.get(orig, {}).get(dest)\n            if path is None:\n                not_assigned += dem\n                continue\n            i_node = orig\n            for j_node in path:\n                link = self._network.link(i_node, j_node)\n                link[\"temp_flow\"] += dem\n                i_node = j_node\n            assigned += dem\n        self.logger.log(f\"ASSIGN bin {bin_no}: total: {len(demand)}\", level=\"DEBUG\")\n        self.logger.log(\n            f\"assigned: {assigned}, not assigned: {not_assigned}\", level=\"DEBUG\"\n        )\n\n        self.controller.emme_manager.copy_attribute_values(\n            self._network, self._scenario, {\"LINK\": [\"temp_flow\"]}, {\"LINK\": [\"data1\"]}\n        )\n\n    def _load_text_format_paths(\n        self, time: str, bin_no: int\n    ) -&gt; Dict[int, Dict[int, List[int]]]:\n        \"\"\"Load all paths from text file and return as nested dictionary.\n\n        Args:\n            time: time period name\n            bin_no: bin number (id) for this demand segment\n\n        Returns:\n            All paths as a nested dictionary, path = paths[origin][destination],\n            using the node IDs as integers.\n        \"\"\"\n        paths = _defaultdict(lambda: {})\n        with open(\n            os.path.join(self.eb_dir, f\"sp_{time}_{bin_no}.txt\"),\n            \"r\",\n            encoding=\"utf8\",\n        ) as paths_file:\n            for line in paths_file:\n                nodes = [int(x) for x in line.split()]\n                paths[nodes[0]][nodes[-1]] = nodes[1:]\n        return paths\n\n    def _assign_flow_binary(\n        self, time: str, bin_no: int, demand: List[Dict[str, Union[float, EmmeNode]]]\n    ):\n        \"\"\"Assign the demand along the paths generated from the shortest path tool.\n\n        The paths are read from a binary format file, see Emme help for details.\n        Demand is summed in self._network (in memory) using temp_flow attribute\n        and written to scenario (Emmebank / disk) @maz_flow.\n\n        Args:\n            time: time period name\n            bin_no: bin number (id) for this demand segment\n            demand: list of dictionaries, containin the demand in the format\n                {\"orig\": EmmeNode, \"dest\": EmmeNode, \"dem\": float (demand value)}\n        \"\"\"\n        file_name = f\"sp_{time}_{bin_no}.ebp\"\n        with open(os.path.join(self.eb_dir, file_name), \"rb\") as paths_file:\n            # read set of path pointers by Orig-Dest sequence from file\n            offset, leaves_nb, path_indicies = self._get_path_indices(paths_file)\n            assigned = 0\n            not_assigned = 0\n            bytes_read = offset * 8\n            # for all orig-dest pairs with demand, load path from file\n            for data in demand:\n                # get file position based on orig-dest index\n                start, end = self._get_path_location(\n                    data[\"orig\"].number, data[\"dest\"].number, leaves_nb, path_indicies\n                )\n                # no path found, disconnected zone\n                if start == end:\n                    not_assigned += data[\"dem\"]\n                    continue\n                paths_file.seek(start * 4 + offset * 8)\n                self._assign_path_flow(paths_file, start, end, data[\"dem\"])\n                assigned += data[\"dem\"]\n                bytes_read += (end - start) * 4\n        self.controller.emme_manager.copy_attribute_values(\n            self._network,\n            self._scenario,\n            {\"LINK\": [\"temp_flow\"]},\n            {\"LINK\": [\"@maz_flow\"]},\n        )\n        self.logger.log(\n            f\"ASSIGN bin {bin_no}, total {len(demand)}, assign \"\n            f\"{assigned}, not assign {not_assigned}, bytes {bytes_read}\",\n            level=\"DEBUG\",\n        )\n\n    @staticmethod\n    def _get_path_indices(paths_file: BinaryIO) -&gt; [int, int, _array.array]:\n        \"\"\"Get the path header indices.\n\n        See the Emme Shortest path tool doc for additional details on reading\n        this file.\n\n        Args:\n            paths_file: binary file access to the generated paths file\n\n        Returns:\n            2 ints + array of ints: offset, leafs_nb, path_indicies\n            offset: starting index to read the paths\n            leafs_nb: number of leafs in the shortest path file\n            path_indicies: array of the start index for each root, leaf path in paths_file.\n        \"\"\"\n        # read first 4 integers from file (Q=64-bit unsigned integers)\n        header = _array.array(\"Q\")\n        header.fromfile(paths_file, 4)\n        roots_nb, leaves_nb = header[2:4]\n        # Load sequence of path indices (positions by orig-dest index),\n        # pointing to list of path node IDs in file\n        path_indicies = _array.array(\"Q\")\n        path_indicies.fromfile(paths_file, roots_nb * leaves_nb + 1)\n        offset = roots_nb * leaves_nb + 1 + 4\n        return offset, leaves_nb, path_indicies\n\n    def _get_path_location(\n        self,\n        orig: EmmeNode,\n        dest: EmmeNode,\n        leaves_nb: int,\n        path_indicies: _array.array,\n    ) -&gt; [int, int]:\n        \"\"\"Get the location in the paths_file to read.\n\n        Args:\n            orig: Emme Node object, origin MAZ to query the path\n            dest: Emme Node object, destination MAZ to query the path\n            leaves_nb: number of leaves\n            path_indicies: array of the start index for each root, leaf path in paths_file.\n\n        Returns:\n            Two integers, start, end\n            start: starting index to read Node ID bytes from paths_file\n            end: ending index to read bytes from paths_file\n        \"\"\"\n        p_index = self._root_index[orig]\n        q_index = self._leaf_index[dest]\n        index = p_index * leaves_nb + q_index\n        start = path_indicies[index]\n        end = path_indicies[index + 1]\n        return start, end\n\n    def _assign_path_flow(\n        self, paths_file: BinaryIO, start: int, end: int, demand: float\n    ):\n        \"\"\"Add demand to link temp_flow for the path.\n\n        Args:\n            paths_file: binary file access to read path from\n            start: starting index to read Node ID bytes from paths_file\n            end: ending index to read bytes from paths_file\n            demand: flow demand to add on link\n        \"\"\"\n        # load sequence of Node IDs which define the path (L=32-bit unsigned integers)\n        path = _array.array(\"L\")\n        path.fromfile(paths_file, end - start)\n        # process path to sequence of links and add flow\n        path_iter = iter(path)\n        i_node = next(path_iter)\n        for j_node in path_iter:\n            link = self._network.link(i_node, j_node)\n            link[\"temp_flow\"] += demand\n            i_node = j_node\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_maz.AssignMAZSPDemand.__init__","title":"<code>__init__(controller)</code>","text":"<p>MAZ-to-MAZ shortest-path highway assignment.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>parent Controller object</p> required Source code in <code>tm2py/components/network/highway/highway_maz.py</code> <pre><code>def __init__(self, controller: RunController):\n    \"\"\"MAZ-to-MAZ shortest-path highway assignment.\n\n    Args:\n        controller: parent Controller object\n    \"\"\"\n\n    super().__init__(controller)\n    self.config = self.controller.config.highway.maz_to_maz\n    self._debug = False\n\n    # bins: performance parameter: crow-fly distance bins\n    #       to limit shortest path calculation by origin to furthest destination\n    #       semi-exposed for performance testing\n    self._bin_edges = _default_bin_edges\n\n    # Lazily-loaded Emme Properties\n    self._highway_emmebank = None\n    self._eb_dir = None\n\n    # Internal attributes to track data through the sequence of steps\n    self._scenario = None\n    self._mazs = None\n    self._demand = _defaultdict(lambda: [])\n    self._max_dist = 0\n    self._network = None\n    self._root_index = None\n    self._leaf_index = None\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_maz.AssignMAZSPDemand.run","title":"<code>run()</code>","text":"<p>Run MAZ-to-MAZ shortest path assignment.</p> Source code in <code>tm2py/components/network/highway/highway_maz.py</code> <pre><code>@LogStartEnd()\ndef run(self):\n    \"\"\"Run MAZ-to-MAZ shortest path assignment.\"\"\"\n\n    county_groups = {}\n    for group in self.config.demand_county_groups:\n        county_groups[group.number] = group.counties\n    for time in self.time_period_names:\n        self._scenario = self.highway_emmebank.scenario(time)\n        with self._setup(time):\n            self._prepare_network()\n            for i, names in county_groups.items():\n                maz_ids = self._get_county_mazs(names)\n                if len(maz_ids) == 0:\n                    self.logger.log(\n                        f\"warning: no mazs for counties {', '.join(names)}\"\n                    )\n                    continue\n                self._process_demand(time, i, maz_ids)\n            demand_bins = self._group_demand()\n            for i, demand_group in enumerate(demand_bins):\n                self._find_roots_and_leaves(demand_group[\"demand\"])\n                self._set_link_cost_maz()\n                self._run_shortest_path(time, i, demand_group[\"dist\"])\n                self._assign_flow(time, i, demand_group[\"demand\"])\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_maz.AssignMAZSPDemand.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate inputs files are correct, raise if an error is found.</p> Source code in <code>tm2py/components/network/highway/highway_maz.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate inputs files are correct, raise if an error is found.\"\"\"\n    # TODO\n    pass\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_maz.SkimMAZCosts","title":"<code>SkimMAZCosts</code>","text":"<p>               Bases: <code>Component</code></p> <p>MAZ-to-MAZ shortest-path skim of time, distance and toll.</p> Source code in <code>tm2py/components/network/highway/highway_maz.py</code> <pre><code>class SkimMAZCosts(Component):\n    \"\"\"MAZ-to-MAZ shortest-path skim of time, distance and toll.\"\"\"\n\n    def __init__(self, controller: RunController):\n        \"\"\"MAZ-to-MAZ shortest-path skim of time, distance and toll.\n\n        Args:\n            controller: parent RunController object\n        \"\"\"\n        super().__init__(controller)\n        self.config = self.controller.config.highway.maz_to_maz\n        # TODO add config requirement that most be a valid time period\n        self._scenario = None\n        self._network = None\n        self._highway_emmebank = None\n\n    @property\n    def highway_emmebank(self):\n        if self._highway_emmebank is None:\n            self._highway_emmebank = self.controller.emme_manager.highway_emmebank\n        return self._highway_emmebank\n\n    @property\n    def scenario(self):\n        if self._scenario is None:\n            self._scenario = self.highway_emmebank.scenario(self.config.skim_period)\n        return self._scenario\n\n    def validate_inputs(self):\n        \"\"\"Validate inputs files are correct, raise if an error is found.\"\"\"\n        # TODO\n        pass\n\n    @LogStartEnd()\n    def run(self):\n        \"\"\"Run shortest path skims for all available MAZ-to-MAZ O-D pairs.\n\n        Runs a shortest path builder for each county, using a maz_skim_cost\n        to limit the search. The valid gen cost (time + cost), distance and toll (drive alone)\n        are written to CSV at the output_skim_file path:\n        FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL\n\n        The following config inputs are used directly in this component. Note also\n        that the network mode_code is prepared in the highway_network component\n        using the excluded_links.\n\n        config.highway.maz_to_maz:\n            skim_period: name of the period used for the skim, must match one the\n                defined config.time_periods\n            demand_county_groups: used for the list of counties, creates a list out\n                of all listed counties under [].counties\n            output_skim_file: relative path to save the skims\n            value_of_time: value of time used to convert tolls and auto operating cost\n            operating_cost_per_mile: auto operating cost\n            max_skim_cost: max cost value used to limit the shortest path search\n            mode_code:\n        \"\"\"\n\n        # prepare output file and write header\n        output = self.get_abs_path(self.config.output_skim_file)\n        os.makedirs(os.path.dirname(output), exist_ok=True)\n        with open(output, \"w\", encoding=\"utf8\") as output_file:\n            output_file.write(\"FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL\\n\")\n        counties = []\n        for group in self.config.demand_county_groups:\n            counties.extend(group.counties)\n        with self._setup():\n            self._prepare_network()\n            for county in counties:\n                num_roots = self._mark_roots(county)\n                if num_roots == 0:\n                    continue\n                sp_values = self._run_shortest_path()\n                self._export_results(sp_values)\n\n    @_context\n    def _setup(self):\n        \"\"\"Creates the temp attributes used in the component.\"\"\"\n        attributes = [\n            (\"LINK\", \"@link_cost\", \"total cost MAZ-MAZ\"),\n            (\"NODE\", \"@maz_root\", \"selected roots (origins)\"),\n        ]\n        with self.controller.emme_manager.temp_attributes_and_restore(\n            self.scenario, attributes\n        ):\n            try:\n                yield\n            finally:\n                self._network = None  # clear network obj ref to free memory\n\n    @LogStartEnd(level=\"DEBUG\")\n    def _prepare_network(self):\n        \"\"\"Calculates the link cost in @link_cost and loads the network to self._network.\"\"\"\n        net_calc = NetworkCalculator(self.controller.emme_manager, self._scenario)\n        if self._scenario.has_traffic_results:\n            time_attr = \"(@free_flow_time.max.timau)\"\n        else:\n            time_attr = \"@free_flow_time\"\n        self.logger.log(f\"Time attribute {time_attr}\", level=\"DEBUG\")\n        vot = self.config.value_of_time\n        op_cost = self.config.operating_cost_per_mile\n        net_calc(\"@link_cost\", f\"{time_attr} + 0.6 / {vot} * (length * {op_cost})\")\n        self._network = self.controller.emme_manager.get_network(\n            self.scenario, {\"NODE\": [\"@maz_id\", \"#node_county\"]}\n        )\n\n    def _mark_roots(self, county: str) -&gt; int:\n        \"\"\"Mark the available roots in the county.\"\"\"\n        count_roots = 0\n        for node in self._network.nodes():\n            if node[\"@maz_id\"] &gt; 0 and node[\"#node_county\"] == county:\n                node[\"@maz_root\"] = node[\"@maz_id\"]\n                count_roots += 1\n            else:\n                node[\"@maz_root\"] = 0\n        values = self._network.get_attribute_values(\"NODE\", [\"@maz_root\"])\n        self.scenario.set_attribute_values(\"NODE\", [\"@maz_root\"], values)\n        return count_roots\n\n    @LogStartEnd(level=\"DETAIL\")\n    def _run_shortest_path(self) -&gt; Dict[str, NumpyArray]:\n        \"\"\"Run shortest paths tool and return dictionary of skim results name, numpy arrays.\n\n        O-D pairs are limited by a max cost value from config.highway.maz_to_maz.max_skim_cost,\n        from roots marked by @maz_root to all available leaves at @maz_id.\n\n        Returns:\n            A dictionary with keys \"COST\", \"DISTANCE\", and \"BRIDGETOLL\", and numpy\n            arrays of SP values for available O-D pairs\n        \"\"\"\n        shortest_paths_tool = self.controller.emme_manager.tool(\n            \"inro.emme.network_calculation.shortest_path\"\n        )\n        max_cost = float(self.config.max_skim_cost)\n        spec = {\n            \"type\": \"SHORTEST_PATH\",\n            \"modes\": [self.config.mode_code],\n            \"root_nodes\": \"@maz_root\",\n            \"leaf_nodes\": \"@maz_id\",\n            \"link_cost\": \"@link_cost\",\n            \"path_constraints\": {\n                \"max_cost\": max_cost,\n                \"uturn_allowed\": False,\n                \"through_leaves\": False,\n                \"through_centroids\": False,\n                \"exclude_forbidden_turns\": False,\n            },\n            \"results\": {\n                \"skim_output\": {\n                    \"return_numpy\": True,\n                    \"analyses\": [\n                        {\n                            \"component\": \"SHORTEST_PATH_COST\",\n                            \"operator\": \"+\",\n                            \"name\": \"COST\",\n                            \"description\": \"\",\n                        },\n                        {\n                            \"component\": \"length\",\n                            \"operator\": \"+\",\n                            \"name\": \"DISTANCE\",\n                            \"description\": \"\",\n                        },\n                        {\n                            \"component\": \"@bridgetoll_da\",\n                            \"operator\": \"+\",\n                            \"name\": \"BRIDGETOLL\",\n                            \"description\": \"\",\n                        },\n                    ],\n                    \"format\": \"OMX\",\n                }\n            },\n            \"performance_settings\": {\n                \"number_of_processors\": self.controller.num_processors,\n                \"direction\": \"FORWARD\",\n                \"method\": \"STANDARD\",\n            },\n        }\n        sp_values = shortest_paths_tool(spec, self.scenario)\n        return sp_values\n\n    def _export_results(self, sp_values: Dict[str, NumpyArray]):\n        \"\"\"Write matrix skims to CSV.\n\n        The matrices are filtered to omit rows for which the COST is\n        &lt; 0 or &gt; 1e19 (Emme uses 1e20 to indicate inaccessible zone pairs).\n\n        sp_values: dictionary of matrix costs, with the three keys\n            \"COST\", \"DISTANCE\", and \"BRIDGETOLL\" and Numpy arrays of values\n        \"\"\"\n        # get list of MAZ IDS\n        roots = [\n            node[\"@maz_root\"] for node in self._network.nodes() if node[\"@maz_root\"]\n        ]\n        leaves = [node[\"@maz_id\"] for node in self._network.nodes() if node[\"@maz_id\"]]\n        # build dataframe with output data and to/from MAZ ids\n        root_ids = np.repeat(roots, len(leaves))\n        leaf_ids = leaves * len(roots)\n        result_df = pd.DataFrame(\n            {\n                \"FROM_ZONE\": root_ids,\n                \"TO_ZONE\": leaf_ids,\n                \"COST\": sp_values[\"COST\"].flatten(),\n                \"DISTANCE\": sp_values[\"DISTANCE\"].flatten(),\n                \"BRIDGETOLL\": sp_values[\"BRIDGETOLL\"].flatten(),\n            }\n        )\n        # drop 0's / 1e20\n        result_df = result_df.query(\"COST &gt; 0 &amp; COST &lt; 1e19\")\n        # write remaining values to text file\n        # FROM_ZONE,TO_ZONE,COST,DISTANCE,BRIDGETOLL\n        output = self.get_abs_path(self.config.output_skim_file)\n        with open(output, \"a\", newline=\"\", encoding=\"utf8\") as output_file:\n            result_df.to_csv(output_file, header=False, index=False)\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_maz.SkimMAZCosts.__init__","title":"<code>__init__(controller)</code>","text":"<p>MAZ-to-MAZ shortest-path skim of time, distance and toll.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>parent RunController object</p> required Source code in <code>tm2py/components/network/highway/highway_maz.py</code> <pre><code>def __init__(self, controller: RunController):\n    \"\"\"MAZ-to-MAZ shortest-path skim of time, distance and toll.\n\n    Args:\n        controller: parent RunController object\n    \"\"\"\n    super().__init__(controller)\n    self.config = self.controller.config.highway.maz_to_maz\n    # TODO add config requirement that most be a valid time period\n    self._scenario = None\n    self._network = None\n    self._highway_emmebank = None\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_maz.SkimMAZCosts.run","title":"<code>run()</code>","text":"<p>Run shortest path skims for all available MAZ-to-MAZ O-D pairs.</p> <p>Runs a shortest path builder for each county, using a maz_skim_cost to limit the search. The valid gen cost (time + cost), distance and toll (drive alone) are written to CSV at the output_skim_file path: FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL</p> <p>The following config inputs are used directly in this component. Note also that the network mode_code is prepared in the highway_network component using the excluded_links.</p> <p>config.highway.maz_to_maz:     skim_period: name of the period used for the skim, must match one the         defined config.time_periods     demand_county_groups: used for the list of counties, creates a list out         of all listed counties under [].counties     output_skim_file: relative path to save the skims     value_of_time: value of time used to convert tolls and auto operating cost     operating_cost_per_mile: auto operating cost     max_skim_cost: max cost value used to limit the shortest path search     mode_code:</p> Source code in <code>tm2py/components/network/highway/highway_maz.py</code> <pre><code>@LogStartEnd()\ndef run(self):\n    \"\"\"Run shortest path skims for all available MAZ-to-MAZ O-D pairs.\n\n    Runs a shortest path builder for each county, using a maz_skim_cost\n    to limit the search. The valid gen cost (time + cost), distance and toll (drive alone)\n    are written to CSV at the output_skim_file path:\n    FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL\n\n    The following config inputs are used directly in this component. Note also\n    that the network mode_code is prepared in the highway_network component\n    using the excluded_links.\n\n    config.highway.maz_to_maz:\n        skim_period: name of the period used for the skim, must match one the\n            defined config.time_periods\n        demand_county_groups: used for the list of counties, creates a list out\n            of all listed counties under [].counties\n        output_skim_file: relative path to save the skims\n        value_of_time: value of time used to convert tolls and auto operating cost\n        operating_cost_per_mile: auto operating cost\n        max_skim_cost: max cost value used to limit the shortest path search\n        mode_code:\n    \"\"\"\n\n    # prepare output file and write header\n    output = self.get_abs_path(self.config.output_skim_file)\n    os.makedirs(os.path.dirname(output), exist_ok=True)\n    with open(output, \"w\", encoding=\"utf8\") as output_file:\n        output_file.write(\"FROM_ZONE, TO_ZONE, COST, DISTANCE, BRIDGETOLL\\n\")\n    counties = []\n    for group in self.config.demand_county_groups:\n        counties.extend(group.counties)\n    with self._setup():\n        self._prepare_network()\n        for county in counties:\n            num_roots = self._mark_roots(county)\n            if num_roots == 0:\n                continue\n            sp_values = self._run_shortest_path()\n            self._export_results(sp_values)\n</code></pre>"},{"location":"api/#tm2py.components.network.highway.highway_maz.SkimMAZCosts.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate inputs files are correct, raise if an error is found.</p> Source code in <code>tm2py/components/network/highway/highway_maz.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate inputs files are correct, raise if an error is found.\"\"\"\n    # TODO\n    pass\n</code></pre>"},{"location":"api/#tm2py.config.HighwayMazToMazConfig.unique_group_numbers","title":"<code>unique_group_numbers(value)</code>","text":"<p>Validate list of demand_county_groups has unique .number values.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"demand_county_groups\")\ndef unique_group_numbers(cls, value):\n    \"\"\"Validate list of demand_county_groups has unique .number values.\"\"\"\n    group_ids = [group.number for group in value]\n    assert len(group_ids) == len(set(group_ids)), \"-&gt; number value must be unique\"\n    return value\n</code></pre>"},{"location":"api/#transit-network-components","title":"Transit Network Components","text":"<p>Transit assignment module.</p> <p>Transit skims module.</p> <p>               Bases: <code>ConfigItem</code></p> <p>Transit mode definition (see also mode in the Emme API).</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TransitModeConfig(ConfigItem):\n    \"\"\"Transit mode definition (see also mode in the Emme API).\"\"\"\n\n    type: Literal[\n        \"WALK\",\n        \"ACCESS\",\n        \"EGRESS\",\n        \"LOCAL\",\n        \"PREMIUM\",\n        \"DRIVE\",\n        \"PNR_dummy\",\n        \"KNR_dummy\",\n    ]\n    assign_type: Literal[\"TRANSIT\", \"AUX_TRANSIT\"]\n    mode_id: str = Field(min_length=1, max_length=1)\n    name: str = Field(max_length=10)\n    description: Optional[str] = \"\"\n    in_vehicle_perception_factor: Optional[float] = Field(default=None, ge=0)\n    speed_or_time_factor: Optional[str] = Field(default=\"\")\n    initial_boarding_penalty: Optional[float] = Field(default=None, ge=0)\n    transfer_boarding_penalty: Optional[float] = Field(default=None, ge=0)\n    headway_fraction: Optional[float] = Field(default=None, ge=0)\n    transfer_wait_perception_factor: Optional[float] = Field(default=None, ge=0)\n    eawt_factor: Optional[float] = Field(default=1)\n\n    @validator(\"in_vehicle_perception_factor\", always=True)\n    def in_vehicle_perception_factor_valid(cls, value, values):\n        \"\"\"Validate in_vehicle_perception_factor exists if assign_type is TRANSIT.\"\"\"\n        if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n            assert value is not None, \"must be specified when assign_type==TRANSIT\"\n        return value\n\n    @validator(\"speed_or_time_factor\", always=True)\n    def speed_or_time_factor_valid(cls, value, values):\n        \"\"\"Validate speed_or_time_factor exists if assign_type is AUX_TRANSIT.\"\"\"\n        if \"assign_type\" in values and values[\"assign_type\"] == \"AUX_TRANSIT\":\n            assert value is not None, \"must be specified when assign_type==AUX_TRANSIT\"\n        return value\n\n    @validator(\"initial_boarding_penalty\", always=True)\n    def initial_boarding_penalty_valid(value, values):\n        \"\"\"Validate initial_boarding_penalty exists if assign_type is TRANSIT.\"\"\"\n        if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n            assert value is not None, \"must be specified when assign_type==TRANSIT\"\n        return value\n\n    @validator(\"transfer_boarding_penalty\", always=True)\n    def transfer_boarding_penalty_valid(value, values):\n        \"\"\"Validate transfer_boarding_penalty exists if assign_type is TRANSIT.\"\"\"\n        if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n            assert value is not None, \"must be specified when assign_type==TRANSIT\"\n        return value\n\n    @validator(\"headway_fraction\", always=True)\n    def headway_fraction_valid(value, values):\n        \"\"\"Validate headway_fraction exists if assign_type is TRANSIT.\"\"\"\n        if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n            assert value is not None, \"must be specified when assign_type==TRANSIT\"\n        return value\n\n    @validator(\"transfer_wait_perception_factor\", always=True)\n    def transfer_wait_perception_factor_valid(value, values):\n        \"\"\"Validate transfer_wait_perception_factor exists if assign_type is TRANSIT.\"\"\"\n        if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n            assert value is not None, \"must be specified when assign_type==TRANSIT\"\n        return value\n\n    @classmethod\n    @validator(\"mode_id\")\n    def mode_id_valid(cls, value):\n        \"\"\"Validate mode_id.\"\"\"\n        assert len(value) == 1, \"mode_id must be one character\"\n        return value\n</code></pre> <p>               Bases: <code>ConfigItem</code></p> <p>Transit assignment parameters.</p> Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass TransitConfig(ConfigItem):\n    \"\"\"Transit assignment parameters.\"\"\"\n\n    modes: Tuple[TransitModeConfig, ...]\n    classes: Tuple[TransitClassConfig, ...]\n    journey_levels: TransitJourneyLevelsConfig\n    apply_msa_demand: bool\n    value_of_time: float\n    walk_speed: float\n    transit_speed: float\n    effective_headway_source: str\n    initial_wait_perception_factor: float\n    transfer_wait_perception_factor: float\n    walk_perception_factor: float\n    walk_perception_factor: float\n    walk_perception_factor_cbd: float\n    drive_perception_factor: float\n    max_transfers: int\n    use_fares: bool\n    fare_2015_to_2000_deflator: float\n    fares_path: pathlib.Path\n    fare_matrix_path: pathlib.Path\n    fare_max_transfer_distance_miles: float\n    override_connector_times: bool\n    use_ccr: bool\n    ccr_stop_criteria: Optional[AssignmentStoppingCriteriaConfig]\n    ccr_weights: CcrWeightsConfig\n    eawt_weights: EawtWeightsConfig\n    congested_transit_assignment: bool\n    congested: CongestedAssnConfig\n    congested_weights: CongestedWeightsConfig\n    output_skim_path: pathlib.Path\n    output_skim_filename_tmpl: str = Field()\n    output_skim_matrixname_tmpl: str = Field()\n    output_stop_usage_path: Optional[str] = Field(default=None)\n    output_transit_boardings_path: Optional[str] = Field(default=None)\n    output_transit_segment_path: Optional[str] = Field(default=None)\n    output_station_to_station_flow_path: Optional[str] = Field(default=None)\n    output_transfer_at_station_path: Optional[str] = Field(default=None)\n    timed_transfer_nodes: Tuple[int, ...] = Field()\n    output_transfer_at_station_node_ids: Dict[str, int] = Field()\n    max_ccr_iterations: float = None\n    split_connectors_to_prevent_walk: bool = False\n    input_connector_access_times_path: Optional[str] = Field(default=None)\n    input_connector_egress_times_path: Optional[str] = Field(default=None)\n    vehicles: Optional[TransitVehicleConfig] = Field(\n        default_factory=TransitVehicleConfig\n    )\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.TransitAssignment","title":"<code>TransitAssignment</code>","text":"<p>               Bases: <code>Component</code></p> <p>Run transit assignment.</p> Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>class TransitAssignment(Component):\n    \"\"\"Run transit assignment.\"\"\"\n\n    def __init__(self, controller: \"RunController\"):\n        \"\"\"Constructor for TransitAssignment.\n\n        Args:\n            controller: RunController object.\n        \"\"\"\n        super().__init__(controller)\n        self.config = self.controller.config.transit\n        self.sub_components = {\n            \"prepare transit demand\": PrepareTransitDemand(controller),\n        }\n        self.transit_network = PrepareTransitNetwork(controller)\n        self._demand_matrix = None  # FIXME\n        self._num_processors = self.controller.emme_manager.num_processors\n        self._time_period = None\n        self._scenario = None\n        self._transit_emmebank = None\n\n    def validate_inputs(self):\n        \"\"\"Validate the inputs.\"\"\"\n        # TODO\n\n    @property\n    def transit_emmebank(self):\n        if not self._transit_emmebank:\n            self._transit_emmebank = self.controller.emme_manager.transit_emmebank\n        return self._transit_emmebank\n\n    @LogStartEnd(\"Transit assignments\")\n    def run(self):\n        \"\"\"Run transit assignments.\"\"\"\n\n        if self.controller.iteration == 0:\n            self.transit_emmebank.create_zero_matrix()\n            if self.controller.config.warmstart.warmstart:\n                if self.controller.config.warmstart.use_warmstart_demand:\n                    self.sub_components[\"prepare transit demand\"].run()\n            else:\n                # give error message to user about not warmstarting transit\n                raise Exception(\n                    f\"ERROR: transit has to be warmstarted, please either specify use_warmstart_skim or use_warmstart_demand\"\n                )\n        else:\n            self.sub_components[\"prepare transit demand\"].run()\n\n        for time_period in self.time_period_names:\n            # update auto times\n            print(\"updating auto time in transit network\")\n            self.transit_network.update_auto_times(time_period)\n\n            if self.controller.iteration == 0:\n                # iteration = 0 : run uncongested transit assignment\n                use_ccr = False\n                congested_transit_assignment = False\n                print(\"running uncongested transit assignment with warmstart demand\")\n                self.run_transit_assign(\n                    time_period, use_ccr, congested_transit_assignment\n                )\n            elif (self.controller.iteration == 1) &amp; (self.controller.config.warmstart.use_warmstart_skim):\n                # iteration = 1 and use_warmstart_skim = True : run uncongested transit assignment\n                use_ccr = False\n                congested_transit_assignment = False\n                self.run_transit_assign(\n                    time_period, use_ccr, congested_transit_assignment\n                )               \n            else:\n                # iteration &gt;= 1 and use_warmstart_skim = False : run congested transit assignment\n                use_ccr = self.config.use_ccr\n                if time_period in [\"EA\", \"EV\", \"MD\"]:\n                    congested_transit_assignment = False\n                else:\n                    congested_transit_assignment = (\n                        self.config.congested_transit_assignment\n                    )\n\n                self.run_transit_assign(\n                    time_period, use_ccr, congested_transit_assignment\n                )\n\n            # output_summaries\n            if self.config.output_stop_usage_path is not None:\n                network, class_stop_attrs = self._calc_connector_flows(time_period)\n                self._export_connector_flows(network, class_stop_attrs, time_period)\n            if self.controller.iteration == self.controller.config.run.end_iteration:\n                if self.config.output_transit_boardings_path is not None:\n                    self._export_boardings_by_line(time_period)\n                if self.config.output_transit_segment_path is not None:\n                    self._export_transit_segment(time_period)\n                if self.config.output_station_to_station_flow_path is not None:\n                    self._export_boardings_by_station(time_period)\n                if self.config.output_transfer_at_station_path is not None:\n                    self._export_transfer_at_stops(time_period)\n\n    @LogStartEnd(\"Transit assignments for a time period\")\n    def run_transit_assign(\n        self, time_period: str, use_ccr: bool, congested_transit_assignment: bool\n    ):\n        if use_ccr:\n            self._run_ccr_assign(time_period)\n        elif congested_transit_assignment:\n            self._run_congested_assign(time_period)\n        else:\n            self._run_extended_assign(time_period)\n\n    def _apply_peaking_factor(self, time_period: str, ea_df=None):\n        \"\"\"apply peaking factors.\n\n        Args:\n            time_period: time period name abbreviation\n        \"\"\"\n        _emme_scenario = self.transit_emmebank.scenario(time_period)\n        _network = _emme_scenario.get_network()\n        _duration = self.time_period_durations[time_period.lower()]\n\n        if time_period.lower() == \"am\":\n            for line in _network.transit_lines():\n                line[\"@orig_hdw\"] = line.headway\n                line_name = line.id\n                line_veh = line.vehicle\n                line_hdw = line.headway\n                line_cap = 60 * _duration * line_veh.total_capacity / line_hdw\n                if line_name in ea_df[\"line_name_am\"].to_list():\n                    ea_boardings = ea_df.loc[\n                        ea_df[\"line_name_am\"] == line_name, \"boardings\"\n                    ].values[0]\n                else:\n                    ea_boardings = 0\n                pnr_peaking_factor = (\n                    line_cap - ea_boardings\n                ) / line_cap  # substract ea boardings from am parking capacity\n                non_pnr_peaking_factor = self.config.congested.am_peaking_factor\n                # in Emme transit assignment, the capacity is computed for each transit line as: 60 * _duration * vehicle.total_capacity / line.headway\n                # so instead of applying peaking factor to calculated capacity, we can divide line.headway by this peaking factor\n                # if ea number of parkers exceed the am parking capacity, set the headway to a very large number\n                if pnr_peaking_factor &gt; 0:\n                    pnr_line_hdw = line_hdw / pnr_peaking_factor\n                else:\n                    pnr_line_hdw = 999\n                non_pnr_line_hdw = line_hdw * non_pnr_peaking_factor\n                if (\"pnr\" in line_name) and (\"egr\" in line_name):\n                    continue\n                elif (\"pnr\" in line_name) and (\"acc\" in line_name):\n                    line.headway = pnr_line_hdw\n                else:\n                    line.headway = non_pnr_line_hdw\n\n        if time_period.lower() == \"pm\":\n            for line in _network.transit_lines():\n                line[\"@orig_hdw\"] = line.headway\n                line_name = line.id\n                line_hdw = line.headway\n                non_pnr_peaking_factor = self.config.congested.pm_peaking_factor\n                non_pnr_line_hdw = line_hdw * non_pnr_peaking_factor\n                if \"pnr\" in line_name:\n                    continue\n                else:\n                    line.headway = non_pnr_line_hdw\n\n        if time_period.lower() == \"ea\":\n            line_name = []\n            boards = []\n            ea_pnr_df = pd.DataFrame()\n            for line in _network.transit_lines():\n                boardings = 0\n                for segment in line.segments(include_hidden=True):\n                    boardings += segment.transit_boardings\n                line_name.append(line.id)\n                boards.append(boardings)\n            ea_pnr_df[\"line_name\"] = line_name\n            ea_pnr_df[\"boardings\"] = boards\n            ea_pnr_df[\"line_name_am\"] = ea_pnr_df[\"line_name\"].str.replace(\n                \"EA\", \"AM\"\n            )  # will substract ea boardings from am parking capacity\n            path_boardings = self.get_abs_path(\n                self.config.output_transit_boardings_path\n            )\n            ea_pnr_df.to_csv(path_boardings.format(period=\"ea_pnr\"), index=False)\n\n        _update_attributes = {\"TRANSIT_LINE\": [\"@orig_hdw\", \"headway\"]}\n        self.controller.emme_manager.copy_attribute_values(\n            _network, _emme_scenario, _update_attributes\n        )\n\n    def _transit_classes(self, time_period) -&gt; List[TransitAssignmentClass]:\n        emme_manager = self.controller.emme_manager\n        if self.config.use_fares:\n            fare_modes = _defaultdict(lambda: set([]))\n            network = self.transit_emmebank.scenario(time_period).get_partial_network(\n                [\"TRANSIT_LINE\"], include_attributes=False\n            )\n            emme_manager.copy_attribute_values(\n                self.transit_emmebank.scenario(time_period),\n                network,\n                {\"TRANSIT_LINE\": [\"#src_mode\"]},\n            )\n            for line in network.transit_lines():\n                fare_modes[line[\"#src_mode\"]].add(line.mode.id)\n        else:\n            fare_modes = None\n        spec_dir = os.path.join(\n            self.get_abs_path(\n                os.path.dirname(self.controller.config.emme.project_path)\n            ),\n            \"Specifications\",\n        )\n        transit_classes = []\n        for class_config in self.config.classes:\n            transit_classes.append(\n                TransitAssignmentClass(\n                    class_config,\n                    self.config,\n                    time_period,\n                    self.controller.iteration,\n                    self._num_processors,\n                    fare_modes,\n                    spec_dir,\n                )\n            )\n        return transit_classes\n\n    def _run_ccr_assign(self, time_period: str) -&gt; None:\n        \"\"\"Runs capacity constrained (??) CCR transit assignment for a time period + update penalties.\n\n        Args:\n            time_period: time period name\n        \"\"\"\n        _duration = self.time_period_durations[time_period.lower()]\n        _ccr_weights = self.config.ccr_weights\n        _eawt_weights = self.config.eawt_weights\n        _mode_config = {\n            mode_config.mode_id: mode_config for mode_config in self.config.modes\n        }\n        _emme_scenario = self.transit_emmebank.scenario(time_period)\n        transit_classes = self._transit_classes(time_period)\n\n        assign_transit = self.controller.emme_manager.tool(\n            \"inro.emme.transit_assignment.capacitated_transit_assignment\"\n        )\n        _tclass_specs = [tclass.emme_transit_spec for tclass in transit_classes]\n        _tclass_names = [tclass.name for tclass in transit_classes]\n\n        _cost_func = {\n            \"segment\": {\n                \"type\": \"CUSTOM\",\n                \"python_function\": func_returns_crowded_segment_cost(\n                    _duration, _ccr_weights\n                ),\n                \"congestion_attribute\": \"us3\",\n                \"orig_func\": False,\n            },\n            \"headway\": {\n                \"type\": \"CUSTOM\",\n                \"python_function\": func_returns_calc_updated_perceived_headway(\n                    _duration,\n                    _eawt_weights,\n                    _mode_config,\n                    use_fares=self.config.use_fares,\n                )\n                + \"\\n\"\n                + textwrap.dedent(inspect.getsource(calc_extra_wait_time))\n                + \"\\n\"\n                + textwrap.dedent(inspect.getsource(calc_adjusted_headway))\n                + \"\\n\"\n                + textwrap.dedent(inspect.getsource(calc_total_offs))\n                + \"\\n\"\n                + textwrap.dedent(inspect.getsource(calc_offs_thru_segment)),\n            },\n            \"assignment_period\": _duration,\n        }\n\n        _stop_criteria = {\n            \"max_iterations\": self.config.ccr_stop_criteria.max_iterations,\n            \"relative_difference\": self.config.ccr_stop_criteria.relative_difference,\n            \"percent_segments_over_capacity\": self.config.ccr_stop_criteria.percent_segments_over_capacity,\n        }\n        add_volumes = False\n        assign_transit(\n            _tclass_specs,\n            congestion_function=_cost_func,\n            stopping_criteria=_stop_criteria,\n            class_names=_tclass_names,\n            scenario=_emme_scenario,\n            log_worksheets=False,\n        )\n        add_volumes = True\n\n        # question - why do we need to do this between iterations AND ALSO give it to the EMME cost function? Does EMME not use it?\n        self._calc_segment_ccr_penalties(time_period)\n\n    def _run_congested_assign(self, time_period: str) -&gt; None:\n        \"\"\"Runs congested transit assignment for a time period.\n\n        Args:\n            time_period: time period name\n        \"\"\"\n        _duration = self.time_period_durations[time_period.lower()]\n        _congested_weights = self.config.congested_weights\n        _emme_scenario = self.transit_emmebank.scenario(time_period)\n        transit_classes = self._transit_classes(time_period)\n\n        assign_transit = self.controller.emme_manager.tool(\n            \"inro.emme.transit_assignment.congested_transit_assignment\"\n        )\n        _tclass_specs = [tclass.emme_transit_spec for tclass in transit_classes]\n        _tclass_names = [tclass.name for tclass in transit_classes]\n\n        _cost_func = {\n            \"type\": \"CUSTOM\",\n            \"python_function\": func_returns_segment_congestion(\n                _duration,\n                _emme_scenario,\n                _congested_weights,\n                use_fares=self.config.use_fares,\n            ),\n            \"congestion_attribute\": \"us3\",\n            \"orig_func\": False,\n            \"assignment_period\": _duration,\n        }\n\n        stop_criteria_settings = self.config.congested.stop_criteria\n        # get the corresponding stop criteria for the global iteration\n        _stop_criteria = None\n        for item in stop_criteria_settings:\n            if item[\"global_iteration\"] == self.controller.iteration:\n                _stop_criteria = {\n                    \"max_iterations\": [\n                        time.max_iteration\n                        for time in item.max_iterations\n                        if time.time_period.lower() == time_period.lower()\n                    ][0],\n                    \"normalized_gap\": item.normalized_gap,\n                    \"relative_gap\": item.relative_gap,\n                }\n        if _stop_criteria is None:\n            raise ValueError(\n                f\"transit.congested.stop_criteria: Must specifify stop criteria for global iteration {self.controller.iteration}\"\n            )\n        add_volumes = False\n        assign_transit(\n            _tclass_specs,\n            congestion_function=_cost_func,\n            stopping_criteria=_stop_criteria,\n            class_names=_tclass_names,\n            scenario=_emme_scenario,\n            log_worksheets=False,\n        )\n        add_volumes = True\n\n    def _run_extended_assign(self, time_period: str) -&gt; None:\n        \"\"\"Run transit assignment without CCR.\n\n        Args:\n            time_period (_type_): time period name\n        \"\"\"\n        assign_transit = self.controller.emme_manager.modeller.tool(\n            \"inro.emme.transit_assignment.extended_transit_assignment\"\n        )\n        _emme_scenario = self.transit_emmebank.scenario(time_period)\n\n        # Question for INRO: Why are we only adding subsequent volumes shouldn't it assume to be\n        #   zero to begin with?\n        # Question for INRO: Can this function be distributed across machines? If so, how would\n        #   that be structured?\n        add_volumes = False\n        for tclass in self._transit_classes(time_period):\n            assign_transit(\n                tclass.emme_transit_spec,\n                class_name=tclass.name,\n                add_volumes=add_volumes,\n                scenario=_emme_scenario,\n            )\n            add_volumes = True\n\n    def _get_network_with_boardings(\n        self, emme_scenario: \"EmmeScenario\"\n    ) -&gt; \"EmmeNetwork\":\n        \"\"\"Get networkw ith transit boardings by line and segment.\n\n        Args:\n            emme_scenario (_type_):\n\n        Returns:\n            EmmeNetwork: with transit boardings by line and segment.\n        \"\"\"\n        network = emme_scenario.get_partial_network(\n            [\"TRANSIT_LINE\", \"TRANSIT_SEGMENT\"], include_attributes=False\n        )\n        _attributes = {\n            \"TRANSIT_LINE\": [\"description\", \"#src_mode\"],\n            \"TRANSIT_SEGMENT\": [\"transit_boardings\"],\n        }\n        _emme_manager = self.controller.emme_manager\n        _emme_manager.copy_attribute_values(emme_scenario, network, _attributes)\n        return network\n\n    def _export_boardings_by_line(self, time_period: str) -&gt; None:\n        \"\"\"Export total boardings by line to config.transit.output_transit_boardings_file.\n\n        args:\n            time_period (str): time period abbreviation\n        \"\"\"\n        _emme_scenario = self.transit_emmebank.scenario(time_period)\n        network = _emme_scenario.get_network()\n\n        output_transit_boardings_file = self.get_abs_path(\n            self.config.output_transit_boardings_path\n        )\n\n        os.makedirs(os.path.dirname(output_transit_boardings_file), exist_ok=True)\n\n        with open(\n            output_transit_boardings_file.format(period=time_period.lower()),\n            \"w\",\n            encoding=\"utf8\",\n        ) as out_file:\n            out_file.write(\n                \",\".join(\n                    [\n                        \"line_name\",\n                        \"description\",\n                        \"total_boarding\",\n                        \"total_hour_cap\",\n                        \"tm2_mode\",\n                        \"line_mode\",\n                        \"headway\",\n                        \"fare_system\",\n                    ]\n                )\n            )\n            out_file.write(\"\\n\")\n            for line in network.transit_lines():\n                boardings = 0\n                capacity = line.vehicle.total_capacity\n                hdw = line.headway\n                line_hour_cap = 60 * capacity / hdw\n                if self.config.use_fares:\n                    mode = line[\"#src_mode\"]\n                else:\n                    mode = line.mode\n                for segment in line.segments(include_hidden=True):\n                    boardings += segment.transit_boardings\n                out_file.write(\n                    \",\".join(\n                        [\n                            str(x)\n                            for x in [\n                                line.id,\n                                line[\"#description\"],\n                                boardings,\n                                line_hour_cap,\n                                line[\"#mode\"],\n                                mode,\n                                line.headway,\n                                line[\"#faresystem\"],\n                            ]\n                        ]\n                    )\n                )\n                out_file.write(\"\\n\")\n\n    def _calc_connector_flows(\n        self, time_period: str\n    ) -&gt; Tuple[\"EmmeNetwork\", Dict[str, str]]:\n        \"\"\"Calculate boardings and alightings by assignment class.\n\n        args:\n            time_period (str): time period abbreviation\n\n        returns:\n            EmmeNetwork with aux_transit_volumes\n            transit class stop attributes: {&lt;transit_class_name&gt;: @aux_volume_&lt;transit_class_name&gt;...}\n        \"\"\"\n        _emme_manager = self.controller.emme_manager\n        _emme_scenario = self.transit_emmebank.scenario(time_period)\n        network_results = _emme_manager.tool(\n            \"inro.emme.transit_assignment.extended.network_results\"\n        )\n        create_extra = _emme_manager.tool(\n            \"inro.emme.data.extra_attribute.create_extra_attribute\"\n        )\n        tclass_stop_attrs = {}\n        for tclass in self.config.classes:\n            attr_name = f\"@aux_vol_{tclass.name}\".lower()  # maximum length 20 limit\n            create_extra(\"LINK\", attr_name, overwrite=True, scenario=_emme_scenario)\n            spec = {\n                \"type\": \"EXTENDED_TRANSIT_NETWORK_RESULTS\",\n                \"on_links\": {\"aux_transit_volumes\": attr_name},\n            }\n            network_results(spec, class_name=tclass.name, scenario=_emme_scenario)\n            tclass_stop_attrs[tclass.name] = attr_name\n\n        # optimization: partial network to only load links and certain attributes\n        network = _emme_scenario.get_partial_network([\"LINK\"], include_attributes=True)\n        attributes = {\n            \"LINK\": tclass_stop_attrs.values(),\n            \"NODE\": [\"@taz_id\", \"#node_id\"],\n        }\n        _emme_manager.copy_attribute_values(_emme_scenario, network, attributes)\n        return network, tclass_stop_attrs\n\n    def _export_connector_flows(\n        self, network: EmmeNetwork, class_stop_attrs: Dict[str, str], time_period: str\n    ):\n        \"\"\"Export boardings and alightings by assignment class, stop(connector) and TAZ.\n\n        args:\n            network: network to use\n            class_stop_attrs: list of attributes to export\n        \"\"\"\n        path_tmplt = self.get_abs_path(self.config.output_stop_usage_path)\n        os.makedirs(os.path.dirname(path_tmplt), exist_ok=True)\n        with open(\n            path_tmplt.format(period=time_period.lower()), \"w\", encoding=\"utf8\"\n        ) as out_file:\n            out_file.write(\",\".join([\"mode\", \"taz\", \"stop\", \"boardings\", \"alightings\"]))\n            out_file.write(\"\\n\")\n            for zone in network.centroids():\n                taz_id = int(zone[\"@taz_id\"])\n                for link in zone.outgoing_links():\n                    stop_id = link.j_node[\"#node_id\"]\n                    for name, attr_name in class_stop_attrs.items():\n                        alightings = (\n                            link.reverse_link[attr_name] if link.reverse_link else 0.0\n                        )\n                        out_file.write(\n                            f\"{name}, {taz_id}, {stop_id}, {link[attr_name]}, {alightings}\\n\"\n                        )\n                for link in zone.incoming_links():\n                    if link.reverse_link:  # already exported\n                        continue\n                    stop_id = link.i_node[\"#node_id\"]\n                    for name, attr_name in class_stop_attrs.items():\n                        out_file.write(\n                            f\"{name}, {taz_id}, {stop_id}, 0.0, {link[attr_name]}\\n\"\n                        )\n\n    def _export_transit_segment(self, time_period: str):\n        # add total boardings by access mode\n        _emme_manager = self.controller.emme_manager\n        _emme_scenario = self.transit_emmebank.scenario(time_period)\n        network_results = _emme_manager.tool(\n            \"inro.emme.transit_assignment.extended.network_results\"\n        )\n        create_extra = _emme_manager.tool(\n            \"inro.emme.data.extra_attribute.create_extra_attribute\"\n        )\n        for tclass in self.config.classes:\n            initial_board_attr_name = f\"@iboard_{tclass.name}\".lower()\n            direct_xboard_attr_name = f\"@dboard_{tclass.name}\".lower()\n            auxiliary_xboard_attr_name = f\"@aboard_{tclass.name}\".lower()\n            create_extra(\n                \"TRANSIT_SEGMENT\",\n                initial_board_attr_name,\n                overwrite=True,\n                scenario=_emme_scenario,\n            )\n            create_extra(\n                \"TRANSIT_SEGMENT\",\n                direct_xboard_attr_name,\n                overwrite=True,\n                scenario=_emme_scenario,\n            )\n            create_extra(\n                \"TRANSIT_SEGMENT\",\n                auxiliary_xboard_attr_name,\n                overwrite=True,\n                scenario=_emme_scenario,\n            )\n            spec = {\n                \"type\": \"EXTENDED_TRANSIT_NETWORK_RESULTS\",\n                \"on_segments\": {\n                    \"initial_boardings\": initial_board_attr_name,\n                    \"transfer_boardings_direct\": direct_xboard_attr_name,\n                    \"transfer_boardings_indirect\": auxiliary_xboard_attr_name,\n                },\n            }\n            network_results(spec, class_name=tclass.name, scenario=_emme_scenario)\n\n        network = _emme_scenario.get_network()\n        path_boardings = self.get_abs_path(self.config.output_transit_segment_path)\n        with open(path_boardings.format(period=time_period.lower()), \"w\") as f:\n            f.write(\n                \",\".join(\n                    [\n                        \"line\",\n                        \"stop_name\",\n                        \"i_node\",\n                        \"j_node\",\n                        \"dwt\",\n                        \"ttf\",\n                        \"voltr\",\n                        \"board\",\n                        \"con_time\",\n                        \"uncon_time\",\n                        \"mode\",\n                        \"src_mode\",\n                        \"mdesc\",\n                        \"hdw\",\n                        \"orig_hdw\",\n                        \"speed\",\n                        \"vauteq\",\n                        \"vcaps\",\n                        \"vcapt\",\n                        \"initial_board_ptw\",\n                        \"initial_board_wtp\",\n                        \"initial_board_ktw\",\n                        \"initial_board_wtk\",\n                        \"initial_board_wtw\",\n                        \"direct_transfer_board_ptw\",\n                        \"direct_transfer_board_wtp\",\n                        \"direct_transfer_board_ktw\",\n                        \"direct_transfer_board_wtk\",\n                        \"direct_transfer_board_wtw\",\n                        \"auxiliary_transfer_board_ptw\",\n                        \"auxiliary_transfer_board_wtp\",\n                        \"auxiliary_transfer_board_ktw\",\n                        \"auxiliary_transfer_board_wtk\",\n                        \"auxiliary_transfer_board_wtw\",\n                    ]\n                )\n            )\n            f.write(\"\\n\")\n\n            for line in network.transit_lines():\n                for segment in line.segments(include_hidden=True):\n                    if self.config.use_fares:\n                        mode = segment.line[\"#src_mode\"]\n                    else:\n                        mode = segment.line.mode\n                    if self.config.congested.use_peaking_factor and (\n                        time_period.lower() in [\"am\", \"pm\"]\n                    ):\n                        orig_headway = segment.line[\"@orig_hdw\"]\n                    else:\n                        orig_headway = segment.line.headway\n                    f.write(\n                        \",\".join(\n                            [\n                                str(x)\n                                for x in [\n                                    segment.id,\n                                    '\"{0}\"'.format(segment[\"#stop_name\"]),\n                                    segment.i_node,\n                                    segment.j_node,\n                                    segment.dwell_time,\n                                    segment.transit_time_func,\n                                    segment.transit_volume,\n                                    segment.transit_boardings,\n                                    segment.transit_time,\n                                    segment[\"@trantime_seg\"],\n                                    segment.line.mode,\n                                    mode,\n                                    segment.line.mode.description,\n                                    segment.line.headway,\n                                    orig_headway,\n                                    segment.line.speed,\n                                    segment.line.vehicle.auto_equivalent,\n                                    segment.line.vehicle.seated_capacity,\n                                    segment.line.vehicle.total_capacity,\n                                    segment[\"@iboard_pnr_trn_wlk\"],\n                                    segment[\"@iboard_wlk_trn_pnr\"],\n                                    segment[\"@iboard_knr_trn_wlk\"],\n                                    segment[\"@iboard_wlk_trn_knr\"],\n                                    segment[\"@iboard_wlk_trn_wlk\"],\n                                    segment[\"@dboard_pnr_trn_wlk\"],\n                                    segment[\"@dboard_wlk_trn_pnr\"],\n                                    segment[\"@dboard_knr_trn_wlk\"],\n                                    segment[\"@dboard_wlk_trn_knr\"],\n                                    segment[\"@dboard_wlk_trn_wlk\"],\n                                    segment[\"@aboard_pnr_trn_wlk\"],\n                                    segment[\"@aboard_wlk_trn_pnr\"],\n                                    segment[\"@aboard_knr_trn_wlk\"],\n                                    segment[\"@aboard_wlk_trn_knr\"],\n                                    segment[\"@aboard_wlk_trn_wlk\"],\n                                ]\n                            ]\n                        )\n                    )\n                    f.write(\"\\n\")\n\n    def _export_boardings_by_station(self, time_period: str):\n        _emme_manager = self.controller.emme_manager\n        _emme_scenario = self.transit_emmebank.scenario(time_period)\n        network = _emme_scenario.get_network()\n        sta2sta = _emme_manager.tool(\n            \"inro.emme.transit_assignment.extended.station_to_station_analysis\"\n        )\n        sta2sta_spec = {\n            \"type\": \"EXTENDED_TRANSIT_STATION_TO_STATION_ANALYSIS\",\n            \"transit_line_selections\": {\n                \"first_boarding\": \"mode=h\",\n                \"last_alighting\": \"mode=h\",\n            },\n            \"analyzed_demand\": None,\n        }\n\n        # map to used modes in apply fares case\n        fare_modes = _defaultdict(lambda: set([]))\n        for line in network.transit_lines():\n            if self.config.use_fares:\n                fare_modes[line[\"#src_mode\"]].add(line.mode.id)\n            else:\n                fare_modes[line.mode.id].add(line.mode.id)\n\n        operator_dict = {\n            # mode: network_selection\n            \"bart\": \"h\",\n            \"caltrain\": \"r\",\n        }\n\n        for tclass in self.config.classes:\n            for op, cut in operator_dict.items():\n                demand_matrix = \"mfTRN_%s_%s\" % (tclass.name, time_period)\n                output_file_name = self.get_abs_path(\n                    self.config.output_station_to_station_flow_path\n                )\n\n                sta2sta_spec[\"transit_line_selections\"][\"first_boarding\"] = (\n                    \"mode=\" + \",\".join(list(fare_modes[cut]))\n                )\n                sta2sta_spec[\"transit_line_selections\"][\"last_alighting\"] = (\n                    \"mode=\" + \",\".join(list(fare_modes[cut]))\n                )\n                sta2sta_spec[\"analyzed_demand\"] = demand_matrix\n\n                output_path = output_file_name.format(\n                    operator=op, tclass=tclass.name, period=time_period.lower()\n                )\n                sta2sta(\n                    specification=sta2sta_spec,\n                    output_file=output_path,\n                    scenario=_emme_scenario,\n                    append_to_output_file=False,\n                    class_name=tclass.name,\n                )\n\n    def _export_transfer_at_stops(self, time_period: str):\n        _emme_manager = self.controller.emme_manager\n        _emme_scenario = self.transit_emmebank.scenario(time_period)\n        network = _emme_scenario.get_network()\n        transfers_at_stops = _emme_manager.tool(\n            \"inro.emme.transit_assignment.extended.apps.transfers_at_stops\"\n        )\n\n        stop_location = self.config.output_transfer_at_station_node_ids\n        stop_location_val_key = {val: key for key, val in stop_location.items()}\n\n        for node in network.nodes():\n            if stop_location_val_key.get(node[\"#node_id\"]):\n                stop_location[stop_location_val_key[node[\"#node_id\"]]] = node.id\n\n        for tclass in self.config.classes:\n            for stop_name, stop_id in stop_location.items():\n                demand_matrix = \"mfTRN_%s_%s\" % (tclass.name, time_period)\n                output_file_name = self.get_abs_path(\n                    self.config.output_transfer_at_station_path\n                )\n                output_path = output_file_name.format(\n                    tclass=tclass.name, stop=stop_name, period=time_period.lower()\n                )\n\n                transfers_at_stops(\n                    selection=f\"i={stop_id}\",\n                    export_path=output_path,\n                    scenario=_emme_scenario,\n                    class_name=tclass.name,\n                    analyzed_demand=demand_matrix,\n                )\n\n    def _add_ccr_vars_to_scenario(self, emme_scenario: \"EmmeScenario\") -&gt; None:\n        \"\"\"Add Extra Added Wait Time and Capacity Penalty to emme scenario.\n\n        Args:\n            emme_scenario : EmmeScenario\n        \"\"\"\n        create_extra = self.controller.emme_manager.tool(\n            \"inro.emme.data.extra_attribute.create_extra_attribute\"\n        )\n        create_extra(\n            \"TRANSIT_SEGMENT\",\n            \"@eawt\",\n            \"extra added wait time\",\n            overwrite=True,\n            scenario=emme_scenario,\n        )\n        create_extra(\n            \"TRANSIT_SEGMENT\",\n            \"@capacity_penalty\",\n            \"capacity penalty at boarding\",\n            overwrite=True,\n            scenario=emme_scenario,\n        )\n\n    def _get_network_with_ccr_scenario_attributes(self, emme_scenario):\n        self._add_ccr_vars_to_scenario(emme_scenario)\n\n        _attributes = {\n            \"TRANSIT_SEGMENT\": [\n                \"@phdwy\",\n                \"transit_volume\",\n                \"transit_boardings\",\n            ],\n            \"TRANSIT_VEHICLE\": [\"seated_capacity\", \"total_capacity\"],\n            \"TRANSIT_LINE\": [\"headway\"],\n        }\n        if self.config.use_fares:\n            _attributes[\"TRANSIT_LINE\"].append(\"#src_mode\")\n\n        # load network object from scenario (on disk) and copy some attributes\n        network = emme_scenario.get_partial_network(\n            [\"TRANSIT_SEGMENT\"], include_attributes=False\n        )\n        network.create_attribute(\"TRANSIT_LINE\", \"capacity\")\n\n        self.emme_manager.copy_attribute_values(emme_scenario, network, _attributes)\n        return network\n\n    def _calc_segment_ccr_penalties(self, time_period):\n        \"\"\"Calculate extra average wait time (@eawt) and @capacity_penalty on the segments.\n\n        TODO: INRO Please document\n\n\n        \"\"\"\n        _emme_scenario = self.transit_emmebank.scenario(time_period)\n        _network = self._get_network_with_ccr_scenario_attributes(_emme_scenario)\n\n        _eawt_weights = self.config.eawt_weights\n        _mode_config = {\n            mode_config.mode_id: mode_config for mode_config in self.config.modes\n        }\n\n        _duration = self.time_period_durations[time_period.lower()]\n        for line in _network.transit_lines():\n            line.capacity = time_period_capacity(\n                line.vehicle.total_capacity, line.headway, _duration\n            )\n\n        # QUESTION: document origin of this param.\n        _hdwy_fraction = 0.5  # fixed in assignment spec\n        for segment in _network.transit_segments():\n            segment[\"@eawt\"] = calc_extra_wait_time(\n                segment,\n                segment.line.capacity,\n                _eawt_weights,\n                _mode_config,\n                use_fares=self.config.use_fares,\n            )\n            segment[\"@capacity_penalty\"] = (\n                max(segment[\"@phdwy\"] - segment[\"@eawt\"] - segment.line.headway, 0)\n                * _hdwy_fraction\n            )\n        # copy (save) results back from the network to the scenario (on disk)\n        _ccr_attributes = {\"TRANSIT_SEGMENT\": [\"@eawt\", \"@capacity_penalty\"]}\n        self.emme_manager.copy_attribute_values(\n            _network, _emme_scenario, _ccr_attributes\n        )\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.TransitAssignment.__init__","title":"<code>__init__(controller)</code>","text":"<p>Constructor for TransitAssignment.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>'RunController'</code> <p>RunController object.</p> required Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>def __init__(self, controller: \"RunController\"):\n    \"\"\"Constructor for TransitAssignment.\n\n    Args:\n        controller: RunController object.\n    \"\"\"\n    super().__init__(controller)\n    self.config = self.controller.config.transit\n    self.sub_components = {\n        \"prepare transit demand\": PrepareTransitDemand(controller),\n    }\n    self.transit_network = PrepareTransitNetwork(controller)\n    self._demand_matrix = None  # FIXME\n    self._num_processors = self.controller.emme_manager.num_processors\n    self._time_period = None\n    self._scenario = None\n    self._transit_emmebank = None\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.TransitAssignment.run","title":"<code>run()</code>","text":"<p>Run transit assignments.</p> Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>@LogStartEnd(\"Transit assignments\")\ndef run(self):\n    \"\"\"Run transit assignments.\"\"\"\n\n    if self.controller.iteration == 0:\n        self.transit_emmebank.create_zero_matrix()\n        if self.controller.config.warmstart.warmstart:\n            if self.controller.config.warmstart.use_warmstart_demand:\n                self.sub_components[\"prepare transit demand\"].run()\n        else:\n            # give error message to user about not warmstarting transit\n            raise Exception(\n                f\"ERROR: transit has to be warmstarted, please either specify use_warmstart_skim or use_warmstart_demand\"\n            )\n    else:\n        self.sub_components[\"prepare transit demand\"].run()\n\n    for time_period in self.time_period_names:\n        # update auto times\n        print(\"updating auto time in transit network\")\n        self.transit_network.update_auto_times(time_period)\n\n        if self.controller.iteration == 0:\n            # iteration = 0 : run uncongested transit assignment\n            use_ccr = False\n            congested_transit_assignment = False\n            print(\"running uncongested transit assignment with warmstart demand\")\n            self.run_transit_assign(\n                time_period, use_ccr, congested_transit_assignment\n            )\n        elif (self.controller.iteration == 1) &amp; (self.controller.config.warmstart.use_warmstart_skim):\n            # iteration = 1 and use_warmstart_skim = True : run uncongested transit assignment\n            use_ccr = False\n            congested_transit_assignment = False\n            self.run_transit_assign(\n                time_period, use_ccr, congested_transit_assignment\n            )               \n        else:\n            # iteration &gt;= 1 and use_warmstart_skim = False : run congested transit assignment\n            use_ccr = self.config.use_ccr\n            if time_period in [\"EA\", \"EV\", \"MD\"]:\n                congested_transit_assignment = False\n            else:\n                congested_transit_assignment = (\n                    self.config.congested_transit_assignment\n                )\n\n            self.run_transit_assign(\n                time_period, use_ccr, congested_transit_assignment\n            )\n\n        # output_summaries\n        if self.config.output_stop_usage_path is not None:\n            network, class_stop_attrs = self._calc_connector_flows(time_period)\n            self._export_connector_flows(network, class_stop_attrs, time_period)\n        if self.controller.iteration == self.controller.config.run.end_iteration:\n            if self.config.output_transit_boardings_path is not None:\n                self._export_boardings_by_line(time_period)\n            if self.config.output_transit_segment_path is not None:\n                self._export_transit_segment(time_period)\n            if self.config.output_station_to_station_flow_path is not None:\n                self._export_boardings_by_station(time_period)\n            if self.config.output_transfer_at_station_path is not None:\n                self._export_transfer_at_stops(time_period)\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.TransitAssignment.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate the inputs.</p> Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate the inputs.\"\"\"\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.TransitAssignmentClass","title":"<code>TransitAssignmentClass</code>","text":"<p>Transit assignment class, represents data from config and conversion to Emme specs.</p> Internal properties Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>class TransitAssignmentClass:\n    \"\"\"Transit assignment class, represents data from config and conversion to Emme specs.\n\n    Internal properties:\n        _name: the class name loaded from config (not to be changed)\n        _class_config: the transit class config (TransitClassConfig)\n        _transit_config: the root transit assignment config (TransitConfig)\n        _time_period: the time period name\n        _iteration: the current iteration\n        _num_processors: the number of processors to use, loaded from config\n        _fare_modes: the mapping from the generated fare mode ID to the original\n            source mode ID\n        _spec_dir: directory to find the generated journey levels tables from\n            the apply fares step\n    \"\"\"\n\n    # disable too many instance attributes and arguments recommendations\n    # pylint: disable=R0902, R0913\n\n    def __init__(\n        self,\n        tclass_config: TransitClassConfig,\n        config: TransitConfig,\n        time_period: str,\n        iteration: int,\n        num_processors: int,\n        fare_modes: Dict[str, Set[str]],\n        spec_dir: str,\n    ):\n        \"\"\"Assignment class constructor.\n\n        Args:\n            tclass_config: the transit class config (TransitClassConfig)\n            config: the root transit assignment config (TransitConfig)\n            time_period: the time period name\n            iteration: the current iteration\n            num_processors: the number of processors to use, loaded from config\n            fare_modes: the mapping from the generated fare mode ID to the original\n                source mode ID\n            spec_dir: directory to find the generated journey levels tables from\n                the apply fares step\n        \"\"\"\n        self._name = tclass_config.name\n        self._class_config = tclass_config\n        self._config = config\n        self._time_period = time_period\n        self._iteration = iteration\n        self._num_processors = num_processors\n        self._fare_modes = fare_modes\n        self._spec_dir = spec_dir\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The class name.\"\"\"\n        return self._name\n\n    @property\n    def emme_transit_spec(self) -&gt; EmmeTransitSpec:\n        \"\"\"Return Emme Extended transit assignment specification.\n\n        Converted from input config (transit.classes, with some parameters from\n        transit table), see also Emme Help for\n        Extended transit assignment for specification details.\n\n        \"\"\"\n        spec = {\n            \"type\": \"EXTENDED_TRANSIT_ASSIGNMENT\",\n            \"modes\": self._modes,\n            \"demand\": self._demand_matrix,\n            \"waiting_time\": {\n                \"effective_headways\": self._config.effective_headway_source,\n                \"headway_fraction\": \"@hdw_fraction\",\n                \"perception_factor\": self._config.initial_wait_perception_factor,\n                \"spread_factor\": 1.0,\n            },\n            \"boarding_cost\": {\"global\": {\"penalty\": 0, \"perception_factor\": 1}},\n            \"boarding_time\": {\n                \"on_lines\": {\n                    \"penalty\": \"@iboard_penalty\",\n                    \"perception_factor\": 1,\n                }\n            },\n            \"in_vehicle_cost\": None,\n            \"in_vehicle_time\": {\"perception_factor\": \"@invehicle_factor\"},\n            \"aux_transit_time\": {\n                \"perception_factor\": 1\n            },  # walk and drive perception factors are specified in mode definition \"speed_or_time_factor\"\n            \"aux_transit_cost\": None,\n            \"journey_levels\": self._journey_levels,\n            \"flow_distribution_between_lines\": {\"consider_total_impedance\": True},\n            \"flow_distribution_at_origins\": {\n                \"fixed_proportions_on_connectors\": None,\n                \"choices_at_origins\": \"OPTIMAL_STRATEGY\",\n            },\n            \"flow_distribution_at_regular_nodes_with_aux_transit_choices\": {\n                \"choices_at_regular_nodes\": \"OPTIMAL_STRATEGY\"\n            },\n            \"circular_lines\": {\"stay\": False},\n            \"connector_to_connector_path_prohibition\": None,\n            \"od_results\": {\"total_impedance\": None},\n            \"performance_settings\": {\"number_of_processors\": self._num_processors},\n        }\n        if self._config.use_fares:\n            fare_perception = 60 / self._config.value_of_time\n            spec[\"boarding_cost\"] = {\n                \"on_segments\": {\n                    \"penalty\": \"@board_cost\",\n                    \"perception_factor\": fare_perception,\n                }\n            }\n            spec[\"in_vehicle_cost\"] = {\n                \"penalty\": \"@invehicle_cost\",\n                \"perception_factor\": fare_perception,\n            }\n        # Optional aux_transit_cost, used for walk time on connectors,\n        #          set if override_connector_times is on\n        if self._config.get(\"override_connector_times\", False):\n            spec[\"aux_transit_cost\"] = {\n                \"penalty\": f\"@walk_time_{self.name.lower()}\",\n                \"perception_factor\": self._config.walk_perception_factor,\n            }\n        return spec\n\n    @property\n    def _demand_matrix(self) -&gt; str:\n        return f'mf\"TRN_{self._class_config.skim_set_id}_{self._time_period}\"'\n\n    def _get_used_mode_ids(self, modes: List[TransitModeConfig]) -&gt; List[str]:\n        \"\"\"Get list of assignment Mode IDs from input list of Emme mode objects.\n\n        Accounts for fare table (mapping from input mode ID to auto-generated\n        set of mode IDs for fare transition table (fares.far input) by applyfares\n        component.\n        \"\"\"\n        if self._config.use_fares:\n            out_modes = set([])\n            for mode in modes:\n                if mode.assign_type == \"TRANSIT\":\n                    out_modes.update(self._fare_modes[mode.mode_id])\n                else:\n                    out_modes.add(mode.mode_id)\n            return list(out_modes)\n        return [mode.mode_id for mode in modes]\n\n    @property\n    def _modes(self) -&gt; List[str]:\n        \"\"\"List of modes IDs (str) to use in assignment for this class.\"\"\"\n        all_modes = self._config.modes\n        mode_types = self._class_config.mode_types\n        modes = [mode for mode in all_modes if mode.type in mode_types]\n        return self._get_used_mode_ids(modes)\n\n    @property\n    def _transit_modes(self) -&gt; List[str]:\n        \"\"\"List of transit modes IDs (str) to use in assignment for this class.\"\"\"\n        all_modes = self._config.modes\n        mode_types = self._class_config.mode_types\n        modes = [\n            mode\n            for mode in all_modes\n            if mode.type in mode_types and mode.assign_type == \"TRANSIT\"\n        ]\n        return self._get_used_mode_ids(modes)\n\n    @property\n    def fare_perception(self):\n        return 60 / self._config.value_of_time\n\n    @property\n    def headway_fraction(self):\n        return 0.5\n\n    @property\n    def _journey_levels(self) -&gt; EmmeTransitJourneyLevelSpec:\n        modes = self._transit_modes\n        effective_headway_source = self._config.effective_headway_source\n        if self._config.use_fares:\n            fare_perception = self.fare_perception\n            file_name = f\"{self._time_period}_ALLPEN_journey_levels.ems\"\n            with open(\n                os.path.join(self._spec_dir, file_name), \"r\", encoding=\"utf8\"\n            ) as jl_spec:\n                journey_levels = _json.load(jl_spec)[\"journey_levels\"]\n\n            if self.name == \"PNR_TRN_WLK\":\n                new_journey_levels = copy.deepcopy(journey_levels)\n\n                for i in range(0, len(new_journey_levels)):\n                    jls = new_journey_levels[i]\n                    for level in jls[\"transition_rules\"]:\n                        level[\"next_journey_level\"] = level[\"next_journey_level\"] + 1\n                    jls[\"transition_rules\"].extend(\n                        [\n                            {\"mode\": \"e\", \"next_journey_level\": i + 2},\n                            {\n                                \"mode\": \"D\",\n                                \"next_journey_level\": len(new_journey_levels) + 2,\n                            },\n                            {\"mode\": \"w\", \"next_journey_level\": i + 2},\n                            {\n                                \"mode\": \"p\",\n                                \"next_journey_level\": len(new_journey_levels) + 2,\n                            },\n                        ]\n                    )\n                # level 0: drive access\n                transition_rules_drive_access = copy.deepcopy(\n                    journey_levels[0][\"transition_rules\"]\n                )\n                for level in transition_rules_drive_access:\n                    level[\"next_journey_level\"] = len(new_journey_levels) + 2\n                transition_rules_drive_access.extend(\n                    [\n                        {\n                            \"mode\": \"e\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\"mode\": \"D\", \"next_journey_level\": 0},\n                        {\n                            \"mode\": \"w\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\"mode\": \"p\", \"next_journey_level\": 1},\n                    ]\n                )\n                # level 1: use transit\n                transition_rules_pnr = copy.deepcopy(\n                    journey_levels[0][\"transition_rules\"]\n                )\n                for level in transition_rules_pnr:\n                    level[\"next_journey_level\"] = 2\n                transition_rules_pnr.extend(\n                    [\n                        {\n                            \"mode\": \"e\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"D\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"w\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\"mode\": \"p\", \"next_journey_level\": 1},\n                    ]\n                )\n                # level len(new_journey_levels)+2: every mode is prohibited\n                transition_rules_prohibit = copy.deepcopy(\n                    journey_levels[0][\"transition_rules\"]\n                )\n                for level in transition_rules_prohibit:\n                    level[\"next_journey_level\"] = len(new_journey_levels) + 2\n                transition_rules_prohibit.extend(\n                    [\n                        {\n                            \"mode\": \"e\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"D\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"w\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"p\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                    ]\n                )\n                new_journey_levels.insert(\n                    0,\n                    {\n                        \"description\": \"drive access\",\n                        \"destinations_reachable\": False,\n                        \"transition_rules\": transition_rules_drive_access,\n                        \"waiting_time\": None,\n                        \"boarding_time\": None,\n                        \"boarding_cost\": None,\n                    },\n                )\n                new_journey_levels.insert(\n                    1,\n                    {\n                        \"description\": \"pnr\",\n                        \"destinations_reachable\": False,\n                        \"transition_rules\": transition_rules_pnr,\n                        \"waiting_time\": None,\n                        \"boarding_time\": None,\n                        \"boarding_cost\": None,\n                    },\n                )\n                new_journey_levels.append(\n                    {\n                        \"description\": \"prohibit\",\n                        \"destinations_reachable\": False,\n                        \"transition_rules\": transition_rules_prohibit,\n                        \"waiting_time\": None,\n                        \"boarding_time\": None,\n                        \"boarding_cost\": None,\n                    }\n                )\n                for level in new_journey_levels[2:-1]:\n                    level[\"waiting_time\"] = {\n                        \"headway_fraction\": \"@hdw_fraction\",\n                        \"effective_headways\": effective_headway_source,\n                        \"spread_factor\": 1,\n                        \"perception_factor\": \"@wait_pfactor\",\n                    }\n                    level[\"boarding_time\"] = {\n                        \"on_lines\": {\n                            \"penalty\": \"@xboard_penalty\",\n                            \"perception_factor\": 1,\n                        },\n                        \"at_nodes\": {\n                            \"penalty\": \"@xboard_nodepen\",\n                            \"perception_factor\": 1,\n                        },\n                    }\n                # add in the correct value of time parameter\n                for level in new_journey_levels:\n                    if level[\"boarding_cost\"]:\n                        level[\"boarding_cost\"][\"on_segments\"][\n                            \"perception_factor\"\n                        ] = fare_perception\n\n            elif self.name == \"WLK_TRN_PNR\":\n                new_journey_levels = copy.deepcopy(journey_levels)\n\n                for i in range(0, len(new_journey_levels)):\n                    jls = new_journey_levels[i]\n                    jls[\"destinations_reachable\"] = False\n                    jls[\"transition_rules\"].extend(\n                        [\n                            {\n                                \"mode\": \"a\",\n                                \"next_journey_level\": len(new_journey_levels) + 2,\n                            },\n                            {\n                                \"mode\": \"D\",\n                                \"next_journey_level\": len(new_journey_levels) + 2,\n                            },\n                            {\"mode\": \"w\", \"next_journey_level\": i + 1},\n                            {\n                                \"mode\": \"p\",\n                                \"next_journey_level\": len(new_journey_levels) + 1,\n                            },\n                        ]\n                    )\n                # level 0: walk access\n                transition_rules_walk_access = copy.deepcopy(\n                    journey_levels[0][\"transition_rules\"]\n                )\n                for level in transition_rules_walk_access:\n                    level[\"next_journey_level\"] = 1\n                transition_rules_walk_access.extend(\n                    [\n                        {\"mode\": \"a\", \"next_journey_level\": 0},\n                        {\n                            \"mode\": \"D\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"w\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"p\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                    ]\n                )\n                # level len(new_journey_levels)+1: drive home\n                transition_rules_drive_home = copy.deepcopy(\n                    journey_levels[0][\"transition_rules\"]\n                )\n                for level in transition_rules_drive_home:\n                    level[\"next_journey_level\"] = len(new_journey_levels) + 2\n                transition_rules_drive_home.extend(\n                    [\n                        {\n                            \"mode\": \"a\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"D\",\n                            \"next_journey_level\": len(new_journey_levels) + 1,\n                        },\n                        {\n                            \"mode\": \"w\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"p\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                    ]\n                )\n                # level len(new_journey_levels)+2: every mode is prohibited\n                transition_rules_prohibit = copy.deepcopy(\n                    journey_levels[0][\"transition_rules\"]\n                )\n                for level in transition_rules_prohibit:\n                    level[\"next_journey_level\"] = len(new_journey_levels) + 2\n                transition_rules_prohibit.extend(\n                    [\n                        {\n                            \"mode\": \"a\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"D\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"w\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"p\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                    ]\n                )\n                new_journey_levels.insert(\n                    0,\n                    {\n                        \"description\": \"walk access\",\n                        \"destinations_reachable\": True,\n                        \"transition_rules\": transition_rules_walk_access,\n                        \"waiting_time\": None,\n                        \"boarding_time\": None,\n                        \"boarding_cost\": None,\n                    },\n                )\n                new_journey_levels.append(\n                    {\n                        \"description\": \"drive home\",\n                        \"destinations_reachable\": True,\n                        \"transition_rules\": transition_rules_drive_home,\n                        \"waiting_time\": None,\n                        \"boarding_time\": None,\n                        \"boarding_cost\": None,\n                    }\n                )\n                new_journey_levels.append(\n                    {\n                        \"description\": \"prohibit\",\n                        \"destinations_reachable\": False,\n                        \"transition_rules\": transition_rules_prohibit,\n                        \"waiting_time\": None,\n                        \"boarding_time\": None,\n                        \"boarding_cost\": None,\n                    }\n                )\n                for level in new_journey_levels[1:-2]:\n                    level[\"waiting_time\"] = {\n                        \"headway_fraction\": \"@hdw_fraction\",\n                        \"effective_headways\": effective_headway_source,\n                        \"spread_factor\": 1,\n                        \"perception_factor\": \"@wait_pfactor\",\n                    }\n                    level[\"boarding_time\"] = {\n                        \"on_lines\": {\n                            \"penalty\": \"@xboard_penalty\",\n                            \"perception_factor\": 1,\n                        },\n                        \"at_nodes\": {\n                            \"penalty\": \"@xboard_nodepen\",\n                            \"perception_factor\": 1,\n                        },\n                    }\n                # add in the correct value of time parameter\n                for level in new_journey_levels:\n                    if level[\"boarding_cost\"]:\n                        level[\"boarding_cost\"][\"on_segments\"][\n                            \"perception_factor\"\n                        ] = fare_perception\n\n            elif self.name == \"KNR_TRN_WLK\":\n                new_journey_levels = copy.deepcopy(journey_levels)\n\n                for i in range(0, len(new_journey_levels)):\n                    jls = new_journey_levels[i]\n                    for level in jls[\"transition_rules\"]:\n                        level[\"next_journey_level\"] = level[\"next_journey_level\"] + 1\n                    jls[\"transition_rules\"].extend(\n                        [\n                            {\"mode\": \"e\", \"next_journey_level\": i + 2},\n                            {\n                                \"mode\": \"D\",\n                                \"next_journey_level\": len(new_journey_levels) + 2,\n                            },\n                            {\"mode\": \"w\", \"next_journey_level\": i + 2},\n                            {\n                                \"mode\": \"k\",\n                                \"next_journey_level\": len(new_journey_levels) + 2,\n                            },\n                        ]\n                    )\n                # level 0: drive access\n                transition_rules_drive_access = copy.deepcopy(\n                    journey_levels[0][\"transition_rules\"]\n                )\n                for level in transition_rules_drive_access:\n                    level[\"next_journey_level\"] = len(new_journey_levels) + 2\n                transition_rules_drive_access.extend(\n                    [\n                        {\n                            \"mode\": \"e\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\"mode\": \"D\", \"next_journey_level\": 0},\n                        {\n                            \"mode\": \"w\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\"mode\": \"k\", \"next_journey_level\": 1},\n                    ]\n                )\n                # level 1: use transit\n                transition_rules_knr = copy.deepcopy(\n                    journey_levels[0][\"transition_rules\"]\n                )\n                for level in transition_rules_knr:\n                    level[\"next_journey_level\"] = 2\n                transition_rules_knr.extend(\n                    [\n                        {\n                            \"mode\": \"e\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"D\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"w\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\"mode\": \"k\", \"next_journey_level\": 1},\n                    ]\n                )\n                # level len(new_journey_levels)+2: every mode is prohibited\n                transition_rules_prohibit = copy.deepcopy(\n                    journey_levels[0][\"transition_rules\"]\n                )\n                for level in transition_rules_prohibit:\n                    level[\"next_journey_level\"] = len(new_journey_levels) + 2\n                transition_rules_prohibit.extend(\n                    [\n                        {\n                            \"mode\": \"e\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"D\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"w\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"k\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                    ]\n                )\n                new_journey_levels.insert(\n                    0,\n                    {\n                        \"description\": \"drive access\",\n                        \"destinations_reachable\": False,\n                        \"transition_rules\": transition_rules_drive_access,\n                        \"waiting_time\": None,\n                        \"boarding_time\": None,\n                        \"boarding_cost\": None,\n                    },\n                )\n                new_journey_levels.insert(\n                    1,\n                    {\n                        \"description\": \"knr\",\n                        \"destinations_reachable\": False,\n                        \"transition_rules\": transition_rules_knr,\n                        \"waiting_time\": None,\n                        \"boarding_time\": None,\n                        \"boarding_cost\": None,\n                    },\n                )\n                new_journey_levels.append(\n                    {\n                        \"description\": \"prohibit\",\n                        \"destinations_reachable\": False,\n                        \"transition_rules\": transition_rules_prohibit,\n                        \"waiting_time\": None,\n                        \"boarding_time\": None,\n                        \"boarding_cost\": None,\n                    }\n                )\n                for level in new_journey_levels[2:-1]:\n                    level[\"waiting_time\"] = {\n                        \"headway_fraction\": \"@hdw_fraction\",\n                        \"effective_headways\": effective_headway_source,\n                        \"spread_factor\": 1,\n                        \"perception_factor\": \"@wait_pfactor\",\n                    }\n                    level[\"boarding_time\"] = {\n                        \"on_lines\": {\n                            \"penalty\": \"@xboard_penalty\",\n                            \"perception_factor\": 1,\n                        },\n                        \"at_nodes\": {\n                            \"penalty\": \"@xboard_nodepen\",\n                            \"perception_factor\": 1,\n                        },\n                    }\n                # add in the correct value of time parameter\n                for level in new_journey_levels:\n                    if level[\"boarding_cost\"]:\n                        level[\"boarding_cost\"][\"on_segments\"][\n                            \"perception_factor\"\n                        ] = fare_perception\n\n            elif self.name == \"WLK_TRN_KNR\":\n                new_journey_levels = copy.deepcopy(journey_levels)\n\n                for i in range(0, len(new_journey_levels)):\n                    jls = new_journey_levels[i]\n                    jls[\"destinations_reachable\"] = False\n                    jls[\"transition_rules\"].extend(\n                        [\n                            {\n                                \"mode\": \"a\",\n                                \"next_journey_level\": len(new_journey_levels) + 2,\n                            },\n                            {\n                                \"mode\": \"D\",\n                                \"next_journey_level\": len(new_journey_levels) + 2,\n                            },\n                            {\"mode\": \"w\", \"next_journey_level\": i + 1},\n                            {\n                                \"mode\": \"k\",\n                                \"next_journey_level\": len(new_journey_levels) + 1,\n                            },\n                        ]\n                    )\n                # level 0: walk access\n                transition_rules_walk_access = copy.deepcopy(\n                    journey_levels[0][\"transition_rules\"]\n                )\n                for level in transition_rules_walk_access:\n                    level[\"next_journey_level\"] = 1\n                transition_rules_walk_access.extend(\n                    [\n                        {\"mode\": \"a\", \"next_journey_level\": 0},\n                        {\n                            \"mode\": \"D\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"w\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"k\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                    ]\n                )\n                # level len(new_journey_levels)+1: drive home\n                transition_rules_drive_home = copy.deepcopy(\n                    journey_levels[0][\"transition_rules\"]\n                )\n                for level in transition_rules_drive_home:\n                    level[\"next_journey_level\"] = len(new_journey_levels) + 2\n                transition_rules_drive_home.extend(\n                    [\n                        {\n                            \"mode\": \"a\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"D\",\n                            \"next_journey_level\": len(new_journey_levels) + 1,\n                        },\n                        {\n                            \"mode\": \"w\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"k\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                    ]\n                )\n                # level len(new_journey_levels)+2: every mode is prohibited\n                transition_rules_prohibit = copy.deepcopy(\n                    journey_levels[0][\"transition_rules\"]\n                )\n                for level in transition_rules_prohibit:\n                    level[\"next_journey_level\"] = len(new_journey_levels) + 2\n                transition_rules_prohibit.extend(\n                    [\n                        {\n                            \"mode\": \"a\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"D\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"w\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                        {\n                            \"mode\": \"k\",\n                            \"next_journey_level\": len(new_journey_levels) + 2,\n                        },\n                    ]\n                )\n                new_journey_levels.insert(\n                    0,\n                    {\n                        \"description\": \"walk access\",\n                        \"destinations_reachable\": True,\n                        \"transition_rules\": transition_rules_walk_access,\n                        \"waiting_time\": None,\n                        \"boarding_time\": None,\n                        \"boarding_cost\": None,\n                    },\n                )\n                new_journey_levels.append(\n                    {\n                        \"description\": \"drive home\",\n                        \"destinations_reachable\": True,\n                        \"transition_rules\": transition_rules_drive_home,\n                        \"waiting_time\": None,\n                        \"boarding_time\": None,\n                        \"boarding_cost\": None,\n                    }\n                )\n                new_journey_levels.append(\n                    {\n                        \"description\": \"prohibit\",\n                        \"destinations_reachable\": False,\n                        \"transition_rules\": transition_rules_prohibit,\n                        \"waiting_time\": None,\n                        \"boarding_time\": None,\n                        \"boarding_cost\": None,\n                    }\n                )\n                for level in new_journey_levels[1:-2]:\n                    level[\"waiting_time\"] = {\n                        \"headway_fraction\": \"@hdw_fraction\",\n                        \"effective_headways\": effective_headway_source,\n                        \"spread_factor\": 1,\n                        \"perception_factor\": \"@wait_pfactor\",\n                    }\n                    level[\"boarding_time\"] = {\n                        \"on_lines\": {\n                            \"penalty\": \"@xboard_penalty\",\n                            \"perception_factor\": 1,\n                        },\n                        \"at_nodes\": {\n                            \"penalty\": \"@xboard_nodepen\",\n                            \"perception_factor\": 1,\n                        },\n                    }\n                # add in the correct value of time parameter\n                for level in new_journey_levels:\n                    if level[\"boarding_cost\"]:\n                        level[\"boarding_cost\"][\"on_segments\"][\n                            \"perception_factor\"\n                        ] = fare_perception\n\n            elif self.name == \"WLK_TRN_WLK\":\n                new_journey_levels = copy.deepcopy(journey_levels)\n\n                for i in range(0, len(new_journey_levels)):\n                    jls = new_journey_levels[i]\n                    jls[\"transition_rules\"].extend(\n                        [\n                            {\"mode\": \"e\", \"next_journey_level\": i + 1},\n                            {\"mode\": \"w\", \"next_journey_level\": i + 1},\n                            {\n                                \"mode\": \"a\",\n                                \"next_journey_level\": i + 1,\n                            },\n                        ]\n                    )\n                # level 0: only allow walk access and walk auxilary\n                # must use the trasit modes to get onto the next level,\n                transition_rules_walk = copy.deepcopy(\n                    journey_levels[0][\"transition_rules\"]\n                )\n                transition_rules_walk.extend(\n                    [\n                        {\n                            \"mode\": \"e\",\n                            \"next_journey_level\": 0,\n                        },\n                        {\n                            \"mode\": \"w\",\n                            \"next_journey_level\": 0,\n                        },\n                        {\"mode\": \"a\", \"next_journey_level\": 0},\n                    ]\n                )\n                new_journey_levels.insert(\n                    0,\n                    {\n                        \"description\": \"base\",\n                        \"destinations_reachable\": False,\n                        \"transition_rules\": transition_rules_walk,\n                        \"waiting_time\": None,\n                        \"boarding_time\": None,\n                        \"boarding_cost\": None,\n                    },\n                )\n                for level in new_journey_levels[1:]:\n                    level[\"waiting_time\"] = {\n                        \"headway_fraction\": \"@hdw_fraction\",\n                        \"effective_headways\": effective_headway_source,\n                        \"spread_factor\": 1,\n                        \"perception_factor\": \"@wait_pfactor\",\n                    }\n                    level[\"boarding_time\"] = {\n                        \"on_lines\": {\n                            \"penalty\": \"@xboard_penalty\",\n                            \"perception_factor\": 1,\n                        },\n                        \"at_nodes\": {\n                            \"penalty\": \"@xboard_nodepen\",\n                            \"perception_factor\": 1,\n                        },\n                    }\n                # add in the correct value of time parameter\n                for level in new_journey_levels:\n                    if level[\"boarding_cost\"]:\n                        level[\"boarding_cost\"][\"on_segments\"][\n                            \"perception_factor\"\n                        ] = fare_perception\n\n            with open(\n                os.path.join(\n                    self._spec_dir,\n                    \"%s_%s_journey_levels.ems\" % (self._time_period, self.name),\n                ),\n                \"w\",\n            ) as jl_spec_file:\n                spec = {\n                    \"type\": \"EXTENDED_TRANSIT_ASSIGNMENT\",\n                    \"journey_levels\": new_journey_levels,\n                }\n                _json.dump(spec, jl_spec_file, indent=4)\n\n        else:\n            new_journey_levels = [\n                {\n                    \"description\": \"\",\n                    \"destinations_reachable\": True,\n                    \"transition_rules\": [\n                        {\"mode\": m, \"next_journey_level\": 1} for m in modes\n                    ],\n                },\n                {\n                    \"description\": \"\",\n                    \"destinations_reachable\": True,\n                    \"transition_rules\": [\n                        {\"mode\": m, \"next_journey_level\": 1} for m in modes\n                    ],\n                    \"waiting_time\": {\n                        \"headway_fraction\": \"@hdw_fraction\",\n                        \"effective_headways\": effective_headway_source,\n                        \"spread_factor\": 1,\n                        \"perception_factor\": \"@wait_pfactor\",\n                    },\n                },\n            ]\n            for level in new_journey_levels[1:]:\n                level[\"boarding_time\"] = {\n                    \"on_lines\": {\"penalty\": \"@xboard_penalty\", \"perception_factor\": 1},\n                    \"at_nodes\": {\"penalty\": \"@xboard_nodepen\", \"perception_factor\": 1},\n                }\n\n        return new_journey_levels\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.TransitAssignmentClass.emme_transit_spec","title":"<code>emme_transit_spec: EmmeTransitSpec</code>  <code>property</code>","text":"<p>Return Emme Extended transit assignment specification.</p> <p>Converted from input config (transit.classes, with some parameters from transit table), see also Emme Help for Extended transit assignment for specification details.</p>"},{"location":"api/#tm2py.components.network.transit.transit_assign.TransitAssignmentClass.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The class name.</p>"},{"location":"api/#tm2py.components.network.transit.transit_assign.TransitAssignmentClass.__init__","title":"<code>__init__(tclass_config, config, time_period, iteration, num_processors, fare_modes, spec_dir)</code>","text":"<p>Assignment class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>tclass_config</code> <code>TransitClassConfig</code> <p>the transit class config (TransitClassConfig)</p> required <code>config</code> <code>TransitConfig</code> <p>the root transit assignment config (TransitConfig)</p> required <code>time_period</code> <code>str</code> <p>the time period name</p> required <code>iteration</code> <code>int</code> <p>the current iteration</p> required <code>num_processors</code> <code>int</code> <p>the number of processors to use, loaded from config</p> required <code>fare_modes</code> <code>Dict[str, Set[str]]</code> <p>the mapping from the generated fare mode ID to the original source mode ID</p> required <code>spec_dir</code> <code>str</code> <p>directory to find the generated journey levels tables from the apply fares step</p> required Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>def __init__(\n    self,\n    tclass_config: TransitClassConfig,\n    config: TransitConfig,\n    time_period: str,\n    iteration: int,\n    num_processors: int,\n    fare_modes: Dict[str, Set[str]],\n    spec_dir: str,\n):\n    \"\"\"Assignment class constructor.\n\n    Args:\n        tclass_config: the transit class config (TransitClassConfig)\n        config: the root transit assignment config (TransitConfig)\n        time_period: the time period name\n        iteration: the current iteration\n        num_processors: the number of processors to use, loaded from config\n        fare_modes: the mapping from the generated fare mode ID to the original\n            source mode ID\n        spec_dir: directory to find the generated journey levels tables from\n            the apply fares step\n    \"\"\"\n    self._name = tclass_config.name\n    self._class_config = tclass_config\n    self._config = config\n    self._time_period = time_period\n    self._iteration = iteration\n    self._num_processors = num_processors\n    self._fare_modes = fare_modes\n    self._spec_dir = spec_dir\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.calc_adjusted_headway","title":"<code>calc_adjusted_headway(segment, segment_capacity)</code>","text":"<p>Headway adjusted based on ....?</p> <p>TODO: add documentation about source and theory behind this.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <p>Emme transit segment object</p> required <code>segment_capacity</code> <code>float</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Adjusted headway</p> Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>def calc_adjusted_headway(segment, segment_capacity: float) -&gt; float:\n    \"\"\"Headway adjusted based on ....?\n\n    TODO: add documentation about source and theory behind this.\n\n    Args:\n        segment: Emme transit segment object\n        segment_capacity (float): _description_\n\n    Returns:\n        float: Adjusted headway\n    \"\"\"\n    # TODO add to params\n    max_hdwy_growth = 1.5\n    max_headway = 999.98\n    # QUESTION FOR INRO: what is the difference between segment[\"@phdwy\"] and line.headway?\n    # is one the perceived headway?\n    _transit_volume = segment.transit_volume\n    _transit_boardings = segment.transit_boardings\n    _previous_headway = segment[\"@phdwy\"]\n    _current_headway = segment.line.headway\n    _available_capacity = max(\n        segment_capacity - _transit_volume + _transit_boardings, 0\n    )\n\n    adjusted_headway = min(\n        max_headway,\n        _previous_headway\n        * min((_transit_boardings + 1) / (_available_capacity + 1), 1.5),\n    )\n    adjusted_headway = max(_current_headway, adjusted_headway)\n\n    return adjusted_headway\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.calc_extra_wait_time","title":"<code>calc_extra_wait_time(segment, segment_capacity, eawt_weights, mode_config, use_fares=False)</code>","text":"<p>Calculate extra added wait time based on\u2026</p>"},{"location":"api/#tm2py.components.network.transit.transit_assign.calc_extra_wait_time--todo-document-fully","title":"TODO document fully.","text":"<p>Parameters:</p> Name Type Description Default <code>segment</code> <code>_type_</code> <p>Emme transit segment object.</p> required <code>segment_capacity</code> <code>float</code> <p>description</p> required <code>eawt_weights</code> <p>extra added wait time weights</p> required <code>mode_config</code> <code>dict</code> <p>mode character to mode config</p> required <code>use_fares</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>def calc_extra_wait_time(\n    segment,\n    segment_capacity: float,\n    eawt_weights,\n    mode_config: dict,\n    use_fares: bool = False,\n):\n    \"\"\"Calculate extra added wait time based on...\n\n    # TODO document fully.\n\n    Args:\n        segment (_type_): Emme transit segment object.\n        segment_capacity (float): _description_\n        eawt_weights: extra added wait time weights\n        mode_config: mode character to mode config\n        use_fares (bool, optional): _description_. Defaults to False.\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    _transit_volume = segment.transit_volume\n    _headway = segment.line.headway if segment.line.headway &gt;= 0.1 else 9999\n    _total_offs = calc_total_offs(segment.line)\n    _offs_thru_segment = calc_offs_thru_segment(segment)\n\n    # TODO Document and add params to config. Have no idea what source is here.\n    eawt = (\n        eawt_weights.constant\n        + eawt_weights.weight_inverse_headway * (1 / _headway)\n        + eawt_weights.vcr * (_transit_volume / segment_capacity)\n        + eawt_weights.exit_proportion * (_offs_thru_segment / _total_offs)\n    )\n\n    if use_fares:\n        eawt_factor = (\n            1\n            if segment.line[\"#src_mode\"] == \"\"\n            else mode_config[segment.line[\"#src_mode\"]][\"eawt_factor\"]\n        )\n    else:\n        eawt_factor = (\n            1\n            if segment.line.mode.id == \"\"\n            else mode_config[segment.line.mode.id][\"eawt_factor\"]\n        )\n\n    return eawt * eawt_factor\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.calc_offs_thru_segment","title":"<code>calc_offs_thru_segment(segment)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>_type_</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>description</p> Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>def calc_offs_thru_segment(segment) -&gt; float:\n    \"\"\"_summary_\n\n    Args:\n        segment (_type_): _description_\n\n    Returns:\n        float: _description_\n    \"\"\"\n    # SIJIA TODO check that it should be [:segment.number+1] . Not sure if 0-indexed in emme or 1-indexed?\n    segments_thru_this_segment = [seg for seg in iter(segment.line.segments(True))][\n        : segment.number + 1\n    ]\n    offs_thru_this_seg = [\n        prev_seg.transit_volume - this_seg.transit_volume + this_seg.transit_boardings\n        for prev_seg, this_seg in zip(\n            segments_thru_this_segment[:-1], segments_thru_this_segment[1:]\n        )\n    ]\n    total_offs_thru_this_seg = sum(offs_thru_this_seg)\n    return total_offs_thru_this_seg\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.calc_total_offs","title":"<code>calc_total_offs(line)</code>","text":"<p>Calculate total alightings for a line.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>_type_</code> <p>description</p> required Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>def calc_total_offs(line) -&gt; float:\n    \"\"\"Calculate total alightings for a line.\n\n    Args:\n        line (_type_): _description_\n    \"\"\"\n    # NOTE This was done previously using:\n    # total_offs += prev_seg.transit_volume - seg.transit_volume + seg.transit_boardings\n    # but offs should equal ons for a whole line, so this seems simpler\n    offs = [seg.transit_boardings for seg in line.segments(True)]\n    total_offs = sum(offs)\n    # added lambda due to divide by zero error\n    return total_offs if total_offs &gt;= 0.001 else 9999\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.func_returns_calc_updated_perceived_headway","title":"<code>func_returns_calc_updated_perceived_headway(time_period_duration, eawt_weights, mode_config, use_fares)</code>","text":"<p>function that returns the calc_headway function for emme assignment, with partial preloaded parameters acts like partial as emme does not take partial</p> Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>def func_returns_calc_updated_perceived_headway(\n    time_period_duration, eawt_weights, mode_config, use_fares\n):\n    \"\"\"\n    function that returns the calc_headway function for emme assignment, with partial preloaded parameters\n    acts like partial as emme does not take partial\n    \"\"\"\n\n    def calc_headway(transit_volume, transit_boardings, headway, capacity, segment):\n        \"\"\"Calculate perceived (???) headway updated by ... and extra added wait time.\n\n        # TODO Document more fully.\n\n        Args:\n            time_period_duration(float): time period duration in minutes\n            segment: Emme Transit segment object\n            eawt_weights:\n            mode_config:\n            use_fares (bool): if true, will use fares\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        # QUESTION FOR INRO: Kevin separately put segment.line.headway and headway as an arg.\n        # Would they be different? Why?\n        # TODO: Either can we label the headways so it is clear what is diff about them or just use single value?\n\n        from tm2py.config import (\n            CcrWeightsConfig,\n            EawtWeightsConfig,\n            TransitClassConfig,\n            TransitConfig,\n            TransitModeConfig,\n        )\n\n        _segment_capacity = capacity\n\n        vcr = transit_volume / _segment_capacity\n\n        _extra_added_wait_time = calc_extra_wait_time(\n            segment,\n            _segment_capacity,\n            {eawt_weights},\n            {mode_config},\n            {use_fares},\n        )\n\n        _adjusted_headway = calc_adjusted_headway(\n            segment,\n            _segment_capacity,\n        )\n\n        return _adjusted_headway + _extra_added_wait_time\n\n    return textwrap.dedent(inspect.getsource(calc_headway)).format(\n        time_period_duration=time_period_duration,\n        eawt_weights=eawt_weights,\n        mode_config=mode_config,\n        use_fares=use_fares,\n    )\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.func_returns_crowded_segment_cost","title":"<code>func_returns_crowded_segment_cost(time_period_duration, weights)</code>","text":"<p>function that returns the calc_segment_cost function for emme assignment, with partial preloaded parameters acts like partial as emme does not take partial</p> Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>def func_returns_crowded_segment_cost(time_period_duration, weights: CcrWeightsConfig):\n    \"\"\"\n    function that returns the calc_segment_cost function for emme assignment, with partial preloaded parameters\n    acts like partial as emme does not take partial\n    \"\"\"\n\n    def calc_segment_cost(transit_volume: float, capacity, segment) -&gt; float:\n        \"\"\"Calculates crowding factor for a segment.\n\n        Toronto implementation limited factor between 1.0 and 10.0.\n        For use with Emme Capacitated assignment normalize by subtracting 1\n\n        Args:\n            time_period_duration(float): time period duration in minutes\n            weights (_type_): transit capacity weights\n            segment_pax (float): transit passengers for the segment for the time period\n            segment: emme line segment\n\n        Returns:\n            float: crowding factor for a segment\n        \"\"\"\n\n        from tm2py.config import (\n            CcrWeightsConfig,\n            EawtWeightsConfig,\n            TransitClassConfig,\n            TransitConfig,\n            TransitModeConfig,\n        )\n\n        if transit_volume == 0:\n            return 0.0\n\n        line = segment.line\n\n        seated_capacity = (\n            line.vehicle.seated_capacity * {time_period_duration} * 60 / line.headway\n        )\n\n        seated_pax = min(transit_volume, seated_capacity)\n        standing_pax = max(transit_volume - seated_pax, 0)\n\n        seated_cost = {weights}.min_seat + ({weights}.max_seat - {weights}.min_seat) * (\n            transit_volume / capacity\n        ) ** {weights}.power_seat\n\n        standing_cost = {weights}.min_stand + (\n            {weights}.max_stand - {weights}.min_stand\n        ) * (transit_volume / capacity) ** {weights}.power_stand\n\n        crowded_cost = (seated_cost * seated_pax + standing_cost * standing_pax) / (\n            transit_volume + 0.01\n        )\n\n        normalized_crowded_cost = max(crowded_cost - 1, 0)\n\n        return normalized_crowded_cost\n\n    return textwrap.dedent(inspect.getsource(calc_segment_cost)).format(\n        time_period_duration=time_period_duration, weights=weights\n    )\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.func_returns_segment_congestion","title":"<code>func_returns_segment_congestion(time_period_duration, scenario, weights, use_fares=False)</code>","text":"<p>function that returns the calc_segment_cost function for emme assignment, with partial preloaded parameters acts like partial as emme does not take partial</p> Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>def func_returns_segment_congestion(\n    time_period_duration,\n    scenario,\n    weights: CongestedWeightsConfig,\n    use_fares: bool = False,\n):\n    \"\"\"\n    function that returns the calc_segment_cost function for emme assignment, with partial preloaded parameters\n    acts like partial as emme does not take partial\n    \"\"\"\n    if use_fares:\n        values = scenario.get_attribute_values(\"TRANSIT_LINE\", [\"#src_mode\"])\n        scenario.set_attribute_values(\"TRANSIT_LINE\", [\"#src_mode\"], values)\n\n    def calc_segment_cost(transit_volume: float, capacity, segment) -&gt; float:\n        \"\"\"Calculates crowding factor for a segment.\n\n        Toronto implementation limited factor between 1.0 and 10.0.\n        For use with Emme Capacitated assignment normalize by subtracting 1\n\n        Args:\n            time_period_duration(float): time period duration in minutes\n            weights (_type_): transit capacity weights\n            segment: emme line segment\n\n        Returns:\n            float: crowding factor for a segment\n        \"\"\"\n\n        from tm2py.config import (\n            CongestedWeightsConfig,\n            TransitClassConfig,\n            TransitConfig,\n            TransitModeConfig,\n        )\n\n        if transit_volume &lt;= 0:\n            return 0.0\n\n        line = segment.line\n\n        if {use_fares}:\n            mode_char = line[\"#src_mode\"]\n        else:\n            mode_char = line.mode.id\n\n        if mode_char in [\"p\"]:\n            congestion = 0.25 * ((transit_volume / capacity) ** 10)\n        else:\n            seated_capacity = (\n                line.vehicle.seated_capacity\n                * {time_period_duration}\n                * 60\n                / line.headway\n            )\n\n            seated_pax = min(transit_volume, seated_capacity)\n            standing_pax = max(transit_volume - seated_pax, 0)\n\n            seated_cost = {weights}.min_seat + (\n                {weights}.max_seat - {weights}.min_seat\n            ) * (transit_volume / capacity) ** {weights}.power_seat\n\n            standing_cost = {weights}.min_stand + (\n                {weights}.max_stand - {weights}.min_stand\n            ) * (transit_volume / capacity) ** {weights}.power_stand\n\n            crowded_cost = (seated_cost * seated_pax + standing_cost * standing_pax) / (\n                transit_volume\n            )\n\n            congestion = max(crowded_cost, 1) - 1.0\n\n        return congestion\n\n    return textwrap.dedent(inspect.getsource(calc_segment_cost)).format(\n        time_period_duration=time_period_duration, weights=weights, use_fares=use_fares\n    )\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_assign.time_period_capacity","title":"<code>time_period_capacity(vehicle_capacity, headway, time_period_duration)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>vehicle_capacity</code> <code>float</code> <p>Vehicle capacity per hour. For vehicles with multiple cars (i.e. trainsets), should be the capacity of all of them that are traveling together.</p> required <code>headway</code> <code>float</code> <p>Vehicle (or train sets) per hour.</p> required <code>time_period_duration</code> <code>float</code> <p>duration of the time period in minutes</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>capacity for the whole time period</p> Source code in <code>tm2py/components/network/transit/transit_assign.py</code> <pre><code>def time_period_capacity(\n    vehicle_capacity: float, headway: float, time_period_duration: float\n) -&gt; float:\n    \"\"\"_summary_\n\n    Args:\n        vehicle_capacity (float): Vehicle capacity per hour. For vehicles with multiple cars\n            (i.e. trainsets), should be the capacity of all of them that are traveling together.\n        headway (float): Vehicle (or train sets) per hour.\n        time_period_duration (float): duration of the time period in minutes\n\n    Returns:\n        float: capacity for the whole time period\n    \"\"\"\n    return vehicle_capacity * time_period_duration * 60 / headway\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim","title":"<code>TransitSkim</code>","text":"<p>               Bases: <code>Component</code></p> <p>Transit skim calculation methods.</p> Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>class TransitSkim(Component):\n    \"\"\"Transit skim calculation methods.\"\"\"\n\n    def __init__(self, controller: \"RunController\"):\n        \"\"\"Constructor for TransitSkim class.\n\n        Args:\n            controller: The RunController instance.\n        \"\"\"\n        super().__init__(controller)\n        self.config = self.controller.config.transit\n        self._emmebank = None\n        self._num_processors = self.controller.emme_manager.num_processors_transit_skim\n        self._networks = None\n        self._scenarios = None\n        self._matrix_cache = None\n        self._skim_properties = None\n        self._skim_matrices = {\n            k: None\n            for k in itertools.product(\n                self.time_period_names,\n                self.config.classes,\n                self.skim_properties,\n            )\n        }\n        self._skim_outputs = None\n\n    def validate_inputs(self):\n        \"\"\"Validate inputs.\"\"\"\n        # TODO add input validation\n        pass\n\n    @property\n    def emmebank(self):\n        if not self._emmebank:\n            self._emmebank = self.controller.emme_manager.transit_emmebank\n        return self._emmebank\n\n    @property\n    def scenarios(self):\n        if self._scenarios is None:\n            self._scenarios = {\n                tp: self.emmebank.scenario(tp) for tp in self.time_period_names\n            }\n        return self._scenarios\n\n    @property\n    def networks(self):\n        if self._networks is None:\n            self._networks = {\n                tp: self.scenarios[tp].get_partial_network(\n                    [\"TRANSIT_SEGMENT\"], include_attributes=False\n                )\n                for tp in self.time_period_names\n            }\n        return self._networks\n\n    @property\n    def matrix_cache(self):\n        if self._matrix_cache is None:\n            self._matrix_cache = {\n                tp: MatrixCache(self.scenarios[tp]) for tp in self.time_period_names\n            }\n        return self._matrix_cache\n\n    @LogStartEnd(\"Transit skims\")\n    def run(self):\n        \"\"\"Run transit skims.\"\"\"\n        self.emmebank_skim_matrices(\n            self.time_period_names, self.config.classes, self.skim_properties\n        )\n        with self.logger.log_start_end(f\"period transit skims\"):\n            for _time_period in self.time_period_names:\n                with self.controller.emme_manager.logbook_trace(\n                    f\"Transit skims for period {_time_period}\"\n                ):\n                    for _transit_class in self.config.classes:\n                        self.run_skim_set(_time_period, _transit_class)\n                        self._export_skims(_time_period, _transit_class)\n                    if self.logger.debug_enabled:\n                        self._log_debug_report(_time_period)\n\n    @property\n    def skim_matrices(self):\n        return self._skim_matrices\n\n    @property\n    def skim_properties(self):\n        \"\"\"List of Skim Property named tuples: name, description.\n\n        TODO put these in config.\n        \"\"\"\n        if self._skim_properties is None:\n            from collections import namedtuple\n\n            # TODO config\n            self._skim_properties = []\n\n            _basic_skims = [\n                (\"IWAIT\", \"first wait time\"),\n                (\"XWAIT\", \"transfer wait time\"),\n                (\"WAIT\", \"total wait time\"),\n                (\"FARE\", \"fare\"),\n                (\"BOARDS\", \"num boardings\"),\n                (\"WAUX\", \"auxiliary walk time\"),\n                (\"DTIME\", \"access and egress drive time\"),\n                (\"DDIST\", \"access and egress drive distance\"),\n                (\"WACC\", \"access walk time\"),\n                (\"WEGR\", \"egress walk time\"),\n                (\"IVT\", \"total in-vehicle time\"),\n                (\"IN_VEHICLE_COST\", \"in-vehicle cost\"),\n                (\"CROWD\", \"Crowding penalty\"),\n            ]\n            self._skim_properties += [\n                Skimproperty(_name, _desc) for _name, _desc in _basic_skims\n            ]\n            for mode in self.config.modes:\n                if (mode.assign_type == \"TRANSIT\") and (mode.type != \"PNR_dummy\"):\n                    desc = mode.description or mode.name\n                    self._skim_properties.append(\n                        Skimproperty(\n                            f\"IVT{mode.name}\",\n                            f\"{desc} in-vehicle travel time\"[:40],\n                        )\n                    )\n            if self.config.use_ccr:\n                self._skim_properties.extend(\n                    [\n                        Skimproperty(\"LINKREL\", \"Link reliability\"),\n                        Skimproperty(\"EAWT\", \"Extra added wait time\"),\n                        Skimproperty(\"CAPPEN\", \"Capacity penalty\"),\n                    ]\n                )\n            if self.config.congested_transit_assignment:\n                self._skim_properties.extend(\n                    [\n                        Skimproperty(\"TRIM\", \"used to trim demands\"),\n                        Skimproperty(\"XBOATIME\", \"transfer boarding time penalty\"),\n                        Skimproperty(\"DTOLL\", \"drive access or egress toll price\"),\n                    ]\n                )\n        return self._skim_properties\n\n    @property\n    def skim_outputs(self):\n        \"\"\"List of Skim Property named tuples: name, description.\n\n        TODO put these in config.\n        \"\"\"\n        if self._skim_outputs is None:\n            from collections import namedtuple\n\n            # TODO config\n            self._skim_outputs = []\n\n            _write_skims_to_omx = [\n                \"IWAIT\",\n                \"XWAIT\",\n                \"FARE\",\n                \"BOARDS\",\n                \"WAUX\",\n                \"DTIME\",\n                \"DDIST\",\n                \"WACC\",\n                \"WEGR\",\n                \"IVT\",\n                \"CROWD\"\n            ]\n\n            for mode in self.config.modes:\n                if (mode.assign_type == \"TRANSIT\") and (mode.type != \"PNR_dummy\"):\n                    _write_skims_to_omx.append(f\"IVT{mode.name}\")\n\n            self._skim_outputs = [\n                Skimproperty(_name, _desc) \n                for _name, _desc in self._skim_properties\n                if _name in _write_skims_to_omx\n            ]\n\n        return self._skim_outputs\n\n    def emmebank_skim_matrices(\n        self,\n        time_periods: List[str] = None,\n        transit_classes=None,\n        skim_properties: Skimproperty = None,\n    ) -&gt; dict:\n        \"\"\"Gets skim matrices from emmebank, or lazily creates them if they don't already exist.\"\"\"\n        create_matrix = self.controller.emme_manager.tool(\n            \"inro.emme.data.matrix.create_matrix\"\n        )\n        if time_periods is None:\n            time_periods = self.time_period_names\n        if not set(time_periods).issubset(set(self.time_period_names)):\n            raise ValueError(\n                f\"time_periods ({time_periods}) must be subset of time_period_names ({self.time_period_names}).\"\n            )\n\n        if transit_classes is None:\n            transit_classes = self.config.classes\n        if not set(transit_classes).issubset(set(self.config.classes)):\n            raise ValueError(\n                f\"time_periods ({transit_classes}) must be subset of time_period_names ({self.config.transit_classes}).\"\n            )\n\n        if skim_properties is None:\n            skim_properties = self.skim_properties\n        if not set(skim_properties).issubset(set(self.skim_properties)):\n            raise ValueError(\n                f\"time_periods ({skim_properties}) must be subset of time_period_names ({self.skim_properties}).\"\n            )\n\n        _tp_tclass_skprop = itertools.product(\n            time_periods, transit_classes, skim_properties\n        )\n        _tp_tclass_skprop_list = []\n\n        for _tp, _tclass, _skprop in _tp_tclass_skprop:\n            a = 1\n            _name = f\"{_tp}_{_tclass.name}_{_skprop.name}\"\n            _desc = f\"{_tp} {_tclass.description}: {_skprop.desc}\"\n            _matrix = self.scenarios[_tp].emmebank.matrix(f'mf\"{_name}\"')\n            if not _matrix:\n                _matrix = create_matrix(\n                    \"mf\", _name, _desc, scenario=self.scenarios[_tp], overwrite=True\n                )\n            else:\n                _matrix.description = _desc\n\n            self._skim_matrices[_name] = _matrix\n            _tp_tclass_skprop_list.append(_name)\n\n        skim_matrices = {\n            k: v\n            for k, v in self._skim_matrices.items()\n            if k in list(_tp_tclass_skprop_list)\n        }\n        return skim_matrices\n\n    def run_skim_set(self, time_period: str, transit_class: str):\n        \"\"\"Run the transit skim calculations for a given time period and assignment class.\n\n        Results are stored in transit emmebank.\n\n        Steps:\n            1. determine if using transit capacity constraint\n            2. skim walk, wait time, boardings, and fares\n            3. skim in vehicle time by mode\n            4. mask transfers above max amount\n            5. mask if doesn't have required modes\n        \"\"\"\n        use_ccr = False\n        congested_transit_assignment = self.config.congested_transit_assignment\n        if self.controller.iteration &gt;= 1:\n            use_ccr = self.config.use_ccr\n        with self.controller.emme_manager.logbook_trace(\n            \"First and total wait time, number of boardings, \"\n            \"fares, and total and transfer walk time\"\n        ):\n            self.skim_walk_wait_boards_fares(time_period, transit_class)\n        with self.controller.emme_manager.logbook_trace(\"In-vehicle time by mode\"):\n            self.skim_invehicle_time_by_mode(time_period, transit_class, use_ccr)\n        with self.controller.emme_manager.logbook_trace(\n            \"Drive distance and time\",\n            \"Walk auxiliary time, walk access time and walk egress time\",\n        ):\n            self.skim_drive_walk(time_period, transit_class)\n        with self.controller.emme_manager.logbook_trace(\"Calculate crowding\"):\n            self.skim_crowding(time_period, transit_class)\n        if use_ccr:\n            with self.controller.emme_manager.logbook_trace(\"CCR related skims\"):\n                self.skim_reliability_crowding_capacity(time_period, transit_class)\n\n    def skim_walk_wait_boards_fares(self, time_period: str, transit_class: str):\n        \"\"\"Skim wait, walk, board, and fares for a given time period and transit assignment class.\n\n        Skim the first and total wait time, number of boardings, (transfers + 1)\n        fares, total walk time, total in-vehicle time.\n        \"\"\"\n        _tp_tclass = f\"{time_period}_{transit_class.name}\"\n        _network = self.networks[time_period]\n        _transit_mode_ids = [\n            m.id for m in _network.modes() if m.type in [\"TRANSIT\", \"AUX_TRANSIT\"]\n        ]\n        spec = {\n            \"type\": \"EXTENDED_TRANSIT_MATRIX_RESULTS\",\n            \"actual_first_waiting_times\": f'mf\"{_tp_tclass}_IWAIT\"',\n            \"actual_total_waiting_times\": f'mf\"{_tp_tclass}_WAIT\"',\n            \"by_mode_subset\": {\n                \"modes\": _transit_mode_ids,\n                \"avg_boardings\": f'mf\"{_tp_tclass}_BOARDS\"',\n            },\n        }\n        if self.config.use_fares:\n            spec[\"by_mode_subset\"].update(\n                {\n                    \"actual_in_vehicle_costs\": f'mf\"{_tp_tclass}_IN_VEHICLE_COST\"',\n                    \"actual_total_boarding_costs\": f'mf\"{_tp_tclass}_FARE\"',\n                }\n            )\n\n        self.controller.emme_manager.matrix_results(\n            spec,\n            class_name=transit_class.name,\n            scenario=self.scenarios[time_period],\n            num_processors=self._num_processors,\n        )\n\n        self._calc_xfer_wait(time_period, transit_class.name)\n        self._calc_boardings(time_period, transit_class.name)\n        if self.config.use_fares:\n            self._calc_fares(time_period, transit_class.name)\n\n    def _calc_xfer_walk(self, time_period, transit_class_name):\n        xfer_modes = [m.mode_id for m in self.config.modes if m.type == \"WALK\"]\n        tp_tclass = f\"{time_period}_{transit_class_name}\"\n        spec = {\n            \"type\": \"EXTENDED_TRANSIT_MATRIX_RESULTS\",\n            \"by_mode_subset\": {\n                \"modes\": xfer_modes,\n                \"actual_aux_transit_times\": f'mf\"{tp_tclass}_XFERWALK\"',\n            },\n        }\n        self.controller.emme_manager.matrix_results(\n            spec,\n            class_name=transit_class_name,\n            scenario=self.scenarios[time_period],\n            num_processors=self._num_processors,\n        )\n\n    def _calc_xfer_wait(self, time_period, transit_class_name):\n        \"\"\"Calculate transfer wait from total wait time and initial wait time and add to Emmebank.\n\n        TODO convert this type of calculation to numpy\n        \"\"\"\n        tp_tclass = f\"{time_period}_{transit_class_name}\"\n        spec = {\n            \"type\": \"MATRIX_CALCULATION\",\n            \"constraint\": {\n                \"by_value\": {\n                    \"od_values\": f'mf\"{tp_tclass}_WAIT\"',\n                    \"interval_min\": 0,\n                    \"interval_max\": 9999999,\n                    \"condition\": \"INCLUDE\",\n                }\n            },\n            \"result\": f'mf\"{tp_tclass}_XWAIT\"',\n            \"expression\": f'(mf\"{tp_tclass}_WAIT\" - mf\"{tp_tclass}_IWAIT\").max.0',\n        }\n\n        self.controller.emme_manager.matrix_calculator(\n            spec,\n            scenario=self.scenarios[time_period],\n            num_processors=self._num_processors,\n        )\n\n    def _calc_boardings(self, time_period: str, transit_class_name: str):\n        \"\"\"Calculate # boardings from # of transfers and add to Emmebank.\n\n        TODO convert this type of calculation to numpy\n        \"\"\"\n        _tp_tclass = f\"{time_period}_{transit_class_name}\"\n        if (\"PNR_TRN_WLK\" in _tp_tclass) or (\"WLK_TRN_PNR\" in _tp_tclass):\n            spec = {\n                \"type\": \"MATRIX_CALCULATION\",\n                \"constraint\": {\n                    \"by_value\": {\n                        \"od_values\": f'mf\"{_tp_tclass}_BOARDS\"',\n                        \"interval_min\": 0,\n                        \"interval_max\": 9999999,\n                        \"condition\": \"INCLUDE\",\n                    }\n                },\n                # CHECK should this be BOARDS or similar, not xfers?\n                \"result\": f'mf\"{_tp_tclass}_BOARDS\"',\n                \"expression\": f'(mf\"{_tp_tclass}_BOARDS\" - 1).max.0',\n            }\n\n            self.controller.emme_manager.matrix_calculator(\n                spec,\n                scenario=self.scenarios[time_period],\n                num_processors=self._num_processors,\n            )\n\n    def _calc_fares(self, time_period: str, transit_class_name: str):\n        \"\"\"Calculate fares as sum in-vehicle cost and boarding cost to get the fare paid and add to Emmebank.\n\n        TODO convert this type of calculation to numpy\n        \"\"\"\n        _tp_tclass = f\"{time_period}_{transit_class_name}\"\n        spec = {\n            \"type\": \"MATRIX_CALCULATION\",\n            \"constraint\": None,\n            \"result\": f'mf\"{_tp_tclass}_FARE\"',\n            \"expression\": f'(mf\"{_tp_tclass}_FARE\" + mf\"{_tp_tclass}_IN_VEHICLE_COST\")',\n        }\n\n        self.controller.emme_manager.matrix_calculator(\n            spec,\n            scenario=self.scenarios[time_period],\n            num_processors=self._num_processors,\n        )\n\n    @staticmethod\n    def _segments_with_modes(_network, _modes: Union[Collection[str], str]):\n        _modes = list(_modes)\n        segments = [\n            li.segments() for li in _network.transit_lines() if li.mode.id in _modes\n        ]\n        return segments\n\n    def _invehicle_time_by_mode_ccr(\n        self, time_period: str, transit_class: str, mode_combinations\n    ) -&gt; List[str]:\n        \"\"\"Calculate in-vehicle travel time by mode using CCR and store results in Emmebank.\n\n        Args:\n            time_period (_type_): time period abbreviation\n            transit_class (_type_): transit class name\n            mode_combinations (_type_): TODO\n\n        Returns:\n            List of matrix names in Emmebank to sum together to get total in-vehicle travel time.\n        \"\"\"\n\n        _network = self.networks[time_period]\n        _scenario = self.scenarios[time_period]\n        _tp_tclass = f\"{time_period}_{transit_class.name}\"\n        _total_ivtt_expr = []\n        create_temps = self.controller.emme_manager.temp_attributes_and_restore\n        temp_attrs = [[\"TRANSIT_SEGMENT\", \"@mode_timtr\", \"base time by mode\"]]\n        with create_temps(_scenario, temp_attrs):\n            for _mode_name, _modes in mode_combinations:\n                _network.create_attribute(\"TRANSIT_SEGMENT\", \"@mode_timtr\")\n                _li_segs_with_mode = TransitSkim._segments_with_modes(_network, _modes)\n                # set temp attribute @mode_timtr to contain the non-congested in-vehicle\n                # times for segments of the mode of interest\n                for line_segment in _li_segs_with_mode:\n                    for segment in line_segment:\n                        segment[\"@mode_timtr\"] = segment[\"@base_timtr\"]\n                # not sure why we to copy this if we are deleting it in next line? - ES\n                self.controller.emme_manager.copy_attribute_values(\n                    self.networks[time_period],\n                    _scenario,\n                    {\"TRANSIT_SEGMENT\": [\"@mode_timtr\"]},\n                )\n                self.networks[time_period].delete_attribute(\n                    \"TRANSIT_SEGMENT\", \"@mode_timtr\"\n                )\n                _ivtt_matrix_name = f'mf\"{_tp_tclass}_IVT{_mode_name}\"'\n                _total_ivtt_expr.append(_ivtt_matrix_name)\n                self._run_strategy_analysis(\n                    time_period,\n                    transit_class,\n                    {\"in_vehicle\": \"@mode_timtr\"},\n                    f\"IVT{_mode_name}\",\n                )\n        return _total_ivtt_expr\n\n    def _invehicle_time_by_mode_no_ccr(\n        self, time_period: str, transit_class: str, mode_combinations\n    ) -&gt; List[str]:\n        \"\"\"Calculate in-vehicle travel time by without CCR and store results in Emmebank.\n\n        Args:\n            time_period (_type_): time period abbreviation\n            transit_class (_type_): transit class name\n            mode_combinations (_type_): TODO\n\n        Returns: List of matrix names in Emmebank to sum together to get total in-vehicle travel time.\n\n        \"\"\"\n        _tp_tclass = f\"{time_period}_{transit_class.name}\"\n        _total_ivtt_expr = []\n        for _mode_name, modes in mode_combinations:\n            _ivtt_matrix_name = f'mf\"{_tp_tclass}_IVT{_mode_name}\"'\n            _total_ivtt_expr.append(_ivtt_matrix_name)\n            spec = {\n                \"type\": \"EXTENDED_TRANSIT_MATRIX_RESULTS\",\n                \"by_mode_subset\": {\n                    \"modes\": modes,\n                    \"actual_in_vehicle_times\": _ivtt_matrix_name,\n                },\n            }\n            self.controller.emme_manager.matrix_results(\n                spec,\n                class_name=transit_class.name,\n                scenario=self.scenarios[time_period],\n                num_processors=self._num_processors,\n            )\n        return _total_ivtt_expr\n\n    def skim_invehicle_time_by_mode(\n        self, time_period: str, transit_class: str, use_ccr: bool = False\n    ) -&gt; None:\n        \"\"\"Skim in-vehicle by mode for a time period and transit class and store results in Emmebank.\n\n        Args:\n            time_period (str): time period abbreviation\n            transit_class (str): transit class name\n            use_ccr (bool): if True, will use crowding, capacity, and reliability (ccr).\n                Defaults to False\n\n        \"\"\"\n        mode_combinations = self._get_emme_mode_ids(transit_class, time_period)\n        if use_ccr:\n            total_ivtt_expr = self._invehicle_time_by_mode_ccr(\n                time_period, transit_class, mode_combinations\n            )\n        else:\n            total_ivtt_expr = self._invehicle_time_by_mode_no_ccr(\n                time_period, transit_class, mode_combinations\n            )\n        # sum total ivtt across all modes\n        self._calc_total_ivt(time_period, transit_class, total_ivtt_expr)\n\n    def _calc_total_ivt(\n        self, time_period: str, transit_class: str, total_ivtt_expr: list[str]\n    ) -&gt; None:\n        \"\"\"Sums matrices to get total in vehicle time and stores in the Emmebank.\n\n        Args:\n            time_period (str): time period abbreviation\n            transit_class (str): transit class name\n            total_ivtt_expr (list[str]): List of matrix names in Emmebank which have IVT to sum to get total.\n        \"\"\"\n        _tp_tclass = f\"{time_period}_{transit_class.name}\"\n        spec = {\n            \"type\": \"MATRIX_CALCULATION\",\n            \"constraint\": None,\n            \"result\": f'mf\"{_tp_tclass }_IVT\"',\n            \"expression\": \"+\".join(total_ivtt_expr),\n        }\n\n        self.controller.emme_manager.matrix_calculator(\n            spec,\n            scenario=self.scenarios[time_period],\n            num_processors=self._num_processors,\n        )\n\n    def skim_drive_walk(self, time_period: str, transit_class: str) -&gt; None:\n        \"\"\"\"\"\"\n        _tp_tclass = f\"{time_period}_{transit_class.name}\"\n        # _network = self.networks[time_period]\n\n        # drive time here is perception factor*(drive time + toll penalty),\n        # will calculate the actual drive time and substract toll penalty in the following steps\n        spec1 = {\n            \"type\": \"EXTENDED_TRANSIT_MATRIX_RESULTS\",\n            \"by_mode_subset\": {\n                \"modes\": [\"D\"],\n                \"actual_aux_transit_times\": f'mf\"{_tp_tclass}_DTIME\"',\n                \"distance\": f'mf\"{_tp_tclass}_DDIST\"',\n            },\n        }\n        # skim walk distance in walk time matrices first,\n        # will calculate the actual walk time and overwrite the distance in the following steps\n        spec2 = {\n            \"type\": \"EXTENDED_TRANSIT_MATRIX_RESULTS\",\n            \"by_mode_subset\": {\n                \"modes\": [\"w\"],\n                \"distance\": f'mf\"{_tp_tclass}_WAUX\"',\n            },\n        }\n        spec3 = {\n            \"type\": \"EXTENDED_TRANSIT_MATRIX_RESULTS\",\n            \"by_mode_subset\": {\n                \"modes\": [\"a\"],\n                \"distance\": f'mf\"{_tp_tclass}_WACC\"',\n            },\n        }\n        spec4 = {\n            \"type\": \"EXTENDED_TRANSIT_MATRIX_RESULTS\",\n            \"by_mode_subset\": {\n                \"modes\": [\"e\"],\n                \"distance\": f'mf\"{_tp_tclass}_WEGR\"',\n            },\n        }\n        if transit_class.name not in ['WLK_TRN_WLK']:\n            self.controller.emme_manager.matrix_results(\n                spec1,\n                class_name=transit_class.name,\n                scenario=self.scenarios[time_period],\n                num_processors=self._num_processors,\n            )\n        self.controller.emme_manager.matrix_results(\n            spec2,\n            class_name=transit_class.name,\n            scenario=self.scenarios[time_period],\n            num_processors=self._num_processors,\n        )\n        if transit_class.name not in ['PNR_TRN_WLK','KNR_TRN_WLK']:\n            self.controller.emme_manager.matrix_results(\n                spec3,\n                class_name=transit_class.name,\n                scenario=self.scenarios[time_period],\n                num_processors=self._num_processors,\n            )\n        if transit_class.name not in ['WLK_TRN_PNR','WLK_TRN_KNR']:\n            self.controller.emme_manager.matrix_results(\n                spec4,\n                class_name=transit_class.name,\n                scenario=self.scenarios[time_period],\n                num_processors=self._num_processors,\n            )\n\n\n        drive_perception_factor = self.config.drive_perception_factor\n        walk_speed = self.config.walk_speed\n        vot = self.config.value_of_time\n        # divide drive time by mode specific perception factor to get the actual time\n        # for walk time, use walk distance/walk speed\n        # because the mode specific perception factors are hardcoded in the mode definition\n        spec_list = [\n            {\n                \"type\": \"MATRIX_CALCULATION\",\n                \"constraint\": None,\n                \"result\": f'mf\"{_tp_tclass}_DTIME\"',\n                \"expression\": f'mf\"{_tp_tclass}_DTIME\"/{drive_perception_factor}',\n            },\n            {\n                \"type\": \"MATRIX_CALCULATION\",\n                \"constraint\": None,\n                \"result\": f'mf\"{_tp_tclass}_DTIME\"',\n                \"expression\": f'mf\"{_tp_tclass}_DTIME\"',\n            },\n            {\n                \"type\": \"MATRIX_CALCULATION\",\n                \"constraint\": None,\n                \"result\": f'mf\"{_tp_tclass}_WAUX\"',\n                \"expression\": f'mf\"{_tp_tclass}_WAUX\"/({walk_speed}/60)',\n            },\n            {\n                \"type\": \"MATRIX_CALCULATION\",\n                \"constraint\": None,\n                \"result\": f'mf\"{_tp_tclass}_WACC\"',\n                \"expression\": f'mf\"{_tp_tclass}_WACC\"/({walk_speed}/60)',\n            },\n            {\n                \"type\": \"MATRIX_CALCULATION\",\n                \"constraint\": None,\n                \"result\": f'mf\"{_tp_tclass}_WEGR\"',\n                \"expression\": f'mf\"{_tp_tclass}_WEGR\"/({walk_speed}/60)',\n            },\n        ]\n        self.controller.emme_manager.matrix_calculator(\n            spec_list,\n            scenario=self.scenarios[time_period],\n            num_processors=self._num_processors,\n        )\n\n    def skim_penalty_toll(self, time_period: str, transit_class: str) -&gt; None:\n        \"\"\"\"\"\"\n        # transfer boarding time penalty\n        self._run_strategy_analysis(\n            time_period, transit_class, {\"boarding\": \"@xboard_nodepen\"}, \"XBOATIME\"\n        )\n\n        _tp_tclass = f\"{time_period}_{transit_class.name}\"\n        if (\"PNR_TRN_WLK\" in _tp_tclass) or (\"WLK_TRN_PNR\" in _tp_tclass):\n            spec = {  # subtract PNR boarding from total transfer boarding time penalty\n                \"type\": \"MATRIX_CALCULATION\",\n                \"constraint\": {\n                    \"by_value\": {\n                        \"od_values\": f'mf\"{_tp_tclass}_XBOATIME\"',\n                        \"interval_min\": 0,\n                        \"interval_max\": 9999999,\n                        \"condition\": \"INCLUDE\",\n                    }\n                },\n                \"result\": f'mf\"{_tp_tclass}_XBOATIME\"',\n                \"expression\": f'(mf\"{_tp_tclass}_XBOATIME\" - 1).max.0',\n            }\n\n            self.controller.emme_manager.matrix_calculator(\n                spec,\n                scenario=self.scenarios[time_period],\n                num_processors=self._num_processors,\n            )\n\n        # drive toll\n        if (\"PNR_TRN_WLK\" in _tp_tclass) or (\"KNR_TRN_WLK\" in _tp_tclass):\n            self._run_path_analysis(\n                time_period,\n                transit_class,\n                \"ORIGIN_TO_INITIAL_BOARDING\",\n                {\"aux_transit\": \"@drive_toll\"},\n                \"DTOLL\",\n            )\n        elif (\"WLK_TRN_PNR\" in _tp_tclass) or (\"WLK_TRN_KNR\" in _tp_tclass):\n            self._run_path_analysis(\n                time_period,\n                transit_class,\n                \"FINAL_ALIGHTING_TO_DESTINATION\",\n                {\"aux_transit\": \"@drive_toll\"},\n                \"DTOLL\",\n            )\n\n    def _get_emme_mode_ids(\n        self, transit_class, time_period\n    ) -&gt; List[Tuple[str, List[str]]]:\n        \"\"\"Get the Emme mode IDs used in the assignment.\n\n        Loads the #src_mode attribute on lines if fares are used, and the\n        @base_timtr on segments if ccr is used.\n\n        Returns:\n            List of tuples of two items, the original mode name (from config)\n            to a list of mode IDs used in the Emme assignment. This list\n            will be one item if fares are not used, but will contain the fare\n            modes used in the journey levels mode-to-mode transfer table\n            generated from Apply fares.\n        \"\"\"\n        if self.config.use_fares:\n            self.controller.emme_manager.copy_attribute_values(\n                self.scenarios[time_period],\n                self.networks[time_period],\n                {\"TRANSIT_LINE\": [\"#src_mode\"]},\n            )\n        if self.config.use_ccr:\n            self.controller.emme_manager.copy_attribute_values(\n                self.scenarios[time_period],\n                self.networks[time_period],\n                {\"TRANSIT_SEGMENT\": [\"@base_timtr\"]},\n            )\n        valid_modes = [\n            mode\n            for mode in self.config.modes\n            if mode.type in transit_class.mode_types\n            and mode.assign_type == \"TRANSIT\"\n            and mode.type != \"PNR_dummy\"\n        ]\n        if self.config.use_fares:\n            # map to used modes in apply fares case\n            fare_modes = defaultdict(lambda: set([]))\n            for line in self.networks[time_period].transit_lines():\n                fare_modes[line[\"#src_mode\"]].add(line.mode.id)\n            emme_mode_ids = [\n                (mode.name, list(fare_modes[mode.mode_id]))\n                for mode in valid_modes\n                if len(list(fare_modes[mode.mode_id])) &gt; 0\n            ]\n        else:\n            emme_mode_ids = [(mode.name, [mode.mode_id]) for mode in valid_modes]\n        return emme_mode_ids\n\n    def skim_reliability_crowding_capacity(\n        self, time_period: str, transit_class\n    ) -&gt; None:\n        \"\"\"Generate skim results for CCR assignment and stores results in Emmebank.\n\n        Generates the following:\n        1. Link Unreliability: LINKREL\n        2. Crowding penalty: CROWD\n        3. Extra added wait time: EAWT\n        4. Capacity penalty: CAPPEN\n\n        Args:\n            time_period (str): time period abbreviation\n            transit_class: transit class\n        \"\"\"\n\n        # Link unreliability\n        self._run_strategy_analysis(\n            time_period, transit_class, {\"in_vehicle\": \"ul1\"}, \"LINKREL\"\n        )\n        # Crowding penalty\n        self._run_strategy_analysis(\n            time_period, transit_class, {\"in_vehicle\": \"@ccost\"}, \"CROWD\"\n        )\n        # skim node reliability, extra added wait time (EAWT)\n        self._run_strategy_analysis(\n            time_period, transit_class, {\"boarding\": \"@eawt\"}, \"EAWT\"\n        )\n        # skim capacity penalty\n        self._run_strategy_analysis(\n            time_period, transit_class, {\"boarding\": \"@capacity_penalty\"}, \"CAPPEN\"\n        )\n\n    def skim_crowding(self, time_period: str, transit_class) -&gt; None:\n        \"\"\"\"\"\"\n        # Crowding penalty\n        self._run_strategy_analysis(\n            time_period, transit_class, {\"in_vehicle\": \"@ccost\"}, \"CROWD\"\n        )\n\n    def _run_strategy_analysis(\n        self,\n        time_period: str,\n        transit_class,\n        components: Dict[str, str],\n        matrix_name_suffix: str,\n    ):\n        \"\"\"Runs strategy analysis in Emme and stores results in emmebank.\n\n        Args:\n            time_period (str): Time period name abbreviation\n            transit_class (_type_): _description_\n            components (Dict[str, str]): _description_\n            matrix_name_suffix (str): Appended to time period and transit class name to create output matrix name.\n        \"\"\"\n        _tp_tclass = f\"{time_period}_{transit_class.name}\"\n        _matrix_name = f'mf\"{_tp_tclass}_{matrix_name_suffix}\"'\n        strategy_analysis = self.controller.emme_manager.tool(\n            \"inro.emme.transit_assignment.extended.strategy_based_analysis\"\n        )\n\n        spec = {\n            \"trip_components\": components,\n            \"sub_path_combination_operator\": \"+\",\n            \"sub_strategy_combination_operator\": \"average\",\n            \"selected_demand_and_transit_volumes\": {\n                \"sub_strategies_to_retain\": \"ALL\",\n                \"selection_threshold\": {\"lower\": -999999, \"upper\": 999999},\n            },\n            \"analyzed_demand\": f\"mfTRN_{transit_class.name}_{time_period}\",\n            \"constraint\": None,\n            \"results\": {\"strategy_values\": _matrix_name},\n            \"type\": \"EXTENDED_TRANSIT_STRATEGY_ANALYSIS\",\n        }\n        strategy_analysis(\n            spec,\n            class_name=transit_class.name,\n            scenario=self.scenarios[time_period],\n            num_processors=self._num_processors,\n        )\n\n    def _run_path_analysis(\n        self,\n        time_period: str,\n        transit_class,\n        portion_of_path: str,\n        components: Dict[str, str],\n        matrix_name_suffix: str,\n    ):\n        \"\"\"Runs path analysis in Emme and stores results in emmebank.\n\n        Args:\n            time_period (str): Time period name abbreviation\n            transit_class (_type_): _description_\n            components (Dict[str, str]): _description_\n            matrix_name_suffix (str): Appended to time period and transit class name to create output matrix name.\n        \"\"\"\n        _tp_tclass = f\"{time_period}_{transit_class.name}\"\n        _matrix_name = f'mf\"{_tp_tclass}_{matrix_name_suffix}\"'\n        path_analysis = self.controller.emme_manager.tool(\n            \"inro.emme.transit_assignment.extended.path_based_analysis\"\n        )\n\n        spec = {\n            \"portion_of_path\": portion_of_path,\n            \"trip_components\": components,\n            \"path_operator\": \"+\",\n            \"path_selection_threshold\": {\"lower\": -999999, \"upper\": 999999},\n            \"path_to_od_aggregation\": {\n                \"operator\": \"average\",\n                \"aggregated_path_values\": _matrix_name,\n            },\n            \"analyzed_demand\": None,\n            \"constraint\": None,\n            \"type\": \"EXTENDED_TRANSIT_PATH_ANALYSIS\",\n        }\n        path_analysis(\n            spec,\n            class_name=transit_class.name,\n            scenario=self.scenarios[time_period],\n            num_processors=self._num_processors,\n        )\n\n    def mask_if_not_required_modes(self, time_period: str, transit_class) -&gt; None:\n        \"\"\"\n        Enforce the `required_mode_combo` parameter by setting IVTs to 0 if don't have required modes.\n\n        Args:\n            time_period (str): Time period name abbreviation\n            transit_class (_type_): _description_\n        \"\"\"\n        if not transit_class.required_mode_combo:\n            return\n\n        _ivt_skims = {}\n        for mode in transit_class.required_mode_combo:\n            transit_modes = [m for m in self.config.modes if m.type == mode]\n            for transit_mode in transit_modes:\n                if mode not in _ivt_skims.keys():\n                    _ivt_skims[mode] = self.matrix_cache[time_period].get_data(\n                        f'mf\"{time_period}_{transit_class.name}_{transit_mode.name}IVTT\"'\n                    )\n                else:\n                    _ivt_skims[mode] += self.matrix_cache[time_period].get_data(\n                        f'mf\"{time_period}_{transit_class.name}_{transit_mode.name}IVTT\"'\n                    )\n\n        # multiply all IVT skims together and see if they are greater than zero\n        has_all = None\n        for key, value in _ivt_skims.items():\n            if has_all is not None:\n                has_all = np.multiply(has_all, value)\n            else:\n                has_all = value\n\n        self._mask_skim_set(time_period, transit_class, has_all)\n\n    def mask_above_max_transfers(self, time_period: str, transit_class):\n        \"\"\"Reset skims to 0 if number of transfers is greater than max_transfers.\n\n        Args:\n            time_period (str): Time period name abbreviation\n            transit_class (_type_): _description_\n        \"\"\"\n        max_transfers = self.config.max_transfers\n        xfers = self.matrix_cache[time_period].get_data(\n            f'mf\"{time_period}_{transit_class.name}_XFERS\"'\n        )\n        xfer_mask = np.less_equal(xfers, max_transfers)\n        self._mask_skim_set(time_period, transit_class, xfer_mask)\n\n    def _mask_skim_set(self, time_period: str, transit_class, mask_array: NumpyArray):\n        \"\"\"Mask a skim set (set of skims for a given time period and transit class) based on an array.\n\n        Array values of &gt;0 are kept. Zero are not.\n\n        TODO add in checks for mask_array dimensions and values\n\n        Args:\n            time_period (str): Time period name abbreviation\n            transit_class (_type_): _description_\n            mask_array (NumpyArray): _description_\n        \"\"\"\n        mask_array = np.greater(mask_array, 0)\n        mask_array = np.less(mask_array, inf)\n        for skim_key, skim in self.emmebank_skim_matrices(\n            time_periods=[time_period], transit_classes=[transit_class]\n        ).items():\n            skim_data = self.matrix_cache[time_period].get_data(skim.name)\n            self.matrix_cache[time_period].set_data(skim.name, skim_data * mask_array)\n\n    def _export_skims(self, time_period: str, transit_class: str):\n        \"\"\"Export skims to OMX files by period.\"\"\"\n        # NOTE: skims in separate file by period\n        output_skim_path = self.get_abs_path(self.config.output_skim_path)\n        omx_file_path = os.path.join(\n            output_skim_path,\n            self.config.output_skim_filename_tmpl.format(\n                time_period=time_period, tclass=transit_class.name\n            ),\n        )\n        os.makedirs(os.path.dirname(omx_file_path), exist_ok=True)\n\n        _matrices = self.emmebank_skim_matrices(\n            time_periods=[time_period], \n            transit_classes=[transit_class],\n            skim_properties=self.skim_outputs\n\n        )\n\n        with OMXManager(\n            omx_file_path,\n            \"w\",\n            self.scenarios[time_period],\n            matrix_cache=self.matrix_cache[time_period],\n            mask_max_value=1e7,\n            growth_factor=1,\n        ) as omx_file:\n            omx_file.write_matrices(_matrices)\n\n    def _log_debug_report(self, _time_period):\n        num_zones = len(self.scenarios[_time_period].zone_numbers)\n        num_cells = num_zones * num_zones\n        self.logger.log(\n            f\"Transit impedance summary for period {_time_period}\", level=\"DEBUG\"\n        )\n        self.logger.log(\n            f\"Number of zones: {num_zones}. Number of O-D pairs: {num_cells}. \"\n            \"Values outside -9999999, 9999999 are masked in summaries.\",\n            level=\"DEBUG\",\n        )\n        self.logger.log(\n            \"name                            min       max      mean           sum\",\n            level=\"DEBUG\",\n        )\n\n        temp = self.emmebank_skim_matrices(time_periods=[_time_period])\n\n        for matrix_name in temp.keys():\n            matrix_name = f'mf\"{matrix_name}\"'\n            values = self.matrix_cache[_time_period].get_data(matrix_name)\n            data = np.ma.masked_outside(values, -9999999, 9999999)\n            stats = (\n                f\"{matrix_name:25} {data.min():9.4g} {data.max():9.4g} \"\n                f\"{data.mean():9.4g} {data.sum(): 13.7g}\"\n            )\n            self.logger.log(stats, level=\"DEBUG\")\n\n    @staticmethod\n    def _copy_attribute_values(src, dst, attributes):\n        for domain, attrs in attributes.items():\n            values = src.get_attribute_values(domain, attrs)\n            dst.set_attribute_values(domain, attrs, values)\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.skim_outputs","title":"<code>skim_outputs</code>  <code>property</code>","text":"<p>List of Skim Property named tuples: name, description.</p> <p>TODO put these in config.</p>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.skim_properties","title":"<code>skim_properties</code>  <code>property</code>","text":"<p>List of Skim Property named tuples: name, description.</p> <p>TODO put these in config.</p>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.__init__","title":"<code>__init__(controller)</code>","text":"<p>Constructor for TransitSkim class.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>'RunController'</code> <p>The RunController instance.</p> required Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>def __init__(self, controller: \"RunController\"):\n    \"\"\"Constructor for TransitSkim class.\n\n    Args:\n        controller: The RunController instance.\n    \"\"\"\n    super().__init__(controller)\n    self.config = self.controller.config.transit\n    self._emmebank = None\n    self._num_processors = self.controller.emme_manager.num_processors_transit_skim\n    self._networks = None\n    self._scenarios = None\n    self._matrix_cache = None\n    self._skim_properties = None\n    self._skim_matrices = {\n        k: None\n        for k in itertools.product(\n            self.time_period_names,\n            self.config.classes,\n            self.skim_properties,\n        )\n    }\n    self._skim_outputs = None\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.emmebank_skim_matrices","title":"<code>emmebank_skim_matrices(time_periods=None, transit_classes=None, skim_properties=None)</code>","text":"<p>Gets skim matrices from emmebank, or lazily creates them if they don\u2019t already exist.</p> Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>def emmebank_skim_matrices(\n    self,\n    time_periods: List[str] = None,\n    transit_classes=None,\n    skim_properties: Skimproperty = None,\n) -&gt; dict:\n    \"\"\"Gets skim matrices from emmebank, or lazily creates them if they don't already exist.\"\"\"\n    create_matrix = self.controller.emme_manager.tool(\n        \"inro.emme.data.matrix.create_matrix\"\n    )\n    if time_periods is None:\n        time_periods = self.time_period_names\n    if not set(time_periods).issubset(set(self.time_period_names)):\n        raise ValueError(\n            f\"time_periods ({time_periods}) must be subset of time_period_names ({self.time_period_names}).\"\n        )\n\n    if transit_classes is None:\n        transit_classes = self.config.classes\n    if not set(transit_classes).issubset(set(self.config.classes)):\n        raise ValueError(\n            f\"time_periods ({transit_classes}) must be subset of time_period_names ({self.config.transit_classes}).\"\n        )\n\n    if skim_properties is None:\n        skim_properties = self.skim_properties\n    if not set(skim_properties).issubset(set(self.skim_properties)):\n        raise ValueError(\n            f\"time_periods ({skim_properties}) must be subset of time_period_names ({self.skim_properties}).\"\n        )\n\n    _tp_tclass_skprop = itertools.product(\n        time_periods, transit_classes, skim_properties\n    )\n    _tp_tclass_skprop_list = []\n\n    for _tp, _tclass, _skprop in _tp_tclass_skprop:\n        a = 1\n        _name = f\"{_tp}_{_tclass.name}_{_skprop.name}\"\n        _desc = f\"{_tp} {_tclass.description}: {_skprop.desc}\"\n        _matrix = self.scenarios[_tp].emmebank.matrix(f'mf\"{_name}\"')\n        if not _matrix:\n            _matrix = create_matrix(\n                \"mf\", _name, _desc, scenario=self.scenarios[_tp], overwrite=True\n            )\n        else:\n            _matrix.description = _desc\n\n        self._skim_matrices[_name] = _matrix\n        _tp_tclass_skprop_list.append(_name)\n\n    skim_matrices = {\n        k: v\n        for k, v in self._skim_matrices.items()\n        if k in list(_tp_tclass_skprop_list)\n    }\n    return skim_matrices\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.mask_above_max_transfers","title":"<code>mask_above_max_transfers(time_period, transit_class)</code>","text":"<p>Reset skims to 0 if number of transfers is greater than max_transfers.</p> <p>Parameters:</p> Name Type Description Default <code>time_period</code> <code>str</code> <p>Time period name abbreviation</p> required <code>transit_class</code> <code>_type_</code> <p>description</p> required Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>def mask_above_max_transfers(self, time_period: str, transit_class):\n    \"\"\"Reset skims to 0 if number of transfers is greater than max_transfers.\n\n    Args:\n        time_period (str): Time period name abbreviation\n        transit_class (_type_): _description_\n    \"\"\"\n    max_transfers = self.config.max_transfers\n    xfers = self.matrix_cache[time_period].get_data(\n        f'mf\"{time_period}_{transit_class.name}_XFERS\"'\n    )\n    xfer_mask = np.less_equal(xfers, max_transfers)\n    self._mask_skim_set(time_period, transit_class, xfer_mask)\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.mask_if_not_required_modes","title":"<code>mask_if_not_required_modes(time_period, transit_class)</code>","text":"<p>Enforce the <code>required_mode_combo</code> parameter by setting IVTs to 0 if don\u2019t have required modes.</p> <p>Parameters:</p> Name Type Description Default <code>time_period</code> <code>str</code> <p>Time period name abbreviation</p> required <code>transit_class</code> <code>_type_</code> <p>description</p> required Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>def mask_if_not_required_modes(self, time_period: str, transit_class) -&gt; None:\n    \"\"\"\n    Enforce the `required_mode_combo` parameter by setting IVTs to 0 if don't have required modes.\n\n    Args:\n        time_period (str): Time period name abbreviation\n        transit_class (_type_): _description_\n    \"\"\"\n    if not transit_class.required_mode_combo:\n        return\n\n    _ivt_skims = {}\n    for mode in transit_class.required_mode_combo:\n        transit_modes = [m for m in self.config.modes if m.type == mode]\n        for transit_mode in transit_modes:\n            if mode not in _ivt_skims.keys():\n                _ivt_skims[mode] = self.matrix_cache[time_period].get_data(\n                    f'mf\"{time_period}_{transit_class.name}_{transit_mode.name}IVTT\"'\n                )\n            else:\n                _ivt_skims[mode] += self.matrix_cache[time_period].get_data(\n                    f'mf\"{time_period}_{transit_class.name}_{transit_mode.name}IVTT\"'\n                )\n\n    # multiply all IVT skims together and see if they are greater than zero\n    has_all = None\n    for key, value in _ivt_skims.items():\n        if has_all is not None:\n            has_all = np.multiply(has_all, value)\n        else:\n            has_all = value\n\n    self._mask_skim_set(time_period, transit_class, has_all)\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.run","title":"<code>run()</code>","text":"<p>Run transit skims.</p> Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>@LogStartEnd(\"Transit skims\")\ndef run(self):\n    \"\"\"Run transit skims.\"\"\"\n    self.emmebank_skim_matrices(\n        self.time_period_names, self.config.classes, self.skim_properties\n    )\n    with self.logger.log_start_end(f\"period transit skims\"):\n        for _time_period in self.time_period_names:\n            with self.controller.emme_manager.logbook_trace(\n                f\"Transit skims for period {_time_period}\"\n            ):\n                for _transit_class in self.config.classes:\n                    self.run_skim_set(_time_period, _transit_class)\n                    self._export_skims(_time_period, _transit_class)\n                if self.logger.debug_enabled:\n                    self._log_debug_report(_time_period)\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.run_skim_set","title":"<code>run_skim_set(time_period, transit_class)</code>","text":"<p>Run the transit skim calculations for a given time period and assignment class.</p> <p>Results are stored in transit emmebank.</p> Steps <ol> <li>determine if using transit capacity constraint</li> <li>skim walk, wait time, boardings, and fares</li> <li>skim in vehicle time by mode</li> <li>mask transfers above max amount</li> <li>mask if doesn\u2019t have required modes</li> </ol> Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>def run_skim_set(self, time_period: str, transit_class: str):\n    \"\"\"Run the transit skim calculations for a given time period and assignment class.\n\n    Results are stored in transit emmebank.\n\n    Steps:\n        1. determine if using transit capacity constraint\n        2. skim walk, wait time, boardings, and fares\n        3. skim in vehicle time by mode\n        4. mask transfers above max amount\n        5. mask if doesn't have required modes\n    \"\"\"\n    use_ccr = False\n    congested_transit_assignment = self.config.congested_transit_assignment\n    if self.controller.iteration &gt;= 1:\n        use_ccr = self.config.use_ccr\n    with self.controller.emme_manager.logbook_trace(\n        \"First and total wait time, number of boardings, \"\n        \"fares, and total and transfer walk time\"\n    ):\n        self.skim_walk_wait_boards_fares(time_period, transit_class)\n    with self.controller.emme_manager.logbook_trace(\"In-vehicle time by mode\"):\n        self.skim_invehicle_time_by_mode(time_period, transit_class, use_ccr)\n    with self.controller.emme_manager.logbook_trace(\n        \"Drive distance and time\",\n        \"Walk auxiliary time, walk access time and walk egress time\",\n    ):\n        self.skim_drive_walk(time_period, transit_class)\n    with self.controller.emme_manager.logbook_trace(\"Calculate crowding\"):\n        self.skim_crowding(time_period, transit_class)\n    if use_ccr:\n        with self.controller.emme_manager.logbook_trace(\"CCR related skims\"):\n            self.skim_reliability_crowding_capacity(time_period, transit_class)\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.skim_crowding","title":"<code>skim_crowding(time_period, transit_class)</code>","text":"Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>def skim_crowding(self, time_period: str, transit_class) -&gt; None:\n    \"\"\"\"\"\"\n    # Crowding penalty\n    self._run_strategy_analysis(\n        time_period, transit_class, {\"in_vehicle\": \"@ccost\"}, \"CROWD\"\n    )\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.skim_drive_walk","title":"<code>skim_drive_walk(time_period, transit_class)</code>","text":"Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>def skim_drive_walk(self, time_period: str, transit_class: str) -&gt; None:\n    \"\"\"\"\"\"\n    _tp_tclass = f\"{time_period}_{transit_class.name}\"\n    # _network = self.networks[time_period]\n\n    # drive time here is perception factor*(drive time + toll penalty),\n    # will calculate the actual drive time and substract toll penalty in the following steps\n    spec1 = {\n        \"type\": \"EXTENDED_TRANSIT_MATRIX_RESULTS\",\n        \"by_mode_subset\": {\n            \"modes\": [\"D\"],\n            \"actual_aux_transit_times\": f'mf\"{_tp_tclass}_DTIME\"',\n            \"distance\": f'mf\"{_tp_tclass}_DDIST\"',\n        },\n    }\n    # skim walk distance in walk time matrices first,\n    # will calculate the actual walk time and overwrite the distance in the following steps\n    spec2 = {\n        \"type\": \"EXTENDED_TRANSIT_MATRIX_RESULTS\",\n        \"by_mode_subset\": {\n            \"modes\": [\"w\"],\n            \"distance\": f'mf\"{_tp_tclass}_WAUX\"',\n        },\n    }\n    spec3 = {\n        \"type\": \"EXTENDED_TRANSIT_MATRIX_RESULTS\",\n        \"by_mode_subset\": {\n            \"modes\": [\"a\"],\n            \"distance\": f'mf\"{_tp_tclass}_WACC\"',\n        },\n    }\n    spec4 = {\n        \"type\": \"EXTENDED_TRANSIT_MATRIX_RESULTS\",\n        \"by_mode_subset\": {\n            \"modes\": [\"e\"],\n            \"distance\": f'mf\"{_tp_tclass}_WEGR\"',\n        },\n    }\n    if transit_class.name not in ['WLK_TRN_WLK']:\n        self.controller.emme_manager.matrix_results(\n            spec1,\n            class_name=transit_class.name,\n            scenario=self.scenarios[time_period],\n            num_processors=self._num_processors,\n        )\n    self.controller.emme_manager.matrix_results(\n        spec2,\n        class_name=transit_class.name,\n        scenario=self.scenarios[time_period],\n        num_processors=self._num_processors,\n    )\n    if transit_class.name not in ['PNR_TRN_WLK','KNR_TRN_WLK']:\n        self.controller.emme_manager.matrix_results(\n            spec3,\n            class_name=transit_class.name,\n            scenario=self.scenarios[time_period],\n            num_processors=self._num_processors,\n        )\n    if transit_class.name not in ['WLK_TRN_PNR','WLK_TRN_KNR']:\n        self.controller.emme_manager.matrix_results(\n            spec4,\n            class_name=transit_class.name,\n            scenario=self.scenarios[time_period],\n            num_processors=self._num_processors,\n        )\n\n\n    drive_perception_factor = self.config.drive_perception_factor\n    walk_speed = self.config.walk_speed\n    vot = self.config.value_of_time\n    # divide drive time by mode specific perception factor to get the actual time\n    # for walk time, use walk distance/walk speed\n    # because the mode specific perception factors are hardcoded in the mode definition\n    spec_list = [\n        {\n            \"type\": \"MATRIX_CALCULATION\",\n            \"constraint\": None,\n            \"result\": f'mf\"{_tp_tclass}_DTIME\"',\n            \"expression\": f'mf\"{_tp_tclass}_DTIME\"/{drive_perception_factor}',\n        },\n        {\n            \"type\": \"MATRIX_CALCULATION\",\n            \"constraint\": None,\n            \"result\": f'mf\"{_tp_tclass}_DTIME\"',\n            \"expression\": f'mf\"{_tp_tclass}_DTIME\"',\n        },\n        {\n            \"type\": \"MATRIX_CALCULATION\",\n            \"constraint\": None,\n            \"result\": f'mf\"{_tp_tclass}_WAUX\"',\n            \"expression\": f'mf\"{_tp_tclass}_WAUX\"/({walk_speed}/60)',\n        },\n        {\n            \"type\": \"MATRIX_CALCULATION\",\n            \"constraint\": None,\n            \"result\": f'mf\"{_tp_tclass}_WACC\"',\n            \"expression\": f'mf\"{_tp_tclass}_WACC\"/({walk_speed}/60)',\n        },\n        {\n            \"type\": \"MATRIX_CALCULATION\",\n            \"constraint\": None,\n            \"result\": f'mf\"{_tp_tclass}_WEGR\"',\n            \"expression\": f'mf\"{_tp_tclass}_WEGR\"/({walk_speed}/60)',\n        },\n    ]\n    self.controller.emme_manager.matrix_calculator(\n        spec_list,\n        scenario=self.scenarios[time_period],\n        num_processors=self._num_processors,\n    )\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.skim_invehicle_time_by_mode","title":"<code>skim_invehicle_time_by_mode(time_period, transit_class, use_ccr=False)</code>","text":"<p>Skim in-vehicle by mode for a time period and transit class and store results in Emmebank.</p> <p>Parameters:</p> Name Type Description Default <code>time_period</code> <code>str</code> <p>time period abbreviation</p> required <code>transit_class</code> <code>str</code> <p>transit class name</p> required <code>use_ccr</code> <code>bool</code> <p>if True, will use crowding, capacity, and reliability (ccr). Defaults to False</p> <code>False</code> Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>def skim_invehicle_time_by_mode(\n    self, time_period: str, transit_class: str, use_ccr: bool = False\n) -&gt; None:\n    \"\"\"Skim in-vehicle by mode for a time period and transit class and store results in Emmebank.\n\n    Args:\n        time_period (str): time period abbreviation\n        transit_class (str): transit class name\n        use_ccr (bool): if True, will use crowding, capacity, and reliability (ccr).\n            Defaults to False\n\n    \"\"\"\n    mode_combinations = self._get_emme_mode_ids(transit_class, time_period)\n    if use_ccr:\n        total_ivtt_expr = self._invehicle_time_by_mode_ccr(\n            time_period, transit_class, mode_combinations\n        )\n    else:\n        total_ivtt_expr = self._invehicle_time_by_mode_no_ccr(\n            time_period, transit_class, mode_combinations\n        )\n    # sum total ivtt across all modes\n    self._calc_total_ivt(time_period, transit_class, total_ivtt_expr)\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.skim_penalty_toll","title":"<code>skim_penalty_toll(time_period, transit_class)</code>","text":"Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>def skim_penalty_toll(self, time_period: str, transit_class: str) -&gt; None:\n    \"\"\"\"\"\"\n    # transfer boarding time penalty\n    self._run_strategy_analysis(\n        time_period, transit_class, {\"boarding\": \"@xboard_nodepen\"}, \"XBOATIME\"\n    )\n\n    _tp_tclass = f\"{time_period}_{transit_class.name}\"\n    if (\"PNR_TRN_WLK\" in _tp_tclass) or (\"WLK_TRN_PNR\" in _tp_tclass):\n        spec = {  # subtract PNR boarding from total transfer boarding time penalty\n            \"type\": \"MATRIX_CALCULATION\",\n            \"constraint\": {\n                \"by_value\": {\n                    \"od_values\": f'mf\"{_tp_tclass}_XBOATIME\"',\n                    \"interval_min\": 0,\n                    \"interval_max\": 9999999,\n                    \"condition\": \"INCLUDE\",\n                }\n            },\n            \"result\": f'mf\"{_tp_tclass}_XBOATIME\"',\n            \"expression\": f'(mf\"{_tp_tclass}_XBOATIME\" - 1).max.0',\n        }\n\n        self.controller.emme_manager.matrix_calculator(\n            spec,\n            scenario=self.scenarios[time_period],\n            num_processors=self._num_processors,\n        )\n\n    # drive toll\n    if (\"PNR_TRN_WLK\" in _tp_tclass) or (\"KNR_TRN_WLK\" in _tp_tclass):\n        self._run_path_analysis(\n            time_period,\n            transit_class,\n            \"ORIGIN_TO_INITIAL_BOARDING\",\n            {\"aux_transit\": \"@drive_toll\"},\n            \"DTOLL\",\n        )\n    elif (\"WLK_TRN_PNR\" in _tp_tclass) or (\"WLK_TRN_KNR\" in _tp_tclass):\n        self._run_path_analysis(\n            time_period,\n            transit_class,\n            \"FINAL_ALIGHTING_TO_DESTINATION\",\n            {\"aux_transit\": \"@drive_toll\"},\n            \"DTOLL\",\n        )\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.skim_reliability_crowding_capacity","title":"<code>skim_reliability_crowding_capacity(time_period, transit_class)</code>","text":"<p>Generate skim results for CCR assignment and stores results in Emmebank.</p> <p>Generates the following: 1. Link Unreliability: LINKREL 2. Crowding penalty: CROWD 3. Extra added wait time: EAWT 4. Capacity penalty: CAPPEN</p> <p>Parameters:</p> Name Type Description Default <code>time_period</code> <code>str</code> <p>time period abbreviation</p> required <code>transit_class</code> <p>transit class</p> required Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>def skim_reliability_crowding_capacity(\n    self, time_period: str, transit_class\n) -&gt; None:\n    \"\"\"Generate skim results for CCR assignment and stores results in Emmebank.\n\n    Generates the following:\n    1. Link Unreliability: LINKREL\n    2. Crowding penalty: CROWD\n    3. Extra added wait time: EAWT\n    4. Capacity penalty: CAPPEN\n\n    Args:\n        time_period (str): time period abbreviation\n        transit_class: transit class\n    \"\"\"\n\n    # Link unreliability\n    self._run_strategy_analysis(\n        time_period, transit_class, {\"in_vehicle\": \"ul1\"}, \"LINKREL\"\n    )\n    # Crowding penalty\n    self._run_strategy_analysis(\n        time_period, transit_class, {\"in_vehicle\": \"@ccost\"}, \"CROWD\"\n    )\n    # skim node reliability, extra added wait time (EAWT)\n    self._run_strategy_analysis(\n        time_period, transit_class, {\"boarding\": \"@eawt\"}, \"EAWT\"\n    )\n    # skim capacity penalty\n    self._run_strategy_analysis(\n        time_period, transit_class, {\"boarding\": \"@capacity_penalty\"}, \"CAPPEN\"\n    )\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.skim_walk_wait_boards_fares","title":"<code>skim_walk_wait_boards_fares(time_period, transit_class)</code>","text":"<p>Skim wait, walk, board, and fares for a given time period and transit assignment class.</p> <p>Skim the first and total wait time, number of boardings, (transfers + 1) fares, total walk time, total in-vehicle time.</p> Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>def skim_walk_wait_boards_fares(self, time_period: str, transit_class: str):\n    \"\"\"Skim wait, walk, board, and fares for a given time period and transit assignment class.\n\n    Skim the first and total wait time, number of boardings, (transfers + 1)\n    fares, total walk time, total in-vehicle time.\n    \"\"\"\n    _tp_tclass = f\"{time_period}_{transit_class.name}\"\n    _network = self.networks[time_period]\n    _transit_mode_ids = [\n        m.id for m in _network.modes() if m.type in [\"TRANSIT\", \"AUX_TRANSIT\"]\n    ]\n    spec = {\n        \"type\": \"EXTENDED_TRANSIT_MATRIX_RESULTS\",\n        \"actual_first_waiting_times\": f'mf\"{_tp_tclass}_IWAIT\"',\n        \"actual_total_waiting_times\": f'mf\"{_tp_tclass}_WAIT\"',\n        \"by_mode_subset\": {\n            \"modes\": _transit_mode_ids,\n            \"avg_boardings\": f'mf\"{_tp_tclass}_BOARDS\"',\n        },\n    }\n    if self.config.use_fares:\n        spec[\"by_mode_subset\"].update(\n            {\n                \"actual_in_vehicle_costs\": f'mf\"{_tp_tclass}_IN_VEHICLE_COST\"',\n                \"actual_total_boarding_costs\": f'mf\"{_tp_tclass}_FARE\"',\n            }\n        )\n\n    self.controller.emme_manager.matrix_results(\n        spec,\n        class_name=transit_class.name,\n        scenario=self.scenarios[time_period],\n        num_processors=self._num_processors,\n    )\n\n    self._calc_xfer_wait(time_period, transit_class.name)\n    self._calc_boardings(time_period, transit_class.name)\n    if self.config.use_fares:\n        self._calc_fares(time_period, transit_class.name)\n</code></pre>"},{"location":"api/#tm2py.components.network.transit.transit_skim.TransitSkim.validate_inputs","title":"<code>validate_inputs()</code>","text":"<p>Validate inputs.</p> Source code in <code>tm2py/components/network/transit/transit_skim.py</code> <pre><code>def validate_inputs(self):\n    \"\"\"Validate inputs.\"\"\"\n    # TODO add input validation\n    pass\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.headway_fraction_valid","title":"<code>headway_fraction_valid(value, values)</code>","text":"<p>Validate headway_fraction exists if assign_type is TRANSIT.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"headway_fraction\", always=True)\ndef headway_fraction_valid(value, values):\n    \"\"\"Validate headway_fraction exists if assign_type is TRANSIT.\"\"\"\n    if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n        assert value is not None, \"must be specified when assign_type==TRANSIT\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.in_vehicle_perception_factor_valid","title":"<code>in_vehicle_perception_factor_valid(value, values)</code>","text":"<p>Validate in_vehicle_perception_factor exists if assign_type is TRANSIT.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"in_vehicle_perception_factor\", always=True)\ndef in_vehicle_perception_factor_valid(cls, value, values):\n    \"\"\"Validate in_vehicle_perception_factor exists if assign_type is TRANSIT.\"\"\"\n    if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n        assert value is not None, \"must be specified when assign_type==TRANSIT\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.initial_boarding_penalty_valid","title":"<code>initial_boarding_penalty_valid(value, values)</code>","text":"<p>Validate initial_boarding_penalty exists if assign_type is TRANSIT.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"initial_boarding_penalty\", always=True)\ndef initial_boarding_penalty_valid(value, values):\n    \"\"\"Validate initial_boarding_penalty exists if assign_type is TRANSIT.\"\"\"\n    if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n        assert value is not None, \"must be specified when assign_type==TRANSIT\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.mode_id_valid","title":"<code>mode_id_valid(value)</code>  <code>classmethod</code>","text":"<p>Validate mode_id.</p> Source code in <code>tm2py/config.py</code> <pre><code>@classmethod\n@validator(\"mode_id\")\ndef mode_id_valid(cls, value):\n    \"\"\"Validate mode_id.\"\"\"\n    assert len(value) == 1, \"mode_id must be one character\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.speed_or_time_factor_valid","title":"<code>speed_or_time_factor_valid(value, values)</code>","text":"<p>Validate speed_or_time_factor exists if assign_type is AUX_TRANSIT.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"speed_or_time_factor\", always=True)\ndef speed_or_time_factor_valid(cls, value, values):\n    \"\"\"Validate speed_or_time_factor exists if assign_type is AUX_TRANSIT.\"\"\"\n    if \"assign_type\" in values and values[\"assign_type\"] == \"AUX_TRANSIT\":\n        assert value is not None, \"must be specified when assign_type==AUX_TRANSIT\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.transfer_boarding_penalty_valid","title":"<code>transfer_boarding_penalty_valid(value, values)</code>","text":"<p>Validate transfer_boarding_penalty exists if assign_type is TRANSIT.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"transfer_boarding_penalty\", always=True)\ndef transfer_boarding_penalty_valid(value, values):\n    \"\"\"Validate transfer_boarding_penalty exists if assign_type is TRANSIT.\"\"\"\n    if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n        assert value is not None, \"must be specified when assign_type==TRANSIT\"\n    return value\n</code></pre>"},{"location":"api/#tm2py.config.TransitModeConfig.transfer_wait_perception_factor_valid","title":"<code>transfer_wait_perception_factor_valid(value, values)</code>","text":"<p>Validate transfer_wait_perception_factor exists if assign_type is TRANSIT.</p> Source code in <code>tm2py/config.py</code> <pre><code>@validator(\"transfer_wait_perception_factor\", always=True)\ndef transfer_wait_perception_factor_valid(value, values):\n    \"\"\"Validate transfer_wait_perception_factor exists if assign_type is TRANSIT.\"\"\"\n    if \"assign_type\" in values and values[\"assign_type\"] == \"TRANSIT\":\n        assert value is not None, \"must be specified when assign_type==TRANSIT\"\n    return value\n</code></pre>"},{"location":"api/#active-network-components","title":"Active Network Components","text":"<p>To come.</p>"},{"location":"api/#emme-wrappers","title":"Emme Wrappers","text":"<p>Emme components module.</p> <p>               Bases: <code>ConfigItem</code></p> <p>Emme-specific parameters.</p> Properties Source code in <code>tm2py/config.py</code> <pre><code>@dataclass(frozen=True)\nclass EmmeConfig(ConfigItem):\n    \"\"\"Emme-specific parameters.\n\n    Properties:\n        all_day_scenario_id: scenario ID to use for all day\n            (initial imported) scenario with all time period data\n        project_path: relative path from run_dir to Emme desktop project (.emp)\n        highway_database_path: relative path to highway Emmebank\n        active_north_database_path:  relative paths to active mode Emmebank for north bay\n        active_south_database_path:  relative paths to active mode Emmebank for south bay\n        transit_database_path: relative path to transit Emmebank\n        num_processors: the number of processors to use in Emme procedures,\n            either as an integer, or value MAX, MAX-N. Typically recommend\n            using MAX-1 (on desktop systems) or MAX-2 (on servers with many\n            logical processors) to leave capacity for background / other tasks.\n    \"\"\"\n\n    all_day_scenario_id: int\n    project_path: pathlib.Path\n    highway_database_path: pathlib.Path\n    active_north_database_path: pathlib.Path\n    active_south_database_path: pathlib.Path\n    transit_database_path: pathlib.Path\n    num_processors: str = Field(regex=r\"^MAX$|^MAX-\\d+$|^\\d+$|^MAX/\\d+$\")\n    num_processors_transit_skim: str = Field(regex=r\"^MAX$|^MAX-\\d+$|^\\d+$|^MAX/\\d+$\")\n    highway_distribution: Optional[List[HighwayDistribution]] = Field(default=None)\n</code></pre>"},{"location":"api/#errata","title":"Errata","text":"<p>Logging module.</p> <p>Note the general definition of logging levels as used in tm2py:</p> highly detailed level information which would rarely be of interest <p>except for detailed debugging by a developer</p> <p>Tools module for common resources / shared code and \u201cutilities\u201d in the tm2py package.</p> <p>Download and unzip examples for tm2py, used in tests.</p>"},{"location":"api/#tm2py.logger.BaseLogger","title":"<code>BaseLogger</code>","text":"<p>Base class for logging. Not to be constructed directly.</p> Source code in <code>tm2py/logger.py</code> <pre><code>class BaseLogger:\n    \"Base class for logging. Not to be constructed directly.\"\n\n    def __init__(self, log_formatters, log_cache_file):\n        self._indentation = 0\n        self._log_cache = LogCache(log_cache_file)\n        self._log_formatters = log_formatters + [self._log_cache]\n\n        # these will be set later via set_emme_manager()\n        self._emme_manager = None\n        self._use_emme_logbook = False\n\n        for log_formatter in self._log_formatters:\n            if hasattr(log_formatter, \"open\"):\n                log_formatter.open()\n\n    def set_emme_manager(self,emme_manager: EmmeManagerLight):\n        if self.controller.config.logging.use_emme_logbook and self.controller.has_emme:\n            self._emme_manager = emme_manager\n            self._use_emme_logbook = emme_manager is not None\n\n    def __del__(self):\n        \"\"\"\n        Destructor for logger object\n        \"\"\"\n        if self._log_formatters:\n            for log_formatter in self._log_formatters:\n                if hasattr(log_formatter, \"close\"):\n                    log_formatter.close()\n\n    def log(self, text: str, level: LogLevel = \"INFO\", indent: bool = True):\n        \"\"\"Log text to file and display depending upon log level and config.\n\n        Args:\n            text (str): text to log\n            level (str): logging level\n            indent (bool): if true indent text based on the number of open contexts\n        \"\"\"\n        timestamp = datetime.now().strftime(\"%d-%b-%Y (%H:%M:%S) \")\n        for log_formatter in self._log_formatters:\n            log_formatter.log(text, LEVELS_STR_TO_INT[level], indent, timestamp)\n        if self._use_emme_logbook:\n            self._emme_manager.logbook_write(text)\n\n    def trace(self, text: str, indent: bool = False):\n        \"\"\"Log text with level=TRACE.\n\n        Args:\n            text (str): text to log\n            indent (bool): if true indent text based on the number of open contexts\n        \"\"\"\n        self.log(text, \"TRACE\", indent)\n\n    def debug(self, text: str, indent: bool = False):\n        \"\"\"Log text with level=DEBUG.\n\n        Args:\n            text (str): text to log\n            indent (bool): if true indent text based on the number of open contexts\n        \"\"\"\n        self.log(text, \"DEBUG\", indent)\n\n    def detail(self, text: str, indent: bool = False):\n        \"\"\"Log text with level=DETAIL.\n\n        Args:\n            text (str): text to log\n            indent (bool): if true indent text based on the number of open contexts\n        \"\"\"\n        self.log(text, \"DETAIL\", indent)\n\n    def info(self, text: str, indent: bool = False):\n        \"\"\"Log text with level=INFO.\n\n        Args:\n            text (str): text to log\n            indent (bool): if true indent text based on the number of open contexts\n        \"\"\"\n        self.log(text, \"INFO\", indent)\n\n    def status(self, text: str, indent: bool = False):\n        \"\"\"Log text with level=STATUS.\n\n        Args:\n            text (str): text to log\n            indent (bool): if true indent text based on the number of open contexts\n        \"\"\"\n        self.log(text, \"STATUS\", indent)\n\n    def warn(self, text: str, indent: bool = False):\n        \"\"\"Log text with level=WARN.\n\n        Args:\n            text (str): text to log\n            indent (bool): if true indent text based on the number of open contexts\n        \"\"\"\n        self.log(text, \"WARN\", indent)\n\n    def error(self, text: str, indent: bool = False):\n        \"\"\"Log text with level=ERROR.\n\n        Args:\n            text (str): text to log\n            indent (bool): if true indent text based on the number of open contexts\n        \"\"\"\n        self.log(text, \"ERROR\", indent)\n\n    def fatal(self, text: str, indent: bool = False):\n        \"\"\"Log text with level=FATAL.\n\n        Args:\n            text (str): text to log\n            indent (bool): if true indent text based on the number of open contexts\n        \"\"\"\n        self.log(text, \"FATAL\", indent)\n\n    def log_time(self, text: str, level=1, indent=False):\n        \"\"\"Log message with timestamp\"\"\"\n        timestamp = datetime.now().strftime(\"%d-%b-%Y (%H:%M:%S)\")\n        if indent:\n            indent = \"  \" * self._indentation\n            self.log(f\"{timestamp}: {indent}{text}\", level)\n        else:\n            self.log(f\"{timestamp}: {text}\", level)\n\n    def _log_start(self, text: str, level: LogLevel = \"INFO\"):\n        \"\"\"Log message with timestamp and 'Start'.\n\n        Args:\n            text (str): message text\n            level (str): logging level\n        \"\"\"\n        self.log(f\"Start {text}\", level, indent=True)\n        for log_formatter in self._log_formatters:\n            log_formatter.increase_indent(LEVELS_STR_TO_INT[level])\n\n    def _log_end(self, text: str, level: LogLevel = \"INFO\"):\n        \"\"\"Log message with timestamp and 'End'.\n\n        Args:\n            text (str): message text\n            level (str): logging level\n        \"\"\"\n        for log_formatter in self._log_formatters:\n            log_formatter.decrease_indent(LEVELS_STR_TO_INT[level])\n        self.log(f\"End {text}\", level, indent=True)\n\n    @_context\n    def log_start_end(self, text: str, level: LogLevel = \"STATUS\"):\n        \"\"\"Use with 'with' statement to log the start and end time with message.\n\n        If using the Emme logbook (config.logging.use_emme_logbook is True), will\n        also create a logbook nest in the tree view using logbook_trace.\n\n        Args:\n            text (str): message text\n            level (str): logging level\n        \"\"\"\n        with self._skip_emme_logging():\n            self._log_start(text, level)\n        if self._use_emme_logbook:\n            with self._emme_manager.logbook_trace(text):\n                yield\n        else:\n            yield\n        with self._skip_emme_logging():\n            self._log_end(text, level)\n\n    def log_dict(self, mapping: dict, level: LogLevel = \"DEBUG\"):\n        \"\"\"Format dictionary to string and log as text.\"\"\"\n        self.log(pformat(mapping, indent=1, width=120), level)\n\n    @_context\n    def _skip_emme_logging(self):\n        \"\"\"Temporary disable Emme logging (if enabled) and restore on exit.\n\n        Intended use is with the log_start_end context and LogStartEnd decorator\n        to allow use of the Emme context without double logging of the\n        messages in the Emme logbook.\n        \"\"\"\n        self._use_emme_logbook, use_emme = False, self._use_emme_logbook\n        yield\n        self._use_emme_logbook = use_emme\n\n    def clear_msg_cache(self):\n        \"\"\"Clear all log messages from cache.\"\"\"\n        self._log_cache.clear()\n\n    @property\n    def debug_enabled(self) -&gt; bool:\n        \"\"\"Returns True if DEBUG is currently filtered for display or print to file.\n\n        Can be used to enable / disable debug logging which may have a performance\n        impact.\n        \"\"\"\n        debug = LEVELS_STR_TO_INT[\"DEBUG\"]\n        for log_formatter in self._log_formatters:\n            if log_formatter is not self._log_cache and log_formatter.level &lt;= debug:\n                return True\n        return False\n\n    @property\n    def trace_enabled(self) -&gt; bool:\n        \"\"\"Returns True if TRACE is currently filtered for display or print to file.\n\n        Can be used to enable / disable trace logging which may have a performance\n        impact.\n        \"\"\"\n        trace = LEVELS_STR_TO_INT[\"TRACE\"]\n        for log_formatter in self._log_formatters:\n            if log_formatter is not self._log_cache and log_formatter.level &lt;= trace:\n                return True\n        return False\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.debug_enabled","title":"<code>debug_enabled: bool</code>  <code>property</code>","text":"<p>Returns True if DEBUG is currently filtered for display or print to file.</p> <p>Can be used to enable / disable debug logging which may have a performance impact.</p>"},{"location":"api/#tm2py.logger.BaseLogger.trace_enabled","title":"<code>trace_enabled: bool</code>  <code>property</code>","text":"<p>Returns True if TRACE is currently filtered for display or print to file.</p> <p>Can be used to enable / disable trace logging which may have a performance impact.</p>"},{"location":"api/#tm2py.logger.BaseLogger.__del__","title":"<code>__del__()</code>","text":"<p>Destructor for logger object</p> Source code in <code>tm2py/logger.py</code> <pre><code>def __del__(self):\n    \"\"\"\n    Destructor for logger object\n    \"\"\"\n    if self._log_formatters:\n        for log_formatter in self._log_formatters:\n            if hasattr(log_formatter, \"close\"):\n                log_formatter.close()\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.clear_msg_cache","title":"<code>clear_msg_cache()</code>","text":"<p>Clear all log messages from cache.</p> Source code in <code>tm2py/logger.py</code> <pre><code>def clear_msg_cache(self):\n    \"\"\"Clear all log messages from cache.\"\"\"\n    self._log_cache.clear()\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.debug","title":"<code>debug(text, indent=False)</code>","text":"<p>Log text with level=DEBUG.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to log</p> required <code>indent</code> <code>bool</code> <p>if true indent text based on the number of open contexts</p> <code>False</code> Source code in <code>tm2py/logger.py</code> <pre><code>def debug(self, text: str, indent: bool = False):\n    \"\"\"Log text with level=DEBUG.\n\n    Args:\n        text (str): text to log\n        indent (bool): if true indent text based on the number of open contexts\n    \"\"\"\n    self.log(text, \"DEBUG\", indent)\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.detail","title":"<code>detail(text, indent=False)</code>","text":"<p>Log text with level=DETAIL.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to log</p> required <code>indent</code> <code>bool</code> <p>if true indent text based on the number of open contexts</p> <code>False</code> Source code in <code>tm2py/logger.py</code> <pre><code>def detail(self, text: str, indent: bool = False):\n    \"\"\"Log text with level=DETAIL.\n\n    Args:\n        text (str): text to log\n        indent (bool): if true indent text based on the number of open contexts\n    \"\"\"\n    self.log(text, \"DETAIL\", indent)\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.error","title":"<code>error(text, indent=False)</code>","text":"<p>Log text with level=ERROR.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to log</p> required <code>indent</code> <code>bool</code> <p>if true indent text based on the number of open contexts</p> <code>False</code> Source code in <code>tm2py/logger.py</code> <pre><code>def error(self, text: str, indent: bool = False):\n    \"\"\"Log text with level=ERROR.\n\n    Args:\n        text (str): text to log\n        indent (bool): if true indent text based on the number of open contexts\n    \"\"\"\n    self.log(text, \"ERROR\", indent)\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.fatal","title":"<code>fatal(text, indent=False)</code>","text":"<p>Log text with level=FATAL.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to log</p> required <code>indent</code> <code>bool</code> <p>if true indent text based on the number of open contexts</p> <code>False</code> Source code in <code>tm2py/logger.py</code> <pre><code>def fatal(self, text: str, indent: bool = False):\n    \"\"\"Log text with level=FATAL.\n\n    Args:\n        text (str): text to log\n        indent (bool): if true indent text based on the number of open contexts\n    \"\"\"\n    self.log(text, \"FATAL\", indent)\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.info","title":"<code>info(text, indent=False)</code>","text":"<p>Log text with level=INFO.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to log</p> required <code>indent</code> <code>bool</code> <p>if true indent text based on the number of open contexts</p> <code>False</code> Source code in <code>tm2py/logger.py</code> <pre><code>def info(self, text: str, indent: bool = False):\n    \"\"\"Log text with level=INFO.\n\n    Args:\n        text (str): text to log\n        indent (bool): if true indent text based on the number of open contexts\n    \"\"\"\n    self.log(text, \"INFO\", indent)\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.log","title":"<code>log(text, level='INFO', indent=True)</code>","text":"<p>Log text to file and display depending upon log level and config.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to log</p> required <code>level</code> <code>str</code> <p>logging level</p> <code>'INFO'</code> <code>indent</code> <code>bool</code> <p>if true indent text based on the number of open contexts</p> <code>True</code> Source code in <code>tm2py/logger.py</code> <pre><code>def log(self, text: str, level: LogLevel = \"INFO\", indent: bool = True):\n    \"\"\"Log text to file and display depending upon log level and config.\n\n    Args:\n        text (str): text to log\n        level (str): logging level\n        indent (bool): if true indent text based on the number of open contexts\n    \"\"\"\n    timestamp = datetime.now().strftime(\"%d-%b-%Y (%H:%M:%S) \")\n    for log_formatter in self._log_formatters:\n        log_formatter.log(text, LEVELS_STR_TO_INT[level], indent, timestamp)\n    if self._use_emme_logbook:\n        self._emme_manager.logbook_write(text)\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.log_dict","title":"<code>log_dict(mapping, level='DEBUG')</code>","text":"<p>Format dictionary to string and log as text.</p> Source code in <code>tm2py/logger.py</code> <pre><code>def log_dict(self, mapping: dict, level: LogLevel = \"DEBUG\"):\n    \"\"\"Format dictionary to string and log as text.\"\"\"\n    self.log(pformat(mapping, indent=1, width=120), level)\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.log_start_end","title":"<code>log_start_end(text, level='STATUS')</code>","text":"<p>Use with \u2018with\u2019 statement to log the start and end time with message.</p> <p>If using the Emme logbook (config.logging.use_emme_logbook is True), will also create a logbook nest in the tree view using logbook_trace.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>message text</p> required <code>level</code> <code>str</code> <p>logging level</p> <code>'STATUS'</code> Source code in <code>tm2py/logger.py</code> <pre><code>@_context\ndef log_start_end(self, text: str, level: LogLevel = \"STATUS\"):\n    \"\"\"Use with 'with' statement to log the start and end time with message.\n\n    If using the Emme logbook (config.logging.use_emme_logbook is True), will\n    also create a logbook nest in the tree view using logbook_trace.\n\n    Args:\n        text (str): message text\n        level (str): logging level\n    \"\"\"\n    with self._skip_emme_logging():\n        self._log_start(text, level)\n    if self._use_emme_logbook:\n        with self._emme_manager.logbook_trace(text):\n            yield\n    else:\n        yield\n    with self._skip_emme_logging():\n        self._log_end(text, level)\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.log_time","title":"<code>log_time(text, level=1, indent=False)</code>","text":"<p>Log message with timestamp</p> Source code in <code>tm2py/logger.py</code> <pre><code>def log_time(self, text: str, level=1, indent=False):\n    \"\"\"Log message with timestamp\"\"\"\n    timestamp = datetime.now().strftime(\"%d-%b-%Y (%H:%M:%S)\")\n    if indent:\n        indent = \"  \" * self._indentation\n        self.log(f\"{timestamp}: {indent}{text}\", level)\n    else:\n        self.log(f\"{timestamp}: {text}\", level)\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.status","title":"<code>status(text, indent=False)</code>","text":"<p>Log text with level=STATUS.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to log</p> required <code>indent</code> <code>bool</code> <p>if true indent text based on the number of open contexts</p> <code>False</code> Source code in <code>tm2py/logger.py</code> <pre><code>def status(self, text: str, indent: bool = False):\n    \"\"\"Log text with level=STATUS.\n\n    Args:\n        text (str): text to log\n        indent (bool): if true indent text based on the number of open contexts\n    \"\"\"\n    self.log(text, \"STATUS\", indent)\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.trace","title":"<code>trace(text, indent=False)</code>","text":"<p>Log text with level=TRACE.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to log</p> required <code>indent</code> <code>bool</code> <p>if true indent text based on the number of open contexts</p> <code>False</code> Source code in <code>tm2py/logger.py</code> <pre><code>def trace(self, text: str, indent: bool = False):\n    \"\"\"Log text with level=TRACE.\n\n    Args:\n        text (str): text to log\n        indent (bool): if true indent text based on the number of open contexts\n    \"\"\"\n    self.log(text, \"TRACE\", indent)\n</code></pre>"},{"location":"api/#tm2py.logger.BaseLogger.warn","title":"<code>warn(text, indent=False)</code>","text":"<p>Log text with level=WARN.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to log</p> required <code>indent</code> <code>bool</code> <p>if true indent text based on the number of open contexts</p> <code>False</code> Source code in <code>tm2py/logger.py</code> <pre><code>def warn(self, text: str, indent: bool = False):\n    \"\"\"Log text with level=WARN.\n\n    Args:\n        text (str): text to log\n        indent (bool): if true indent text based on the number of open contexts\n    \"\"\"\n    self.log(text, \"WARN\", indent)\n</code></pre>"},{"location":"api/#tm2py.logger.LogCache","title":"<code>LogCache</code>","text":"<p>               Bases: <code>LogFormatter</code></p> <p>Caches all messages for later recording in on error logfile.</p> Properties <ul> <li>file_path: the absolute file path to write to</li> </ul> Source code in <code>tm2py/logger.py</code> <pre><code>class LogCache(LogFormatter):\n    \"\"\"Caches all messages for later recording in on error logfile.\n\n    Properties:\n        - file_path: the absolute file path to write to\n    \"\"\"\n\n    def __init__(self, file_path: str):\n        \"\"\"Constructor for LogCache object.\n\n        Args:\n            file_path (str): the absolute file path to write to.\n        \"\"\"\n        super().__init__(level=0)\n        self.file_path = file_path\n        self._msg_cache = []\n\n    def open(self):\n        \"\"\"Initialize log file (remove).\"\"\"\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def log(self, text: str, level: int, indent: bool, timestamp: Union[str, None]):\n        \"\"\"Format and store text for later recording.\n\n        Args:\n            text (str): text to log\n            level (int): logging level\n            indent (bool): if true indent text based on the number of open contexts\n            timestamp (str): formatted datetime as a string or None\n        \"\"\"\n        self._msg_cache.append(\n            (level, self._format_text(text, level, indent, timestamp))\n        )\n\n    def write_cache(self):\n        \"\"\"Write all cached messages.\"\"\"\n        with open(self.file_path, \"w\", encoding=\"utf8\") as file:\n            for level, text in self._msg_cache:\n                file.write(f\"{LEVELS_INT_TO_STR[level]:6} {text}\\n\")\n        self.clear()\n\n    def clear(self):\n        \"\"\"Clear message cache.\"\"\"\n        self._msg_cache = []\n</code></pre>"},{"location":"api/#tm2py.logger.LogCache.__init__","title":"<code>__init__(file_path)</code>","text":"<p>Constructor for LogCache object.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>the absolute file path to write to.</p> required Source code in <code>tm2py/logger.py</code> <pre><code>def __init__(self, file_path: str):\n    \"\"\"Constructor for LogCache object.\n\n    Args:\n        file_path (str): the absolute file path to write to.\n    \"\"\"\n    super().__init__(level=0)\n    self.file_path = file_path\n    self._msg_cache = []\n</code></pre>"},{"location":"api/#tm2py.logger.LogCache.clear","title":"<code>clear()</code>","text":"<p>Clear message cache.</p> Source code in <code>tm2py/logger.py</code> <pre><code>def clear(self):\n    \"\"\"Clear message cache.\"\"\"\n    self._msg_cache = []\n</code></pre>"},{"location":"api/#tm2py.logger.LogCache.log","title":"<code>log(text, level, indent, timestamp)</code>","text":"<p>Format and store text for later recording.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to log</p> required <code>level</code> <code>int</code> <p>logging level</p> required <code>indent</code> <code>bool</code> <p>if true indent text based on the number of open contexts</p> required <code>timestamp</code> <code>str</code> <p>formatted datetime as a string or None</p> required Source code in <code>tm2py/logger.py</code> <pre><code>def log(self, text: str, level: int, indent: bool, timestamp: Union[str, None]):\n    \"\"\"Format and store text for later recording.\n\n    Args:\n        text (str): text to log\n        level (int): logging level\n        indent (bool): if true indent text based on the number of open contexts\n        timestamp (str): formatted datetime as a string or None\n    \"\"\"\n    self._msg_cache.append(\n        (level, self._format_text(text, level, indent, timestamp))\n    )\n</code></pre>"},{"location":"api/#tm2py.logger.LogCache.open","title":"<code>open()</code>","text":"<p>Initialize log file (remove).</p> Source code in <code>tm2py/logger.py</code> <pre><code>def open(self):\n    \"\"\"Initialize log file (remove).\"\"\"\n    if os.path.exists(self.file_path):\n        os.remove(self.file_path)\n</code></pre>"},{"location":"api/#tm2py.logger.LogCache.write_cache","title":"<code>write_cache()</code>","text":"<p>Write all cached messages.</p> Source code in <code>tm2py/logger.py</code> <pre><code>def write_cache(self):\n    \"\"\"Write all cached messages.\"\"\"\n    with open(self.file_path, \"w\", encoding=\"utf8\") as file:\n        for level, text in self._msg_cache:\n            file.write(f\"{LEVELS_INT_TO_STR[level]:6} {text}\\n\")\n    self.clear()\n</code></pre>"},{"location":"api/#tm2py.logger.LogDisplay","title":"<code>LogDisplay</code>","text":"<p>               Bases: <code>LogFormatter</code></p> <p>Format and print log text to console / Notebook.</p> Properties <ul> <li>level: the log level as an int</li> </ul> Source code in <code>tm2py/logger.py</code> <pre><code>class LogDisplay(LogFormatter):\n    \"\"\"Format and print log text to console / Notebook.\n\n    Properties:\n        - level: the log level as an int\n    \"\"\"\n\n    def log(self, text: str, level: int, indent: bool, timestamp: Union[str, None]):\n        \"\"\"Format and display text on screen (print).\n\n        Args:\n            text (str): text to log\n            level (int): logging level\n            indent (bool): if true indent text based on the number of open contexts\n            timestamp (str): formatted datetime as a string or None\n        \"\"\"\n        if level &gt;= self.level:\n            print(self._format_text(text, level, indent, timestamp))\n</code></pre>"},{"location":"api/#tm2py.logger.LogDisplay.log","title":"<code>log(text, level, indent, timestamp)</code>","text":"<p>Format and display text on screen (print).</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to log</p> required <code>level</code> <code>int</code> <p>logging level</p> required <code>indent</code> <code>bool</code> <p>if true indent text based on the number of open contexts</p> required <code>timestamp</code> <code>str</code> <p>formatted datetime as a string or None</p> required Source code in <code>tm2py/logger.py</code> <pre><code>def log(self, text: str, level: int, indent: bool, timestamp: Union[str, None]):\n    \"\"\"Format and display text on screen (print).\n\n    Args:\n        text (str): text to log\n        level (int): logging level\n        indent (bool): if true indent text based on the number of open contexts\n        timestamp (str): formatted datetime as a string or None\n    \"\"\"\n    if level &gt;= self.level:\n        print(self._format_text(text, level, indent, timestamp))\n</code></pre>"},{"location":"api/#tm2py.logger.LogFile","title":"<code>LogFile</code>","text":"<p>               Bases: <code>LogFormatter</code></p> <p>Format and write log text to file.</p> Properties <ul> <li>level: the log level as an int</li> <li>file_path: the absolute file path to write to</li> </ul> Source code in <code>tm2py/logger.py</code> <pre><code>class LogFile(LogFormatter):\n    \"\"\"Format and write log text to file.\n\n    Properties:\n        - level: the log level as an int\n        - file_path: the absolute file path to write to\n    \"\"\"\n\n    def __init__(self, level: int, file_path: str):\n        \"\"\"Constructor for LogFile object.\n\n        Args:\n            level (int): the log level as an int.\n            file_path (str): the absolute file path to write to.\n        \"\"\"\n        super().__init__(level)\n        self.file_path = file_path\n        self.log_file = None\n\n    def open(self):\n        \"\"\"Open the log file for writing.\"\"\"\n        self.log_file = open(self.file_path, \"w\", encoding=\"utf8\")\n\n    def log(self, text: str, level: int, indent: bool, timestamp: Union[str, None]):\n        \"\"\"Log text to file and display depending upon log level and config.\n\n        Note that log will not write to file until opened with a context.\n\n        Args:\n            text (str): text to log\n            level (int): logging level\n            indent (bool): if true indent text based on the number of open contexts\n            timestamp (str): formatted datetime as a string or None for timestamp\n        \"\"\"\n        if level &gt;= self.level and self.log_file is not None:\n            text = self._format_text(text, level, indent, timestamp)\n            self.log_file.write(f\"{text}\\n\")\n            self.log_file.flush()\n\n    def close(self):\n        \"\"\"Close the open log file.\"\"\"\n        self.log_file.close()\n        self.log_file = None\n</code></pre>"},{"location":"api/#tm2py.logger.LogFile.__init__","title":"<code>__init__(level, file_path)</code>","text":"<p>Constructor for LogFile object.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>the log level as an int.</p> required <code>file_path</code> <code>str</code> <p>the absolute file path to write to.</p> required Source code in <code>tm2py/logger.py</code> <pre><code>def __init__(self, level: int, file_path: str):\n    \"\"\"Constructor for LogFile object.\n\n    Args:\n        level (int): the log level as an int.\n        file_path (str): the absolute file path to write to.\n    \"\"\"\n    super().__init__(level)\n    self.file_path = file_path\n    self.log_file = None\n</code></pre>"},{"location":"api/#tm2py.logger.LogFile.close","title":"<code>close()</code>","text":"<p>Close the open log file.</p> Source code in <code>tm2py/logger.py</code> <pre><code>def close(self):\n    \"\"\"Close the open log file.\"\"\"\n    self.log_file.close()\n    self.log_file = None\n</code></pre>"},{"location":"api/#tm2py.logger.LogFile.log","title":"<code>log(text, level, indent, timestamp)</code>","text":"<p>Log text to file and display depending upon log level and config.</p> <p>Note that log will not write to file until opened with a context.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to log</p> required <code>level</code> <code>int</code> <p>logging level</p> required <code>indent</code> <code>bool</code> <p>if true indent text based on the number of open contexts</p> required <code>timestamp</code> <code>str</code> <p>formatted datetime as a string or None for timestamp</p> required Source code in <code>tm2py/logger.py</code> <pre><code>def log(self, text: str, level: int, indent: bool, timestamp: Union[str, None]):\n    \"\"\"Log text to file and display depending upon log level and config.\n\n    Note that log will not write to file until opened with a context.\n\n    Args:\n        text (str): text to log\n        level (int): logging level\n        indent (bool): if true indent text based on the number of open contexts\n        timestamp (str): formatted datetime as a string or None for timestamp\n    \"\"\"\n    if level &gt;= self.level and self.log_file is not None:\n        text = self._format_text(text, level, indent, timestamp)\n        self.log_file.write(f\"{text}\\n\")\n        self.log_file.flush()\n</code></pre>"},{"location":"api/#tm2py.logger.LogFile.open","title":"<code>open()</code>","text":"<p>Open the log file for writing.</p> Source code in <code>tm2py/logger.py</code> <pre><code>def open(self):\n    \"\"\"Open the log file for writing.\"\"\"\n    self.log_file = open(self.file_path, \"w\", encoding=\"utf8\")\n</code></pre>"},{"location":"api/#tm2py.logger.LogFileLevelOverride","title":"<code>LogFileLevelOverride</code>","text":"<p>               Bases: <code>LogFile</code></p> <p>Format and write log text to file.</p> Properties <ul> <li>level: the log level as an int</li> <li>file_path: the absolute file path to write to</li> <li>iter_component_level: TODO</li> <li>controller: TODO</li> </ul> Source code in <code>tm2py/logger.py</code> <pre><code>class LogFileLevelOverride(LogFile):\n    \"\"\"Format and write log text to file.\n\n    Properties:\n        - level: the log level as an int\n        - file_path: the absolute file path to write to\n        - iter_component_level: TODO\n        - controller: TODO\n    \"\"\"\n\n    def __init__(self, level, file_path, iter_component_level, controller):\n        \"\"\"Constructor for LogFileLevelOverride object.\n\n        Args:\n            level (_type_): TODO\n            file_path (_type_): TODO\n            iter_component_level (_type_): TODO\n            controller (_type_): TODO\n        \"\"\"\n        super().__init__(level, file_path)\n        self.iter_component_level = iter_component_level\n        self.controller = controller\n\n    @property\n    def level(self):\n        \"\"\"Current log level with iter_component_level config override.\"\"\"\n        return self.iter_component_level.get(\n            self.controller.iter_component, self._level\n        )\n</code></pre>"},{"location":"api/#tm2py.logger.LogFileLevelOverride.level","title":"<code>level</code>  <code>property</code>","text":"<p>Current log level with iter_component_level config override.</p>"},{"location":"api/#tm2py.logger.LogFileLevelOverride.__init__","title":"<code>__init__(level, file_path, iter_component_level, controller)</code>","text":"<p>Constructor for LogFileLevelOverride object.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>_type_</code> <p>TODO</p> required <code>file_path</code> <code>_type_</code> <p>TODO</p> required <code>iter_component_level</code> <code>_type_</code> <p>TODO</p> required <code>controller</code> <code>_type_</code> <p>TODO</p> required Source code in <code>tm2py/logger.py</code> <pre><code>def __init__(self, level, file_path, iter_component_level, controller):\n    \"\"\"Constructor for LogFileLevelOverride object.\n\n    Args:\n        level (_type_): TODO\n        file_path (_type_): TODO\n        iter_component_level (_type_): TODO\n        controller (_type_): TODO\n    \"\"\"\n    super().__init__(level, file_path)\n    self.iter_component_level = iter_component_level\n    self.controller = controller\n</code></pre>"},{"location":"api/#tm2py.logger.LogFormatter","title":"<code>LogFormatter</code>","text":"<p>Base class for recording text to log.</p> Properties Source code in <code>tm2py/logger.py</code> <pre><code>class LogFormatter:\n    \"\"\"Base class for recording text to log.\n\n    Properties:\n        indent: current indentation level for the LogFormatter\n        level: log filter level (as an int)\n    \"\"\"\n\n    def __init__(self, level: int):\n        \"\"\"Constructor for LogFormatter.\n\n        Args:\n            level (int): log filter level (as an int)\n        \"\"\"\n        self._level = level\n        self.indent = 0\n\n    @property\n    def level(self):\n        \"\"\"The current filter level for the LogFormatter.\"\"\"\n        return self._level\n\n    def increase_indent(self, level: int):\n        \"\"\"Increase current indent if the log level is filtered in.\"\"\"\n        if level &gt;= self.level:\n            self.indent += 1\n\n    def decrease_indent(self, level: int):\n        \"\"\"Decrease current indent if the log level is filtered in.\"\"\"\n        if level &gt;= self.level:\n            self.indent -= 1\n\n    @abstractmethod\n    def log(\n        self,\n        text: str,\n        level: int,\n        indent: bool,\n        timestamp: Union[str, None],\n    ):\n        \"\"\"Format and log message text.\n\n        Args:\n            text (str): text to log\n            level (int): logging level\n            indent (bool): if true indent text based on the number of open contexts\n            timestamp (str): formatted datetime as a string or None\n        \"\"\"\n\n    def _format_text(\n        self,\n        text: str,\n        level: int,\n        indent: bool,\n        timestamp: Union[str, None],\n    ):\n        \"\"\"Format text for logging.\n\n        Args:\n            text (str): text to format\n            level (int): logging level\n            indent (bool): if true indent text based on the number of open contexts and\n                timestamp width\n            timestamp (str): formatted datetime as a string or None for timestamp\n        \"\"\"\n        if timestamp is None:\n            timestamp = \"                        \" if indent else \"\"\n        if indent:\n            num_indents = self.indent\n            indent = \"  \" * max(num_indents, 0)\n        else:\n            indent = \"\"\n        return f\"{timestamp}{LEVELS_INT_TO_STR[level]:&gt;6}: {indent}{text}\"\n</code></pre>"},{"location":"api/#tm2py.logger.LogFormatter.level","title":"<code>level</code>  <code>property</code>","text":"<p>The current filter level for the LogFormatter.</p>"},{"location":"api/#tm2py.logger.LogFormatter.__init__","title":"<code>__init__(level)</code>","text":"<p>Constructor for LogFormatter.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>log filter level (as an int)</p> required Source code in <code>tm2py/logger.py</code> <pre><code>def __init__(self, level: int):\n    \"\"\"Constructor for LogFormatter.\n\n    Args:\n        level (int): log filter level (as an int)\n    \"\"\"\n    self._level = level\n    self.indent = 0\n</code></pre>"},{"location":"api/#tm2py.logger.LogFormatter.decrease_indent","title":"<code>decrease_indent(level)</code>","text":"<p>Decrease current indent if the log level is filtered in.</p> Source code in <code>tm2py/logger.py</code> <pre><code>def decrease_indent(self, level: int):\n    \"\"\"Decrease current indent if the log level is filtered in.\"\"\"\n    if level &gt;= self.level:\n        self.indent -= 1\n</code></pre>"},{"location":"api/#tm2py.logger.LogFormatter.increase_indent","title":"<code>increase_indent(level)</code>","text":"<p>Increase current indent if the log level is filtered in.</p> Source code in <code>tm2py/logger.py</code> <pre><code>def increase_indent(self, level: int):\n    \"\"\"Increase current indent if the log level is filtered in.\"\"\"\n    if level &gt;= self.level:\n        self.indent += 1\n</code></pre>"},{"location":"api/#tm2py.logger.LogFormatter.log","title":"<code>log(text, level, indent, timestamp)</code>  <code>abstractmethod</code>","text":"<p>Format and log message text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to log</p> required <code>level</code> <code>int</code> <p>logging level</p> required <code>indent</code> <code>bool</code> <p>if true indent text based on the number of open contexts</p> required <code>timestamp</code> <code>str</code> <p>formatted datetime as a string or None</p> required Source code in <code>tm2py/logger.py</code> <pre><code>@abstractmethod\ndef log(\n    self,\n    text: str,\n    level: int,\n    indent: bool,\n    timestamp: Union[str, None],\n):\n    \"\"\"Format and log message text.\n\n    Args:\n        text (str): text to log\n        level (int): logging level\n        indent (bool): if true indent text based on the number of open contexts\n        timestamp (str): formatted datetime as a string or None\n    \"\"\"\n</code></pre>"},{"location":"api/#tm2py.logger.LogStartEnd","title":"<code>LogStartEnd</code>","text":"<p>Log the start and end time with optional message.</p> <p>Used as a Component method decorator. If msg is not provided a default message is generated with the object class and method name.</p> <p>Example::     @LogStartEnd(\u201cHighway assignment and skims\u201d, level=\u201dSTATUS\u201d)     def run(self):         pass</p> Properties <p>text (str): message text to use in the start and end record. level (str): logging level as a string.</p> Source code in <code>tm2py/logger.py</code> <pre><code>class LogStartEnd:\n    \"\"\"Log the start and end time with optional message.\n\n    Used as a Component method decorator. If msg is not provided a default\n    message is generated with the object class and method name.\n\n    Example::\n        @LogStartEnd(\"Highway assignment and skims\", level=\"STATUS\")\n        def run(self):\n            pass\n\n    Properties:\n        text (str): message text to use in the start and end record.\n        level (str): logging level as a string.\n    \"\"\"\n\n    def __init__(self, text: str = None, level: str = \"INFO\"):\n        \"\"\"Constructor for LogStartEnd object.\n\n        Args:\n            text (str, optional): message text to use in the start and end record.\n                Defaults to None.\n            level (str, optional): logging level as a string. Defaults to \"INFO\".\n        \"\"\"\n        self.text = text\n        self.level = level\n\n    def __call__(self, func):\n        \"\"\"Ability to call logger.\n\n        Args:\n            func (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n\n        @functools.wraps(func)\n        def wrapper(obj, *args, **kwargs):\n            text = self.text or obj.__class__.__name__ + \" \" + func.__name__\n            with obj.logger.log_start_end(text, self.level):\n                value = func(obj, *args, **kwargs)\n            return value\n\n        return wrapper\n</code></pre>"},{"location":"api/#tm2py.logger.LogStartEnd.__call__","title":"<code>__call__(func)</code>","text":"<p>Ability to call logger.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>_type_</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>tm2py/logger.py</code> <pre><code>def __call__(self, func):\n    \"\"\"Ability to call logger.\n\n    Args:\n        func (_type_): _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(obj, *args, **kwargs):\n        text = self.text or obj.__class__.__name__ + \" \" + func.__name__\n        with obj.logger.log_start_end(text, self.level):\n            value = func(obj, *args, **kwargs)\n        return value\n\n    return wrapper\n</code></pre>"},{"location":"api/#tm2py.logger.LogStartEnd.__init__","title":"<code>__init__(text=None, level='INFO')</code>","text":"<p>Constructor for LogStartEnd object.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>message text to use in the start and end record. Defaults to None.</p> <code>None</code> <code>level</code> <code>str</code> <p>logging level as a string. Defaults to \u201cINFO\u201d.</p> <code>'INFO'</code> Source code in <code>tm2py/logger.py</code> <pre><code>def __init__(self, text: str = None, level: str = \"INFO\"):\n    \"\"\"Constructor for LogStartEnd object.\n\n    Args:\n        text (str, optional): message text to use in the start and end record.\n            Defaults to None.\n        level (str, optional): logging level as a string. Defaults to \"INFO\".\n    \"\"\"\n    self.text = text\n    self.level = level\n</code></pre>"},{"location":"api/#tm2py.logger.Logger","title":"<code>Logger</code>","text":"<p>               Bases: <code>BaseLogger</code></p> <p>Logging of message text for display, text file, and Emme logbook, as well as notify to slack.</p> <p>The log message levels can be one of: TRACE, DEBUG, DETAIL, INFO, STATUS, WARN, ERROR, FATAL Which will filter all messages of that severity and higher. See module note on use of descriptive level names.</p> <p>logger.log(\u201ca message\u201d) with logger.log_start_end(\u201cRunning a set of steps\u201d):     logger.log(\u201cMessage with timestamp\u201d)     logger.log(\u201cA debug message\u201d, level=\u201dDEBUG\u201d)     # equivalently, use the .debug:     logger.debug(\u201cAnother debug message\u201d)     if logger.debug_enabled:         # only generate this report if logging DEBUG         logger.log(\u201cA debug report that takes time to produce\u201d, level=\u201dDEBUG\u201d)     logger.notify_slack(\u201cA slack message\u201d)</p> <p>Methods can also be decorated with LogStartEnd (see class for more).</p> <p>Note that the Logger should only be initialized once per model run. In places where the controller is not available, the last Logger initialized can be obtained from the class method get_logger::</p> <pre><code>logger = Logger.get_logger()\n</code></pre> Internal properties Source code in <code>tm2py/logger.py</code> <pre><code>class Logger(BaseLogger):\n    \"\"\"Logging of message text for display, text file, and Emme logbook, as well as notify to slack.\n\n    The log message levels can be one of:\n    TRACE, DEBUG, DETAIL, INFO, STATUS, WARN, ERROR, FATAL\n    Which will filter all messages of that severity and higher.\n    See module note on use of descriptive level names.\n\n    logger.log(\"a message\")\n    with logger.log_start_end(\"Running a set of steps\"):\n        logger.log(\"Message with timestamp\")\n        logger.log(\"A debug message\", level=\"DEBUG\")\n        # equivalently, use the .debug:\n        logger.debug(\"Another debug message\")\n        if logger.debug_enabled:\n            # only generate this report if logging DEBUG\n            logger.log(\"A debug report that takes time to produce\", level=\"DEBUG\")\n        logger.notify_slack(\"A slack message\")\n\n    Methods can also be decorated with LogStartEnd (see class for more).\n\n    Note that the Logger should only be initialized once per model run.\n    In places where the controller is not available, the last Logger\n    initialized can be obtained from the class method get_logger::\n\n        logger = Logger.get_logger()\n\n    Internal properties:\n        _log_cache: the LogCache object\n        _log_formatters: list of objects that format text and record, either\n            to file, display (print to screen) or cache for log on error\n        _use_emme_logbook: whether Emme logbook is enabled\n        _slack_notifier: SlackNotifier object for sending messages to slack\n    \"\"\"\n\n    # used to cache last initialized Logger\n    _instance = None\n\n    def __new__(cls, controller: RunController):\n        \"\"\"Logger __new__ method override.\n\n        Args:\n            controller (RunController): Associated RunController instance.\n        \"\"\"\n        # pylint: disable=unused-argument\n        cls._instance = super(Logger, cls).__new__(cls)\n        return cls._instance\n\n    def __init__(self, controller: RunController):\n        \"\"\"Constructor for Logger object.\n\n        Args:\n            controller (RunController): Associated RunController instance.\n        \"\"\"\n        self.controller = controller\n\n        log_config = controller.config.logging\n        iter_component_level = log_config.iter_component_level or []\n        iter_component_level = dict(\n            ((i, c), LEVELS_STR_TO_INT[l]) for i, c, l in iter_component_level\n        )\n        display_logger = LogDisplay(LEVELS_STR_TO_INT[log_config.display_level])\n        run_log_formatter = LogFile(\n            LEVELS_STR_TO_INT[log_config.run_file_level],\n            os.path.join(controller.run_dir, log_config.run_file_path),\n        )\n        standard_log_formatter = LogFileLevelOverride(\n            LEVELS_STR_TO_INT[log_config.log_file_level],\n            os.path.join(controller.run_dir, log_config.log_file_path),\n            iter_component_level,\n            controller,\n        )\n        log_formatters = [display_logger, run_log_formatter, standard_log_formatter]\n        log_cache_file = os.path.join(\n            controller.run_dir, log_config.log_on_error_file_path\n        )\n        # set this latter via setEmmeManager()\n        emme_manager = None\n        super().__init__(log_formatters, log_cache_file)\n\n        self._slack_notifier = SlackNotifier(self)\n\n    @classmethod\n    def get_logger(cls):\n        \"\"\"Return the last initialized logger object.\"\"\"\n        return cls._instance\n\n    def notify_slack(self, text: str):\n        \"\"\"Send message to slack if enabled by config.\n\n        Args:\n            text (str): text to send to slack\n        \"\"\"\n        if self.controller.config.logging.notify_slack:\n            self._slack_notifier.post_message(text)\n</code></pre>"},{"location":"api/#tm2py.logger.Logger.__init__","title":"<code>__init__(controller)</code>","text":"<p>Constructor for Logger object.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>Associated RunController instance.</p> required Source code in <code>tm2py/logger.py</code> <pre><code>def __init__(self, controller: RunController):\n    \"\"\"Constructor for Logger object.\n\n    Args:\n        controller (RunController): Associated RunController instance.\n    \"\"\"\n    self.controller = controller\n\n    log_config = controller.config.logging\n    iter_component_level = log_config.iter_component_level or []\n    iter_component_level = dict(\n        ((i, c), LEVELS_STR_TO_INT[l]) for i, c, l in iter_component_level\n    )\n    display_logger = LogDisplay(LEVELS_STR_TO_INT[log_config.display_level])\n    run_log_formatter = LogFile(\n        LEVELS_STR_TO_INT[log_config.run_file_level],\n        os.path.join(controller.run_dir, log_config.run_file_path),\n    )\n    standard_log_formatter = LogFileLevelOverride(\n        LEVELS_STR_TO_INT[log_config.log_file_level],\n        os.path.join(controller.run_dir, log_config.log_file_path),\n        iter_component_level,\n        controller,\n    )\n    log_formatters = [display_logger, run_log_formatter, standard_log_formatter]\n    log_cache_file = os.path.join(\n        controller.run_dir, log_config.log_on_error_file_path\n    )\n    # set this latter via setEmmeManager()\n    emme_manager = None\n    super().__init__(log_formatters, log_cache_file)\n\n    self._slack_notifier = SlackNotifier(self)\n</code></pre>"},{"location":"api/#tm2py.logger.Logger.__new__","title":"<code>__new__(controller)</code>","text":"<p>Logger new method override.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>RunController</code> <p>Associated RunController instance.</p> required Source code in <code>tm2py/logger.py</code> <pre><code>def __new__(cls, controller: RunController):\n    \"\"\"Logger __new__ method override.\n\n    Args:\n        controller (RunController): Associated RunController instance.\n    \"\"\"\n    # pylint: disable=unused-argument\n    cls._instance = super(Logger, cls).__new__(cls)\n    return cls._instance\n</code></pre>"},{"location":"api/#tm2py.logger.Logger.get_logger","title":"<code>get_logger()</code>  <code>classmethod</code>","text":"<p>Return the last initialized logger object.</p> Source code in <code>tm2py/logger.py</code> <pre><code>@classmethod\ndef get_logger(cls):\n    \"\"\"Return the last initialized logger object.\"\"\"\n    return cls._instance\n</code></pre>"},{"location":"api/#tm2py.logger.Logger.notify_slack","title":"<code>notify_slack(text)</code>","text":"<p>Send message to slack if enabled by config.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to send to slack</p> required Source code in <code>tm2py/logger.py</code> <pre><code>def notify_slack(self, text: str):\n    \"\"\"Send message to slack if enabled by config.\n\n    Args:\n        text (str): text to send to slack\n    \"\"\"\n    if self.controller.config.logging.notify_slack:\n        self._slack_notifier.post_message(text)\n</code></pre>"},{"location":"api/#tm2py.logger.ProcessLogger","title":"<code>ProcessLogger</code>","text":"<p>               Bases: <code>BaseLogger</code></p> <p>Logger for running in separate process with no RunController.</p> Source code in <code>tm2py/logger.py</code> <pre><code>class ProcessLogger(BaseLogger):\n    \"Logger for running in separate process with no RunController.\"\n\n    def __init__(self, run_log_file_path, log_on_error_file_path, emme_manager):\n        \"\"\"Constructor for Logger object.\n\n        Args:\n            run_log_file_path ():\n            log_on_error_file_path ():\n            emme_manager ():\n        \"\"\"\n        run_log_formatter = LogFile(LEVELS_STR_TO_INT[\"INFO\"], run_log_file_path)\n        log_formatters = [run_log_formatter]\n        super().__init__(log_formatters, log_on_error_file_path, emme_manager)\n</code></pre>"},{"location":"api/#tm2py.logger.ProcessLogger.__init__","title":"<code>__init__(run_log_file_path, log_on_error_file_path, emme_manager)</code>","text":"<p>Constructor for Logger object.</p> <p>Parameters:</p> Name Type Description Default <code>run_log_file_path</code> required <code>log_on_error_file_path</code> required <code>emme_manager</code> required Source code in <code>tm2py/logger.py</code> <pre><code>def __init__(self, run_log_file_path, log_on_error_file_path, emme_manager):\n    \"\"\"Constructor for Logger object.\n\n    Args:\n        run_log_file_path ():\n        log_on_error_file_path ():\n        emme_manager ():\n    \"\"\"\n    run_log_formatter = LogFile(LEVELS_STR_TO_INT[\"INFO\"], run_log_file_path)\n    log_formatters = [run_log_formatter]\n    super().__init__(log_formatters, log_on_error_file_path, emme_manager)\n</code></pre>"},{"location":"api/#tm2py.logger.SlackNotifier","title":"<code>SlackNotifier</code>","text":"<p>Notify slack of model run status.</p> <p>The slack channel can be input directly, or is configured via text file found at \u201cM:\\Software\\Slack\\TravelModel_SlackWebhook.txt\u201d (if on MTC server) rr\u201dC:\\Software\\Slack\\TravelModel_SlackWebhook.txt\u201d (if local)</p> Properties <ul> <li>logger (Logger): object for logging of trace messages</li> <li>slack_webhook_url (str): optional, url to use for sending the message to slack</li> </ul> Source code in <code>tm2py/logger.py</code> <pre><code>class SlackNotifier:\n    r\"\"\"Notify slack of model run status.\n\n    The slack channel can be input directly, or is configured via text file found at\n    \"M:\\Software\\Slack\\TravelModel_SlackWebhook.txt\" (if on MTC server)\n    rr\"C:\\Software\\Slack\\TravelModel_SlackWebhook.txt\" (if local)\n\n    Properties:\n        - logger (Logger): object for logging of trace messages\n        - slack_webhook_url (str): optional, url to use for sending the message to slack\n    \"\"\"\n\n    def __init__(self, logger: Logger, slack_webhook_url: str = None):\n        r\"\"\"Constructor for SlackNotifier object.\n\n        Args:\n            logger (Logger): logger instance.\n            slack_webhook_url (str, optional): . Defaults to None, which is replaced by either:\n                - r\"M:\\Software\\Slack\\TravelModel_SlackWebhook.txt\" (if on MTC server)\n                - r\"C:\\Software\\Slack\\TravelModel_SlackWebhook.txt\" (otherwise)\n        \"\"\"\n        self.logger = logger\n        if not logger.controller.config.logging.notify_slack:\n            self._slack_webhook_url = None\n            return\n        if slack_webhook_url is None:\n            hostname = socket.getfqdn()\n            if hostname.endswith(\".mtc.ca.gov\"):\n                slack_webhook_url_file = (\n                    r\"M:\\Software\\Slack\\TravelModel_SlackWebhook.txt\"\n                )\n                self.logger.log(\n                    f\"SlackNotifier running on mtc host; using {slack_webhook_url_file}\",\n                    level=\"TRACE\",\n                )\n            else:\n                slack_webhook_url_file = (\n                    r\"C:\\Software\\Slack\\TravelModel_SlackWebhook.txt\"\n                )\n                self.logger.log(\n                    f\"SlackNotifier running on non-mtc host; using {slack_webhook_url_file}\",\n                    level=\"TRACE\",\n                )\n            if os.path.isfile(slack_webhook_url_file):\n                with open(slack_webhook_url_file, \"r\", encoding=\"utf8\") as url_file:\n                    self._slack_webhook_url = url_file.read()\n            else:\n                self._slack_webhook_url = None\n        else:\n            self._slack_webhook_url = slack_webhook_url\n        self.logger.log(\n            f\"SlackNotifier using slack webhook url {self._slack_webhook_url}\",\n            level=\"TRACE\",\n        )\n\n    def post_message(self, text):\n        \"\"\"Posts text to the slack channel via the webhook if slack_webhook_url is found.\n\n        Args:\n           text: text message to send to slack\n        \"\"\"\n        if self._slack_webhook_url is None:\n            return\n        headers = {\"Content-type\": \"application/json\"}\n        data = {\"text\": text}\n        self.logger.log(f\"Sending message to slack: {text}\", level=\"TRACE\")\n        response = requests.post(self._slack_webhook_url, headers=headers, json=data, timeout=10)\n        self.logger.log(f\"Receiving response: {response}\", level=\"TRACE\")\n</code></pre>"},{"location":"api/#tm2py.logger.SlackNotifier.__init__","title":"<code>__init__(logger, slack_webhook_url=None)</code>","text":"<p>Constructor for SlackNotifier object.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>logger instance.</p> required <code>slack_webhook_url</code> <code>str</code> <p>. Defaults to None, which is replaced by either: - r\u201dM:\\Software\\Slack\\TravelModel_SlackWebhook.txt\u201d (if on MTC server) - r\u201dC:\\Software\\Slack\\TravelModel_SlackWebhook.txt\u201d (otherwise)</p> <code>None</code> Source code in <code>tm2py/logger.py</code> <pre><code>def __init__(self, logger: Logger, slack_webhook_url: str = None):\n    r\"\"\"Constructor for SlackNotifier object.\n\n    Args:\n        logger (Logger): logger instance.\n        slack_webhook_url (str, optional): . Defaults to None, which is replaced by either:\n            - r\"M:\\Software\\Slack\\TravelModel_SlackWebhook.txt\" (if on MTC server)\n            - r\"C:\\Software\\Slack\\TravelModel_SlackWebhook.txt\" (otherwise)\n    \"\"\"\n    self.logger = logger\n    if not logger.controller.config.logging.notify_slack:\n        self._slack_webhook_url = None\n        return\n    if slack_webhook_url is None:\n        hostname = socket.getfqdn()\n        if hostname.endswith(\".mtc.ca.gov\"):\n            slack_webhook_url_file = (\n                r\"M:\\Software\\Slack\\TravelModel_SlackWebhook.txt\"\n            )\n            self.logger.log(\n                f\"SlackNotifier running on mtc host; using {slack_webhook_url_file}\",\n                level=\"TRACE\",\n            )\n        else:\n            slack_webhook_url_file = (\n                r\"C:\\Software\\Slack\\TravelModel_SlackWebhook.txt\"\n            )\n            self.logger.log(\n                f\"SlackNotifier running on non-mtc host; using {slack_webhook_url_file}\",\n                level=\"TRACE\",\n            )\n        if os.path.isfile(slack_webhook_url_file):\n            with open(slack_webhook_url_file, \"r\", encoding=\"utf8\") as url_file:\n                self._slack_webhook_url = url_file.read()\n        else:\n            self._slack_webhook_url = None\n    else:\n        self._slack_webhook_url = slack_webhook_url\n    self.logger.log(\n        f\"SlackNotifier using slack webhook url {self._slack_webhook_url}\",\n        level=\"TRACE\",\n    )\n</code></pre>"},{"location":"api/#tm2py.logger.SlackNotifier.post_message","title":"<code>post_message(text)</code>","text":"<p>Posts text to the slack channel via the webhook if slack_webhook_url is found.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <p>text message to send to slack</p> required Source code in <code>tm2py/logger.py</code> <pre><code>def post_message(self, text):\n    \"\"\"Posts text to the slack channel via the webhook if slack_webhook_url is found.\n\n    Args:\n       text: text message to send to slack\n    \"\"\"\n    if self._slack_webhook_url is None:\n        return\n    headers = {\"Content-type\": \"application/json\"}\n    data = {\"text\": text}\n    self.logger.log(f\"Sending message to slack: {text}\", level=\"TRACE\")\n    response = requests.post(self._slack_webhook_url, headers=headers, json=data, timeout=10)\n    self.logger.log(f\"Receiving response: {response}\", level=\"TRACE\")\n</code></pre>"},{"location":"api/#tm2py.tools.SpatialGridIndex","title":"<code>SpatialGridIndex</code>","text":"<p>Simple spatial grid hash for fast (enough) nearest neighbor / within distance searches of points.</p> Source code in <code>tm2py/tools.py</code> <pre><code>class SpatialGridIndex:\n    \"\"\"\n    Simple spatial grid hash for fast (enough) nearest neighbor / within distance searches of points.\n    \"\"\"\n\n    def __init__(self, size: float):\n        \"\"\"\n        Args:\n            size: the size of the grid to use for the index, relative to the point coordinates\n        \"\"\"\n        self._size = float(size)\n        self._grid_index = _defaultdict(lambda: [])\n\n    def insert(self, obj: Any, x: float, y: float):\n        \"\"\"\n        Add new obj with coordinates x and y.\n        Args:\n           obj: any python object, will be returned from search methods \"nearest\" and \"within_distance\"\n           x: x-coordinate\n           y: y-coordinate\n        \"\"\"\n        grid_x, grid_y = round(x / self._size), round(y / self._size)\n        self._grid_index[(grid_x, grid_y)].append((obj, x, y))\n\n    def nearest(self, x: float, y: float):\n        \"\"\"Return the closest object in index to the specified coordinates\n        Args:\n            x: x-coordinate\n            y: y-coordinate\n        \"\"\"\n        if len(self._grid_index) == 0:\n            raise Exception(\"SpatialGrid is empty.\")\n\n        def calc_dist(x1, y1, x2, y2):\n            return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n        grid_x, grid_y = round(x / self._size), round(y / self._size)\n        step = 0\n        done = False\n        found_items = []\n        while not done:\n            search_offsets = list(range(-1 * step, step + 1))\n            search_offsets = _product(search_offsets, search_offsets)\n            items = []\n            for x_offset, y_offset in search_offsets:\n                if abs(x_offset) != step and abs(y_offset) != step:\n                    continue  # already checked this grid tile\n                items.extend(self._grid_index[grid_x + x_offset, grid_y + y_offset])\n            if found_items:\n                done = True\n            found_items.extend(items)\n            step += 1\n        min_dist = 1e400\n        closest = None\n        for i, xi, yi in found_items:\n            dist = calc_dist(x, y, xi, yi)\n            if dist &lt; min_dist:\n                closest = i\n                min_dist = dist\n        return closest\n\n    def within_distance(self, x: float, y: float, distance: float):\n        \"\"\"Return all objects in index within the distance of the specified coordinates\n        Args:\n            x: x-coordinate\n            y: y-coordinate\n            distance: distance to search in point coordinate units\n        \"\"\"\n\n        def point_in_circle(x1, y1, x2, y2, dist):\n            return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) &lt;= dist\n\n        return self._get_items_on_grid(x, y, distance, point_in_circle)\n\n    def within_square(self, x: float, y: float, distance: float):\n        \"\"\"Return all objects in index within a square box distance of the specified coordinates.\n        Args:\n            x: x-coordinate\n            y: y-coordinate\n            distance: distance to search in point coordinate units\n        \"\"\"\n\n        def point_in_box(x1, y1, x2, y2, dist):\n            return abs(x1 - x2) &lt;= dist and abs(y1 - y2) &lt;= dist\n\n        return self._get_items_on_grid(x, y, distance, point_in_box)\n\n    def _get_items_on_grid(self, x, y, distance, filter_func):\n        grid_x, grid_y = round(x / self._size), round(y / self._size)\n        num_search_grids = ceil(distance / self._size)\n        search_offsets = list(range(-1 * num_search_grids, num_search_grids + 1))\n        search_offsets = list(_product(search_offsets, search_offsets))\n        items = []\n        for x_offset, y_offset in search_offsets:\n            items.extend(self._grid_index[grid_x + x_offset, grid_y + y_offset])\n        filtered_items = [\n            i for i, xi, yi in items if filter_func(x, y, xi, yi, distance)\n        ]\n        return filtered_items\n</code></pre>"},{"location":"api/#tm2py.tools.SpatialGridIndex.__init__","title":"<code>__init__(size)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>the size of the grid to use for the index, relative to the point coordinates</p> required Source code in <code>tm2py/tools.py</code> <pre><code>def __init__(self, size: float):\n    \"\"\"\n    Args:\n        size: the size of the grid to use for the index, relative to the point coordinates\n    \"\"\"\n    self._size = float(size)\n    self._grid_index = _defaultdict(lambda: [])\n</code></pre>"},{"location":"api/#tm2py.tools.SpatialGridIndex.insert","title":"<code>insert(obj, x, y)</code>","text":"<p>Add new obj with coordinates x and y. Args:    obj: any python object, will be returned from search methods \u201cnearest\u201d and \u201cwithin_distance\u201d    x: x-coordinate    y: y-coordinate</p> Source code in <code>tm2py/tools.py</code> <pre><code>def insert(self, obj: Any, x: float, y: float):\n    \"\"\"\n    Add new obj with coordinates x and y.\n    Args:\n       obj: any python object, will be returned from search methods \"nearest\" and \"within_distance\"\n       x: x-coordinate\n       y: y-coordinate\n    \"\"\"\n    grid_x, grid_y = round(x / self._size), round(y / self._size)\n    self._grid_index[(grid_x, grid_y)].append((obj, x, y))\n</code></pre>"},{"location":"api/#tm2py.tools.SpatialGridIndex.nearest","title":"<code>nearest(x, y)</code>","text":"<p>Return the closest object in index to the specified coordinates Args:     x: x-coordinate     y: y-coordinate</p> Source code in <code>tm2py/tools.py</code> <pre><code>def nearest(self, x: float, y: float):\n    \"\"\"Return the closest object in index to the specified coordinates\n    Args:\n        x: x-coordinate\n        y: y-coordinate\n    \"\"\"\n    if len(self._grid_index) == 0:\n        raise Exception(\"SpatialGrid is empty.\")\n\n    def calc_dist(x1, y1, x2, y2):\n        return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n    grid_x, grid_y = round(x / self._size), round(y / self._size)\n    step = 0\n    done = False\n    found_items = []\n    while not done:\n        search_offsets = list(range(-1 * step, step + 1))\n        search_offsets = _product(search_offsets, search_offsets)\n        items = []\n        for x_offset, y_offset in search_offsets:\n            if abs(x_offset) != step and abs(y_offset) != step:\n                continue  # already checked this grid tile\n            items.extend(self._grid_index[grid_x + x_offset, grid_y + y_offset])\n        if found_items:\n            done = True\n        found_items.extend(items)\n        step += 1\n    min_dist = 1e400\n    closest = None\n    for i, xi, yi in found_items:\n        dist = calc_dist(x, y, xi, yi)\n        if dist &lt; min_dist:\n            closest = i\n            min_dist = dist\n    return closest\n</code></pre>"},{"location":"api/#tm2py.tools.SpatialGridIndex.within_distance","title":"<code>within_distance(x, y, distance)</code>","text":"<p>Return all objects in index within the distance of the specified coordinates Args:     x: x-coordinate     y: y-coordinate     distance: distance to search in point coordinate units</p> Source code in <code>tm2py/tools.py</code> <pre><code>def within_distance(self, x: float, y: float, distance: float):\n    \"\"\"Return all objects in index within the distance of the specified coordinates\n    Args:\n        x: x-coordinate\n        y: y-coordinate\n        distance: distance to search in point coordinate units\n    \"\"\"\n\n    def point_in_circle(x1, y1, x2, y2, dist):\n        return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) &lt;= dist\n\n    return self._get_items_on_grid(x, y, distance, point_in_circle)\n</code></pre>"},{"location":"api/#tm2py.tools.SpatialGridIndex.within_square","title":"<code>within_square(x, y, distance)</code>","text":"<p>Return all objects in index within a square box distance of the specified coordinates. Args:     x: x-coordinate     y: y-coordinate     distance: distance to search in point coordinate units</p> Source code in <code>tm2py/tools.py</code> <pre><code>def within_square(self, x: float, y: float, distance: float):\n    \"\"\"Return all objects in index within a square box distance of the specified coordinates.\n    Args:\n        x: x-coordinate\n        y: y-coordinate\n        distance: distance to search in point coordinate units\n    \"\"\"\n\n    def point_in_box(x1, y1, x2, y2, dist):\n        return abs(x1 - x2) &lt;= dist and abs(y1 - y2) &lt;= dist\n\n    return self._get_items_on_grid(x, y, distance, point_in_box)\n</code></pre>"},{"location":"api/#tm2py.tools.download_unzip","title":"<code>download_unzip(url, out_base_dir, target_dir, zip_filename='test_data.zip')</code>","text":"<p>Download and unzips a file from a URL. The zip file is removed after extraction.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Full URL do download from.</p> required <code>out_base_dir</code> <code>str</code> <p>Where to unzip the file.</p> required <code>target_dir</code> <code>str</code> <p>What to unzip the file as.</p> required <code>zip_filename</code> <code>str</code> <p>Filename to store zip file as. Defaults to \u201ctest_data.zip\u201d.</p> <code>'test_data.zip'</code> Source code in <code>tm2py/tools.py</code> <pre><code>def download_unzip(\n    url: str, out_base_dir: str, target_dir: str, zip_filename: str = \"test_data.zip\"\n) -&gt; None:\n    \"\"\"Download and unzips a file from a URL. The zip file is removed after extraction.\n\n    Args:\n        url (str): Full URL do download from.\n        out_base_dir (str): Where to unzip the file.\n        target_dir (str): What to unzip the file as.\n        zip_filename (str, optional): Filename to store zip file as. Defaults to \"test_data.zip\".\n    \"\"\"\n    target_zip = os.path.join(out_base_dir, zip_filename)\n    if not os.path.isdir(out_base_dir):\n        os.makedirs(out_base_dir)\n    urllib.request.Request(url)\n    _download(url, target_zip)\n    _unzip(target_zip, target_dir)\n    os.remove(target_zip)\n</code></pre>"},{"location":"api/#tm2py.tools.emme_context","title":"<code>emme_context()</code>","text":"<p>Return True if Emme is installed.</p> Source code in <code>tm2py/tools.py</code> <pre><code>def emme_context():\n    \"\"\"Return True if Emme is installed.\"\"\"\n    import pkg_resources\n\n    _inro_package = \"inro-emme\"\n    _avail_packages = [pkg.key for pkg in pkg_resources.working_set]\n\n    if _inro_package not in _avail_packages:\n        print(\"Inro not found. Skipping inro setup.\")\n        mocked_inro_context()\n        return False\n    else:\n        import inro\n\n        if \"MagicMock\" in str(type(inro)):\n            return False\n\n    return True\n</code></pre>"},{"location":"api/#tm2py.tools.interpolate_dfs","title":"<code>interpolate_dfs(df, ref_points, target_point, ref_col_name='ends_with')</code>","text":"<p>Interpolate for the model year assuming linear growth between the reference years.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>dataframe to interpolate on, with ref points contained in column name per ref_col_name.</p> required <code>ref_points</code> <code>Collection[Union[float, int]]</code> <p>reference years to interpolate between</p> required <code>target_point</code> <code>Union[float, int]</code> <p>target year</p> required <code>ref_col_name</code> <code>str</code> <p>column name to use for reference years. Defaults to \u201cends_with\u201d.</p> <code>'ends_with'</code> Source code in <code>tm2py/tools.py</code> <pre><code>def interpolate_dfs(\n    df: pd.DataFrame,\n    ref_points: Collection[Union[float, int]],\n    target_point: Union[float, int],\n    ref_col_name: str = \"ends_with\",\n) -&gt; pd.DataFrame:\n    \"\"\"Interpolate for the model year assuming linear growth between the reference years.\n\n    Args:\n        df (pd.DataFrame): dataframe to interpolate on, with ref points contained in column\n            name per ref_col_name.\n        ref_points (Collection[Union[float,int]]): reference years to interpolate between\n        target_point (Union[float,int]): target year\n        ref_col_name (str, optional): column name to use for reference years.\n            Defaults to \"ends_with\".\n    \"\"\"\n    if ref_col_name not in [\"ends_with\"]:\n        raise NotImplementedError(f\"{ref_col_name} not implemented\")\n    if len(ref_points) != 2:\n        raise NotImplementedError(f\"{ref_points} reference points not implemented\")\n\n    _ref_points = list(map(int, ref_points))\n    _target_point = int(target_point)\n\n    _ref_points.sort()\n    _start_point, _end_point = _ref_points\n    if not _start_point &lt;= _target_point &lt;= _end_point:\n        raise ValueError(\n            f\"Target Point: {_target_point} not within range of \\\n            Reference Points: {_ref_points}\"\n        )\n\n    _start_ref_df = df[[c for c in df.columns if c.endswith(f\"{_start_point}\")]].copy()\n    _end_ref_df = df[[c for c in df.columns if c.endswith(f\"{_end_point}\")]].copy()\n\n    if len(_start_ref_df.columns) != len(_end_ref_df.columns):\n        raise ValueError(\n            f\"{_start_point} and {_end_point} have different number of columns:\\n\\\n           {_start_point} Columns: {_start_ref_df.columns}\\n\\\n           {_end_point} Columns: {_end_ref_df.columns}\\\n        \"\n        )\n\n    _start_ref_df.rename(\n        columns=lambda x: x.replace(f\"_{_start_point}\", \"\"), inplace=True\n    )\n    _end_ref_df.rename(columns=lambda x: x.replace(f\"_{_end_point}\", \"\"), inplace=True)\n    _scale_factor = float(target_point - _start_point) / (_end_point - _start_point)\n\n    interpolated_df = (1 - _scale_factor) * _start_ref_df + _scale_factor * _end_ref_df\n\n    return interpolated_df\n</code></pre>"},{"location":"api/#tm2py.tools.mocked_inro_context","title":"<code>mocked_inro_context()</code>","text":"<p>Mocking of modules which need to be mocked for tests.</p> Source code in <code>tm2py/tools.py</code> <pre><code>def mocked_inro_context():\n    \"\"\"Mocking of modules which need to be mocked for tests.\"\"\"\n    import sys\n    from unittest.mock import MagicMock\n\n    sys.modules[\"inro.emme.database.emmebank\"] = MagicMock()\n    sys.modules[\"inro.emme.database.emmebank.path\"] = MagicMock(return_value=\".\")\n    sys.modules[\"inro.emme.network.link\"] = MagicMock()\n    sys.modules[\"inro.emme.network.mode\"] = MagicMock()\n    sys.modules[\"inro.emme.network.node\"] = MagicMock()\n    sys.modules[\"inro.emme.network\"] = MagicMock()\n    sys.modules[\"inro.emme.database.scenario\"] = MagicMock()\n    sys.modules[\"inro.emme.database.matrix\"] = MagicMock()\n    sys.modules[\"inro.emme.network.node\"] = MagicMock()\n    sys.modules[\"inro.emme.desktop.app\"] = MagicMock()\n    sys.modules[\"inro\"] = MagicMock()\n    sys.modules[\"inro.modeller\"] = MagicMock()\n    sys.modules[\"tm2py.emme.manager.EmmeManager.project\"] = MagicMock()\n    sys.modules[\"tm2py.emme.manager.EmmeManager.emmebank\"] = MagicMock()\n    sys.modules[\"tm2py.emme.manager\"] = MagicMock()\n</code></pre>"},{"location":"api/#tm2py.tools.run_process","title":"<code>run_process(commands, name='')</code>","text":"<p>Run system level commands as blocking process and log output and error messages.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>Collection[str]</code> <p>list of one or more commands to execute</p> required <code>name</code> <code>str</code> <p>optional name to use for the temp bat file</p> <code>''</code> Source code in <code>tm2py/tools.py</code> <pre><code>def run_process(commands: Collection[str], name: str = \"\"):\n    \"\"\"Run system level commands as blocking process and log output and error messages.\n\n    Args:\n        commands: list of one or more commands to execute\n        name: optional name to use for the temp bat file\n    \"\"\"\n    # when merged with develop_logging branch can use get_logger\n    # logger = Logger.get_logger\n    logger = None\n    with temp_file(\"w\", prefix=name, suffix=\".bat\") as (bat_file, bat_file_path):\n        bat_file.write(\"\\n\".join(commands))\n        bat_file.close()\n        if logger:\n            # temporary file to capture output error messages generated by Java\n            # Note: temp file created in the current working directory\n            with temp_file(mode=\"w+\", suffix=\"_error.log\") as (err_file, _):\n                try:\n                    output = _subprocess.check_output(\n                        bat_file_path, stderr=err_file, shell=True\n                    )\n                    logger.log(output.decode(\"utf-8\"))\n                except _subprocess.CalledProcessError as error:\n                    logger.log(error.output)\n                    raise\n                finally:\n                    err_file.seek(0)\n                    error_msg = err_file.read()\n                    if error_msg:\n                        logger.log(error_msg)\n        else:\n            _subprocess.check_call(bat_file_path, shell=True)\n</code></pre>"},{"location":"api/#tm2py.tools.temp_file","title":"<code>temp_file(mode='w+', prefix='', suffix='')</code>","text":"<p>Temp file wrapper to return open file handle and named path.</p> <p>A named temporary file (using mkstemp) with specified prefix and suffix is created and opened with the specified mode. The file handle and path are returned. The file is closed and deleted on exit.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>mode to open file, [rw][+][b]</p> <code>'w+'</code> <code>prefix</code> <code>str</code> <p>optional text to start temp file name</p> <code>''</code> <code>suffix</code> <code>str</code> <p>optional text to end temp file name</p> <code>''</code> Source code in <code>tm2py/tools.py</code> <pre><code>@_context\ndef temp_file(mode: str = \"w+\", prefix: str = \"\", suffix: str = \"\"):\n    \"\"\"Temp file wrapper to return open file handle and named path.\n\n    A named temporary file (using mkstemp) with specified prefix and\n    suffix is created and opened with the specified mode. The file\n    handle and path are returned. The file is closed and deleted on exit.\n\n    Args:\n        mode: mode to open file, [rw][+][b]\n        prefix: optional text to start temp file name\n        suffix: optional text to end temp file name\n    \"\"\"\n    file_ref, file_path = tempfile.mkstemp(prefix=prefix, suffix=suffix)\n    file = os.fdopen(file_ref, mode=mode)\n    try:\n        yield file, file_path\n    finally:\n        if not file.closed:\n            file.close()\n        os.remove(file_path)\n</code></pre>"},{"location":"api/#tm2py.tools.zonal_csv_to_matrices","title":"<code>zonal_csv_to_matrices(csv_file, i_column='ORIG', j_column='DEST', value_columns=['VALUE'], default_value=0.0, fill_zones=False, max_zone=None, delimiter=',')</code>","text":"<p>Read a CSV file with zonal data and into dataframes.</p> <p>Input CSV file should have a header row specifying the I, J, and Value column names.</p> <p>Parameters:</p> Name Type Description Default <code>csv_file</code> <code>str</code> <p>description</p> required <code>i_column</code> <code>str</code> <p>Name of j zone column. Defaults to \u201cORIG\u201d.</p> <code>'ORIG'</code> <code>j_column</code> <code>str</code> <p>Name of i zone column. Defaults to \u201cDEST\u201d.</p> <code>'DEST'</code> <code>value_columns</code> <code>str</code> <p>List of columns to turn into matrices. Defaults to [\u201cVALUE\u201d].</p> <code>['VALUE']</code> <code>default_value</code> <code>float</code> <p>Value to fill empty cells with. Defaults to 0.0.</p> <code>0.0</code> <code>fill_zones</code> <code>bool</code> <p>If true, will fill zones without values to max zone with default value. Defaults to False.</p> <code>False</code> <code>max_zone</code> <code>int</code> <p>If fill_zones is True, used to determine matrix size. Defaults to max(I, J).</p> <code>None</code> <code>delimiter</code> <code>str</code> <p>Input file delimeter. Defaults to \u201c,\u201d.</p> <code>','</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>Mapping[str, DataFrame]</code> <p>Dictionary of Pandas dataframes with matrix names as keys.</p> Source code in <code>tm2py/tools.py</code> <pre><code>def zonal_csv_to_matrices(\n    csv_file: str,\n    i_column: str = \"ORIG\",\n    j_column: str = \"DEST\",\n    value_columns: str = [\"VALUE\"],\n    default_value: float = 0.0,\n    fill_zones: bool = False,\n    max_zone: int = None,\n    delimiter: str = \",\",\n) -&gt; Mapping[str, pd.DataFrame]:\n    \"\"\"Read a CSV file with zonal data and into dataframes.\n\n    Input CSV file should have a header row specifying the I, J, and Value column names.\n\n    Args:\n        csv_file (str): _description_\n        i_column (str, optional): Name of j zone column. Defaults to \"ORIG\".\n        j_column (str, optional): Name of i zone column. Defaults to \"DEST\".\n        value_columns (str, optional): List of columns to turn into matrices.\n            Defaults to [\"VALUE\"].\n        default_value (float, optional): Value to fill empty cells with. Defaults to 0.0.\n        fill_zones (bool, optional): If true, will fill zones without values to max zone with\n            default value. Defaults to False.\n        max_zone (int, optional): If fill_zones is True, used to determine matrix size.\n            Defaults to max(I, J).\n        delimiter (str, optional): Input file delimeter. Defaults to \",\".\n\n    Returns:\n        dict: Dictionary of Pandas dataframes with matrix names as keys.\n    \"\"\"\n    # TODO Create a test\n    _df = pd.read_csv(csv_file, delimiter=delimiter)\n    _df_idx = _df.set_index([i_column, j_column])\n\n    _dfs_dict = {v: _df_idx[v] for v in value_columns}\n    if not fill_zones:\n        return _dfs_dict\n\n    if max_zone is None:\n        max_zone = _df[[i_column, j_column]].max().max()\n\n    _zone_list = list(range(1, max_zone + 1))\n    for v, _df in _dfs_dict.items():\n        _df[v].reindex(index=_zone_list, columns=_zone_list, fill_value=default_value)\n    return _dfs_dict\n</code></pre>"},{"location":"api/#tm2py.examples.get_example","title":"<code>get_example(example_name=_DEFAULT_EXAMPLE_NAME, example_subdir=_DEFAULT_EXAMPLE_SUBDIR, root_dir=_ROOT_DIR, retrieval_url=_DEFAULT_EXAMPLE_URL)</code>","text":"<p>Returns example directory; downloads if necessary from retrieval URL.</p> <p>Parameters:</p> Name Type Description Default <code>example_name</code> <code>str</code> <p>Used to retrieve sub-folder or create it if doesn\u2019t exist. Defaults to _DEFAULT_EXAMPLE_NAME.</p> <code>_DEFAULT_EXAMPLE_NAME</code> <code>example_subdir</code> <code>str</code> <p>Where to find examples within root dir. Defaults to _DEFAULT_EXAMPLE_SUBDIR.</p> <code>_DEFAULT_EXAMPLE_SUBDIR</code> <code>root_dir</code> <code>str</code> <p>Root dir of project. Defaults to _ROOT_DIR.</p> <code>_ROOT_DIR</code> <code>retrieval_url</code> <code>str</code> <p>URL to retrieve example data zip from. Defaults to _DEFAULT_EXAMPLE_URL.</p> <code>_DEFAULT_EXAMPLE_URL</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If can\u2019t find the files after trying to download it.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to example data.</p> Source code in <code>tm2py/examples.py</code> <pre><code>def get_example(\n    example_name: str = _DEFAULT_EXAMPLE_NAME,\n    example_subdir: str = _DEFAULT_EXAMPLE_SUBDIR,\n    root_dir: str = _ROOT_DIR,\n    retrieval_url: str = _DEFAULT_EXAMPLE_URL,\n) -&gt; str:\n    \"\"\"Returns example directory; downloads if necessary from retrieval URL.\n\n    Args:\n        example_name (str, optional): Used to retrieve sub-folder or create it if doesn't exist.\n            Defaults to _DEFAULT_EXAMPLE_NAME.\n        example_subdir (str, optional): Where to find examples within root dir. Defaults\n            to _DEFAULT_EXAMPLE_SUBDIR.\n        root_dir (str, optional): Root dir of project. Defaults to _ROOT_DIR.\n        retrieval_url (str, optional): URL to retrieve example data zip from. Defaults\n            to _DEFAULT_EXAMPLE_URL.\n\n    Raises:\n        FileNotFoundError: If can't find the files after trying to download it.\n\n    Returns:\n        str: Path to example data.\n    \"\"\"\n    _example_dir = os.path.join(root_dir, example_subdir)\n    _this_example_dir = os.path.join(_example_dir, example_name)\n    if os.path.isdir(_this_example_dir):\n        return _this_example_dir\n\n    download_unzip(retrieval_url, _example_dir, _this_example_dir)\n    if not os.path.isdir(_this_example_dir):\n        raise FileNotFoundError(f\"example {_this_example_dir} not found\")\n\n    return _this_example_dir\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#abstract-component","title":"Abstract Component","text":"<pre><code>classDiagram\n    class Component{\n        +_controller\n        +_trace\n        +validate_inputs()\n        +run()\n        +report_progress()\n        +test_component()\n        +write_top_sheet()\n    }\n</code></pre>"},{"location":"architecture/#controllers","title":"Controllers","text":"<pre><code>classDiagram\n    Controller &lt;|-- ModelController\n    class Controller{\n        _config\n        +_logger\n        +_top_sheet\n        +_trace\n        +validate_inputs()\n        +run()\n        +report_progress()\n        +test_component()\n        +write_top_sheet()\n    }\n    class ModelController{\n        +_components: String model.Component\n        +_iteration\n        +validate_inputs()\n        +run()\n        +report_progress()\n        +test_component()\n        +write_top_sheet()\n        +run_prepare_emme_networks()\n        +run_non_motorized_skims()\n        +run_airpassenger_model()\n        +run_resident_model()\n        +run_internal_external_model()\n        +run_truck_model()\n        +run_average_demand()\n        +run_highway_assignment()\n        +run_transit_assignment()\n    }\n    class Logger{\n        +controller\n        +log()\n    }\n</code></pre>"},{"location":"architecture/#configs","title":"Configs","text":"<pre><code>classDiagram\n    class Configuration{\n        +load()\n        +save()\n    }\n</code></pre>"},{"location":"architecture/#utils","title":"Utils","text":"<pre><code>classDiagram\n    class NetworkCalc{\n        +_scenario\n        +_network_calc\n        +__call__()\n        +_add_calc()\n        +run()\n    }\n    class OMX{\n        +_file_path\n        +_mode\n        +_scenario\n        +_omx_key\n        +_omx_file\n        +_matrix_cache\n        +_generate_name()\n        +open()\n        +close()\n        +__enter__()\n        +__exit__()\n        +write_matrices()\n        +write_clipped_array()\n        +write_array()\n        +read()\n        +read_hdf5()\n    }\n    class EmmeProjectCache{\n        +close_all()\n        +create_project()\n        +project()\n    }\n    class MatrixCache{\n        +_scenario\n        +_emmebanks\n        +_timestamps\n        +_data\n        +get_data()\n        +set_data()\n        +clear()\n    }\n\n</code></pre>"},{"location":"architecture/#demand","title":"Demand","text":"<pre><code>\nclassDiagram\n    Component -- AirPassenger: how?\n    Component -- InternalExternal: how?\n    Component -- Truck: how?\n    Component &lt;|-- ResidentsModel\n    ResidentsModel -- InternalExternal: how?\n    ResidentsModel -- AirPassenger: how?\n    class Component{\n    }\n    class AirPassenger{\n        +_parameter\n        +_load_demand()\n        +_sum_demand()\n        +_interpolate()\n        +_export_result()\n    }\n    class InternalExternal{\n        +_parameter\n        +_ix_forecast()\n        +_ix_time_of_day()\n        +_ix_toll_choice()\n        +_export_results()\n    }\n    class ResidentsModel{\n        +_start_household_manager()\n        +_start_matrix_manager()\n        +_run_resident_model()\n        +_stop_java()\n    }\n    class Truck{\n        +_parameter\n        +_generation()\n        +_distribution()\n        +_time_of_day()\n        +_toll_choice()\n        +_export_results()\n    }\n</code></pre>"},{"location":"architecture/#assignment","title":"Assignment","text":"<pre><code>\nclassDiagram\n    Component &lt;|-- HighwayAssignment\n    Component &lt;|-- AssignMAZSPDemand\n    Component &lt;|-- ActiveModesAssignment\n    ActiveModesAssignment -- TransitAssignment: how?\n    HighwayAssignment -- AssignMAZSPDemand: how?\n    ImportDemand -- HighwayAssignment: how?\n    ActiveModesAssignment -- AssignMAZSPDemand: how?\n    class Component{\n    }\n    class HighwayAssignment{\n        +_num_processors\n        +_root_dir\n        +_matrix_cache\n        +_emme_manager\n        +_Emmebank\n        +_skim_matrices\n        +_setup()\n        +_assign_and_skim()\n        +_calc_time_skim()\n        +_set_intrazonal_values()\n        +_export_skims()\n        +_base_spec()\n        +_prepare_traffic_class()\n        +_prepare_path_analyses()\n    }\n    class ImportDemand{\n        +_root_dir\n        +_scenario\n        +_period\n        +_setup()\n        +_read_demand()\n    }\n    class AssignMAZSPDemand{\n        +_scenario\n        +_period\n        +_modes\n        +_modeller\n        +_bin_edges\n        +_net_calc\n        +_debug_report\n        +_debug\n        +_mazs\n        +_demand\n        +_max_dist\n        +_network\n        +_root_index\n        +_leaf_index\n        +_setup()\n        +_prepare_network()\n        +_get_county_mazs()\n        +_process_demand()\n        +_group_demand()\n        +_find_roots_and_leaves()\n        +_run_shortest_path()\n        +_assign_flow()\n    }\n    class ActiveModesAssignment{\n        +_scenario\n        +_modeller\n        +_setup()\n        +_prepare_network()\n        +_run_shortest_path()\n    }\n     class TransitAssignment{\n        +_root_dir\n        +_emme_manager\n        +_setup()\n    }\n</code></pre>"},{"location":"inputs/","title":"Input","text":""},{"location":"inputs/#input","title":"Input","text":""},{"location":"inputs/#input-file-list","title":"Input File List","text":"<p>The table below contains brief descriptions of the input files required to execute the travel model.</p> Directory File Description hwy/ complete_network.net Highway, bike, walk network hwy/ tolls.csv Contains toll prices for all facilities and all time periods hwy/ interchange_nodes.csv Identifies nodes connected to interchanges landuse/ mazData.csv Micro zone data landuse/ tazData.csv Travel analysis zone data nonres/ truckFF.dat Friction factors for the commercial vehicle distribution models nonres/ truck_kfactors_taz.csv \u201cK-factors\u201d for the commercial vehicle distribution models nonres/ ixDaily2015.tpp Internal-external fixed trip table for year 2015 nonres/ ixDaily2015_totals.dbf Internal-external total trips table for year 2015 nonres/ YYYY_fromtoAAA.csv Airport passenger fixed trips for year YYYY and airport AAA nonres/ ixex_config.dbf Station-specific growth rates and commute shares for each forecast year popsyn/ households.csv Synthetic population household file popsyn/ persons.csv Synthetic population person file trn/ transitLines.lin Transit lines trn/ station_attribute_data_input.csv Station attributes trn/ vehtype.pts Vehicle types trn/ roadway-assignment-names-helper.csv Names for model links trn/ fareMatrix.txt Matrix containing transit fares trn/ fares.far Used to run fare calculations for EMME scenario"},{"location":"inputs/#time-periods","title":"Time Periods","text":"<p>Time periods in Travel Model Two are consistent with Travel Model One:</p> Time Period Times Duration EA (early AM) 3 am to 6 am 3 hours AM (AM peak period) 6 am to 10 am 4 hours MD (mid-day) 10 am to 3 pm 5 hours PM (PM peak period) 3 pm to 7 pm 4 hours EV (evening) 7 pm to 3 am 8 hours"},{"location":"inputs/#roadway-network","title":"Roadway Network","text":"<p>The all streets highway network, walk network, and bicycle network were developed from OpenStreetMap. The projection is NAD 1983 StatePlane California VI FIPS 0406 Feet.</p>"},{"location":"inputs/#county-node-numbering-system","title":"County Node Numbering System","text":"<p>The highway network uses a numbering system whereby each county has a reserved block of nodes. Within each county\u2019s block:</p> <ul> <li>Nodes 1 through 9,999 are reserved for TAZs</li> <li>Nodes 10,001 through 89,999 are for MAZs</li> <li>Nodes 90,001 through 99,999 are for transit access points (TAPs)</li> </ul> <p>The blocks are assigned to the nine counties per MTC\u2019s numbering scheme, as shown in the table below.</p> <p>Roadway, walk, bicycle, and transit network nodes are numbered by county as well and range from 1,000,000 to 10,000,000 as shown below.</p> Code County TAZs MAZs TAPs Network Node HOV Lane Node 1 San Francisco 1\u20139,999 10,001\u201389,999 90,001\u201399,999 1,000,000\u20131,500,000 5,500,000\u20136,000,000 2 San Mateo 100,001\u2013109,999 110,001\u2013189,999 190,001\u2013199,999 1,500,000\u20132,000,000 6,000,000\u20136,500,000 3 Santa Clara 200,001\u2013209,999 210,001\u2013289,999 290,001\u2013299,999 2,000,000\u20132,500,000 6,500,000\u20137,000,000 4 Alameda 300,001\u2013309,999 310,001\u2013389,999 390,001\u2013399,999 2,500,000\u20133,000,000 7,000,000\u20137,500,000 5 Contra Costa 400,001\u2013409,999 410,001\u2013489,999 490,001\u2013499,999 3,000,000\u20133,500,000 7,500,000\u20138,000,000 6 Solano 500,001\u2013509,999 510,001\u2013589,999 590,001\u2013599,999 3,500,000\u20134,000,000 8,000,000\u20138,500,000 7 Napa 600,001\u2013609,999 610,001\u2013689,999 690,001\u2013699,999 4,000,000\u20134,500,000 8,500,000\u20139,000,000 8 Sonoma 700,001\u2013709,999 710,001\u2013789,999 790,001\u2013799,999 4,500,000\u20135,000,000 9,000,000\u20139,500,000 9 Marin 800,001\u2013809,999 810,001\u2013889,999 890,001\u2013899,999 5,000,000\u20135,500,000 9,500,000\u201310,000,000 External 900,001\u2013999,999"},{"location":"inputs/#node-attributes","title":"Node Attributes","text":"<p>The following node attributes are included in the master network.</p> Field Description Data Type N Node Number Integer (see Node Numbering) X X coordinate (feet) Float Y Y coordinate (feet) Float OSM_NODE_ID OpenStreetMap node identifier Integer COUNTY County Name String DRIVE_ACCESS Node is used by automobile and/or bus links Boolean WALK_ACCESS Node is used by pedestrian links Boolean BIKE_ACCESS Node is used by bicycle links Boolean RAIL_ACCESS Node is used by rail links Boolean"},{"location":"install/","title":"Installing tm2py","text":""},{"location":"install/#install-tm2py","title":"Install tm2py","text":"<p>First, you need to set up your server.</p>"},{"location":"install/#1-clone-the-repository","title":"1. Clone the Repository","text":"<p>Clone the tm2py GitHub repo using Git Bash or GitHub Desktop, and switch to the branch you want to run.</p>"},{"location":"install/#2-open-the-openpaths-emme-shell-and-create-a-virtual-environment","title":"2. Open the OpenPaths EMME Shell and Create a Virtual Environment","text":"<p>Open the OpenPaths EMME Shell and:</p> <ul> <li>Change directory (<code>cd</code>) to the parent folder of the <code>tm2py</code> GitHub folder.  </li> <li>Create a new virtual environment alongside the <code>tm2py</code> folder (not inside it):</li> </ul> <p><code>python -m venv &lt;your_tm2py_env_name&gt;</code></p>"},{"location":"install/#3-activate-the-virtual-environment","title":"3. Activate the Virtual Environment","text":"<p>Activate the virtual environment in the OpenPaths EMME shell:</p> <p><code>&lt;your_tm2py_env_name&gt;\\Scripts\\activate</code></p>"},{"location":"install/#4-copy-emmepth-to-the-virtual-environment","title":"4. Copy <code>emme.pth</code> to the Virtual Environment","text":"<p>Copy the <code>emme.pth</code> file from your OpenPaths EMME installation folder to the virtual environment\u2019s <code>site-packages</code> folder. You can do this via shell commands or manually in Windows.</p> <p>Copy from: <code>C:\\Program Files\\Bentley\\OpenPaths\\EMME 24.01.00\\emme.pth</code> Copy to: <code>&lt;your_tm2py_env_name&gt;\\Lib\\site-packages\\</code></p> <p>(Yes, this is one of those quirky things travel modelers do.)</p>"},{"location":"install/#5-install-tm2py-in-editable-mode","title":"5. Install <code>tm2py</code> in Editable Mode","text":"<p>In the same activated shell:</p> <ul> <li> <p>Change into the <code>tm2py</code> folder: <code>cd tm2py</code></p> </li> <li> <p>Install in editable mode: <code>pip install -e .</code></p> </li> </ul>"},{"location":"install/#6-verify-the-installation","title":"6. Verify the Installation","text":"<ul> <li> <p>In the shell, launch Python: <code>python</code></p> </li> <li> <p>Try importing tm2py: <code>import tm2py</code></p> </li> </ul> <p>You should only see packages listed in <code>requirements.txt</code> installed. If the import works without errors, the installation was successful.</p>"},{"location":"outputs/","title":"Outputs","text":"<p>Travel Model Two (TM2) generates a variety of output files across multiple categories.</p>"},{"location":"outputs/#skims","title":"Skims","text":"<p>Skims represent level-of-service (LOS) indicators across transportation modes and time periods.</p> <ul> <li> <p>Highway Skim Matrices <code>skims\\HWYSKM[TimePeriod]_taz.tpp</code>   Include travel time, distance, bridge tolls, and other metrics for different vehicle types (e.g., DA, S2, S3).</p> </li> <li> <p>MAZ to MAZ Distances </p> </li> <li><code>skims\\bike_distance_maz_maz.txt</code> </li> <li> <p><code>skims\\ped_distance_maz_maz.txt</code>   Provide bike and pedestrian distances between Micro Analysis Zones (MAZs).</p> </li> <li> <p>TAZ to TAZ Bike Distances <code>skims\\bike_distance_taz_taz.txt</code>   Show bike distances between Traffic Analysis Zones (TAZs).</p> </li> <li> <p>Transit Skims <code>skims\\transit_skims_[TimePeriod]_[Iteration]_[Inner Iteration].omx</code>   Contain transit LOS indicators for various time periods and iterations.</p> </li> </ul>"},{"location":"outputs/#ctramp-output","title":"CTRAMP Output","text":"<p>CTRAMP outputs provide detailed data on individual and joint travel behaviors.</p> <ul> <li> <p>Individual Tours File <code>indivTourData_[iteration].csv</code>   Records individual tour data.</p> </li> <li> <p>Individual Trips File <code>indivTripData_[iteration].csv</code>   Logs individual trip details.</p> </li> <li> <p>Joint Tours File <code>jointTourData_[iteration].csv</code>   Captures joint tour information.</p> </li> <li> <p>Joint Trips File <code>jointTripData_[iteration].csv</code>   Details joint trip data.</p> </li> <li> <p>Resimulated Transit Trips File <code>ctramp_output/indivTripDataResim_[iteration]_[inner_iteration].csv</code>   Contains resimulated transit trip data.</p> </li> <li> <p>Unconstrained Parking Demand File <code>ctramp_output/unconstrainedPNRDemand_[iteration]0.csv</code>   Shows parking demand without constraints.</p> </li> <li> <p>Constrained Parking Demand File <code>ctramp_output/constrainedPNRDemand_[iteration]1.csv</code>   Displays parking demand with constraints.</p> </li> <li> <p>Tour and Trip Mode Codes   Provides codes for different travel modes.</p> </li> <li> <p>Time Period Codes   Lists codes representing various time periods.</p> </li> </ul>"},{"location":"outputs/#assignment-outputs","title":"Assignment Outputs","text":"<p>Assignment outputs reflect the results of network assignments.</p> <ul> <li>Highway Assignment Networks </li> <li><code>hwy\\maz_preload_[TimePeriod].net</code> </li> <li><code>hwy\\load[TimePeriod].net</code> </li> <li> <p>Other intermediate and final highway network assignment files.</p> </li> <li> <p>Transit Assignment Tables </p> </li> <li><code>trn\\boardings_by_line_[TimePeriod].txt</code> </li> <li><code>trn\\boardings_by_segment_[TimePeriod].txt</code>   Detail transit boardings by line and by segment.</li> </ul>"},{"location":"run/","title":"Run the Model Setup","text":""},{"location":"run/#1-set-up-the-model-run-directory","title":"1. Set Up the Model Run Directory","text":""},{"location":"run/#a-open-the-openpaths-emme-shell-and-a-terminal-and-activate-your-tm2py-virtual-environment","title":"a. Open the OpenPaths EMME Shell and a terminal and activate your tm2py virtual environment:","text":"<pre><code>OpenPaths EMME Environment is set to:\nOpenPaths EMME 25.00.01.06 64-bit,   Copyright 2025 Bentley Systems, Incorporated\n\nPython Path is set to:\nC:\\Program Files\\Bentley\\OpenPaths\\EMME 25.00.01\\Python311\\\n\nC:\\Users\\lzorn\\Documents&gt;E:\\GitHub\\tm2\\tm2py_env\\Scripts\\activate\n\n(tm2py_env) C:\\Users\\lzorn\\Documents&gt;\n</code></pre>"},{"location":"run/#b-configure-input-and-output-paths","title":"b. Configure Input and Output Paths","text":"<p>If needed, edit the configuration file located at: <code>tm2py-utils/tm2py-utils/config/develop/setup_config_mtc_2015.toml</code></p>"},{"location":"run/#c-run-setup_modelpy","title":"c. Run <code>setup_model.py</code>","text":"<p>This script is a light wrapper for SetupModel and it takes two arguments:</p> <ol> <li>the location of the setup configuration file from the previous step</li> <li>the model run directory. </li> </ol> <p>Either argument can be relative or absolute paths</p> <pre><code>(tm2py_env) E:\\GitHub\\tm2\\tm2py&gt;python scripts\\setup_model.py E:\\GitHub\\tm2\\tm2py-utils\\tm2py-utils\\config\\develop\\setup_config_mtc_2015.toml E:\\TM2\\2023_TM2_test_20250606\n</code></pre> <p>TODO: Fix this Note: You may need to update the <code>emmebanks</code> to the latest version before the model will run. Also: We used a different <code>WalkTransitDriveSkims.xls</code> file in the CTRAMP folder.</p>"},{"location":"run/#2-run-the-model","title":"2. Run the Model","text":"<p>While still in the activated virtual environment:</p> <ol> <li>Navigate to the model run directory you setup in the previous step.</li> <li>Run the model: <pre><code>(tm2py_env) E:\\GitHub\\tm2&gt;cd E:\\TM2\\2023_TM2_test_20250606\n\n(tm2py_env) E:\\TM2\\2023_TM2_test_20250606&gt;python RunModel.py\n</code></pre></li> </ol>"},{"location":"run/#user-configuration","title":"User Configuration","text":""},{"location":"run/#model-configuration","title":"Model Configuration","text":"<p>The model config file allows for customization on the the model run performance settings.</p>"},{"location":"run/#network-acceleration","title":"Network Acceleration","text":"<p>Emme Openpaths provides the network accelerate option, which allows for faster assignment on smaller machines. WARNING: This has lead to some instability with model runs completing so, especially on large machines, this should remain off </p> <p>To enable this under [highway] in toml <pre><code>    network_acceleration=true\n</code></pre></p>"},{"location":"run/#parallel-highway-assignment","title":"Parallel Highway Assignment","text":"<p>tm2py offers the option to run assignment in parallel to reduce runtime. This can be achieved by including the following configuration under [emme] in the model_config. <pre><code>    [[emme.highway_distribution]]\n        time_periods = [\"AM\"]\n        num_processors = \"MAX/3\"\n    [[emme.highway_distribution]]\n        time_periods = [\"PM\"]\n        num_processors = \"MAX/3\"\n    [[emme.highway_distribution]]\n        time_periods = [\"EA\", \"MD\", \"EV\"]\n        num_processors = \"MAX/3\"\n</code></pre></p> <p>Otherwise, to turn this feature off, explicitly configure tm2py to use 1 thread: <pre><code>    if serial assignment is required comment about the above block and use the below\n    [[emme.highway_distribution]]\n        time_periods = [\"EA\", \"AM\", \"MD\", \"PM\", \"EV\"]\n        num_pro\n</code></pre></p>"},{"location":"server-setup/","title":"Set up server","text":""},{"location":"server-setup/#mtcs-server","title":"MTC\u2019s server","text":"<p>MTC is running tm2py on Intel(R) Xeon(R) Gold 6338 CPU @ 2.00GHz processors, 24 sockets, 48 cores. The servers have 512 GB of memory and run Windows Server 2019 Standard.</p> <p>The C: drive has 80 GB, and an external E: drive has about 1 TB of disk space.</p>"},{"location":"server-setup/#required-software","title":"Required Software","text":"<ol> <li> <p>OpenPaths/EMME (24.01) Advanced    From this link, search for OpenPaths, then install OpenPaths 204 Update 1 (SES).</p> </li> <li> <p>Java 1.8.0 162    CTRAMP runs on Java. </p> </li> <li> <p>Box    MTC gets its input files from Box, so this is required for now. We\u2019ll need to figure out a long-term location for inputs.  </p> </li> </ol> <p>To install Box, you also need the Microsoft .NET Framework 4.8, and you will need to restart your machine.  </p> <p>MTC staff run the model from the E: Box location. To configure the Box folder location, follow these instructions:    https://support.box.com/hc/en-us/articles/360043697454-Configuring-the-Default-Box-Drive-Folder-Location</p> <ol> <li>Git/Git Bash and/or GitHub Desktop    You\u2019ll need this to clone the tm2py repository. Just search online to install.</li> </ol>"},{"location":"server-setup/#optional-software","title":"Optional Software","text":"<ol> <li>Visual Studio Code    This can be used to debug Python and run Jupyter notebooks. Install the Python, Java and Jupyter extensions.and run jupyter notebooks. Install the python and jupyter notebook extensions.</li> </ol>"},{"location":"contributing/development/","title":"Development","text":""},{"location":"contributing/development/#development-pattern","title":"Development Pattern","text":"<p>Generally speaking, development uses git branches to manage progress on features and bugs while maintaining a stable and versioned <code>main</code> branch while developing most features from the <code>develop</code> branch as per the git-flow model and product road-mapping as per issues in milestones and managed in the project board.</p> <pre><code>    gitGraph\n      commit  id: \"a\"\n      branch develop\n      checkout develop\n      commit id: \"initial development setup\"\n      branch featureA\n      checkout featureA\n      commit id: \"initial try\"\n      commit id: \"more work\"\n      commit id: \"Passes Tests\"\n      checkout develop\n      commit id: \"small change\"\n      checkout featureA\n      merge develop\n      commit id: \"Passes Tests w/Develop Updates\"\n      checkout develop\n      merge featureA\n      branch featureB\n      checkout featureB\n      commit id: \"work on another feature\"\n      commit id: \"b\"\n      checkout develop\n      merge featureB\n      checkout main\n      merge develop\n      branch release\n      checkout release\n      commit tag: \"v0.9-prerelease\"\n      commit tag: \"v0.9\"\n      checkout main\n      merge release\n      checkout develop\n      merge main\n\n</code></pre>"},{"location":"contributing/development/#how-to-contribute","title":"How to Contribute","text":"<p>The following are the general steps taken to contribute to <code>tm2py</code>.</p>"},{"location":"contributing/development/#issue-development","title":"Issue Development","text":"<p>Generally-speaking, all contributions should support an issue which has a clearly-defined user-story, a set of tests/conditions which need to be demonstrated in order to close the issue, an agreed-upon approach, and is assigned to the person who should be working on it.</p>"},{"location":"contributing/development/#branch","title":"Branch","text":"<p>Use GitHub\u2019s branching capabilities to create a feature branch from the main <code>develop</code> branch which is clearly named (e.g. features:<code>feat-add-transit-assignment</code> bug fixes: <code>fix-crash-macosx</code>) and check it out.  </p> Terminal <pre><code>git checkout develop\ngit checkout -b fix-maxos-crash\n</code></pre> GitHub Desktop <p>[Managing branches documentation(https://docs.github.com/en/desktop/contributing-and-collaborating-using-github-desktop/making-changes-in-a-branch/managing-branches)]</p>"},{"location":"contributing/development/#develop-tests","title":"Develop tests","text":"<p>As much as possible, we use test-driven development in order to clearly define when the work is done and working.  This can be acheived through writing a new test or extending another test.  When this is complete, the specified test should fail.</p>"},{"location":"contributing/development/#fix-issue-testsaddress-user-story","title":"Fix issue tests/Address user story","text":"<p>Complete development using the approach agreed upon in the issue.  When this is complete, the tests for the issue should pass and the user story in the issue should be satisfied</p> <p>General notes about code style:</p> <ul> <li>Use PEP8 general style and Google-style docstrings</li> <li>Add logging statements throutout using the logging module</li> <li>Clarity over concision  </li> <li>Expicit over implicit</li> <li>Add comments for non-obvious code where it would take a user a while to figure out</li> </ul> <p>Confirm tests run:</p> With Emme <p>If you have Emme installed, it will automatically run the tests with Emme environment.</p> <pre><code>pytest -s\n</code></pre> Using Mocked Emme Environment <p>If you have Emme installed but want to force running the tests with the Mock:</p> <pre><code>pytest --inro mock\n</code></pre>"},{"location":"contributing/development/#updateaddress-other-failing-tests","title":"Update/address other failing tests","text":"<p>Update your branch with the most recent version of the develop branch (which may have moved forward), resolving any merge-conflicts and other tests that may now be failing. When this is complete, all tests should pass.</p> <p>Tip</p> <p>You can (and should) push your changes throughout your work so that others can see what you are working on, contribute advice, and sometimes work on the issue with you.</p>"},{"location":"contributing/development/#update-relevant-documentation","title":"Update relevant documentation","text":"<p>See the Docmentation on Documentation.</p>"},{"location":"contributing/development/#tidy-your-work","title":"Tidy your work","text":"<p>In order to make sure all changes comply with our requirements and are consistent with specifications (i.e. for markdown files, which aren\u2019t tested in <code>pytest</code>), we use <code>pre-commit</code>:</p> <pre><code>pre-commit run --all-files\npre-commit run --hook-stage manual --all-files\n</code></pre> <p>Tip</p> <p>Often pre-commit checks will \u201cfail\u201d on the first run when they are fixing the issues.  When you run it again, hopefully it will be successful.</p>"},{"location":"contributing/development/#pull-request","title":"Pull-Request","text":"<p>Create the pull-request which clearly defines what the pull request contains and link it to the issues it addresses in the description via closing keywords (if applicable) or references.  Finally, please assign reviewers who should review the pull-request prior to it being merged and address their requested changes.</p>"},{"location":"contributing/development/#review-and-agree-on-pull-request-with-reviewers","title":"Review and Agree on Pull Request with Reviewers","text":"<p>Pull request author should be responsive to reviewer questions and comments, addressing them in-line and through updated code pushes.</p>"},{"location":"contributing/development/#merge","title":"Merge","text":"<p>Merge approved pull-request to <code>develop</code> using the <code>squash all changes</code> functionality so that it appears as a single commit on the <code>develop</code> branch. Resolve any merge conflicts and closing any issues which were fully addressed.</p>"},{"location":"contributing/development/#logging","title":"Logging","text":"<p>The Logging module has the following levels:</p> <ul> <li>display </li> <li>file </li> <li>fallback </li> </ul> <p>In addition, there are:</p> <ul> <li>override logging level filter by component name and iteration, and  </li> <li>notify slack component (untested at this time)</li> </ul>"},{"location":"contributing/development/#logging-levels","title":"Logging Levels","text":"<p>Here are the log levels as defined in <code>TM2PY</code>:</p> Level Description TRACE Highly detailed information which would rarely be of interest except for detailed debugging by a developer. DEBUG diagnostic information which would generally be useful to a developer debugging the model code; this may also be useful to a model operator in some cases. DETAIL more detail than would normally be of interest, but might be useful to a model operator debugging a model run / data or understanding model results. INFO messages which would normally be worth recording about the model operation. STATUS top-level, model is running type messages. There should be relatively few of these, generally one per component, or one per time period if the procedure is long. WARN warning messages where there is a possibility of a problem. ERROR problem causing operation to halt which is normal (or not unexpected) in scope, e.g. file does not exist. Includes general Python exceptions. FATAL severe problem requiring operation to stop immediately. <p>Note</p> <p>In practice there may not be a large distinction between ERROR and FATAL in tm2py context.</p>"},{"location":"contributing/development/#adding-log-statements-in-code","title":"Adding log statements in code","text":"<p>Messages can be recorded using:</p> <pre><code>logger.log(level=\"INFO\")\n\n#or equivalently\n\nlogger.info()\n</code></pre> <p>Additional arguments: - Indent the message: <code>indent=True</code></p> <p>Group log messages together: - Using a context: <code>logger.log_start_end()</code> - Using a decorator:</p> <pre><code>@LogStartEnd(\"Highway assignment and skims\", level=\"STATUS\")\ndef run(self):\n</code></pre>"},{"location":"contributing/development/#viewing-logging","title":"Viewing logging","text":"<p>Log messages can be shown in the console / notebook (using the logging.display_level)</p> <pre><code>import logging\nlogging.display_level = \"INFO\" # or DEBUG, etc.\n</code></pre> <p>Log files with written log messages are split into:</p> Run Log <p>For model overview.</p> Settings Location: <code>logging.run_file_path</code> Level: <code>logging.run_file_level</code> Debug Log <p>A more detailed log.</p> Settings Location: <code>logging.log_file_path</code> Level: <code>logging.log_file_level</code> Catch-all Log <p>Will output all log messages recorded.</p> Settings Location: <code>logging.log_on_error_file_path</code> Level: All\u2026 <p>Note</p> <p>Some logging can be conditional to only run if the log level is filtered in.</p> <p>e.g. if it takes a long time to generate the report. There is an example of this in the highway assignment which generates a report of the matrix results statistics only if DEBUG is filtered in for at least one of the log_levels.</p>"},{"location":"contributing/development/#additional-settings","title":"Additional Settings","text":""},{"location":"contributing/development/#locally-override-logging-level-for-debugging","title":"Locally override logging level for debugging","text":"<p>The <code>logging.iter_component_level</code> can be used to locally override the logging level filter for debug purposes. This is specified as one or more tuples of (iteration, component_name, log_level).</p> <p>Example</p> <p>Record all messages during the highway component run at iteration 2:</p> <pre><code>logging.iter_component_level: [ [2, \"highway\", \"TRACE\"] ]\n</code></pre>"},{"location":"contributing/documentation/","title":"Documentation","text":"<p>Documentation is developed using the Python package mkdocs.</p>"},{"location":"contributing/documentation/#installing","title":"Installing","text":"<p>Running the Travel Model via tm2py involves running from an Emme virtual environment (see run)</p> <p>Assuming you don\u2019t want to deal with installing documentation-related packages into that virtual environment, then you might want to make an environment for documentation:</p> <pre><code># Create the environment, specifying the location environment\n# This is useful since MTC virtual machines typically have small C drives and big E drives\n(base) PS E:\\&gt; conda create python=3.11.9 --prefix E:\\conda\\envs\\tm2py-docs\n# Activate that environment\n(base) PS E:\\&gt; conda activate E:\\conda\\envs\\tm2py-docs\n# Navigate to your tm2py clone for which you want to build docs\n(tm2py-docs) PS E:\\&gt;cd E:\\GitHub\\tm2\\tm2py\\\n# Install tm2py in editable mode; this should install requirements as well\n(tm2py-docs) PS E:\\GitHub\\tm2\\tm2py&gt; pip install -e .\n# Install docs requirements\n(tm2py-docs) PS E:\\GitHub\\tm2\\tm2py&gt; pip install -r .\\docs\\requirements.txt\n</code></pre>"},{"location":"contributing/documentation/#building-locally","title":"Building Locally","text":"<p>Mkdocs documentation webpages can be built locally and viewed at the URL specified in the terminal:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"contributing/documentation/#helpful-references","title":"Helpful References:","text":"<ol> <li>mkdocstrings - how to document code to generate documentation.</li> </ol>"},{"location":"contributing/documentation/#linting","title":"Linting","text":"<p>Documentation should be linted before deployment:</p> <pre><code>pre-commit run --all-files\npre-commit run --hook-stage manual --all-files\n</code></pre>"},{"location":"contributing/documentation/#deploying-documentation","title":"Deploying documentation","text":"<p>Documentation is built and deployed to [http://bayareametro.github.io/tm2py] using the <code>mike</code> package and Github Actions configured in <code>.github/workflows/</code> for each \u201cref\u201d (i.e. branch) in the tm2py repository.</p>"},{"location":"examples/","title":"Example Workflows","text":"Example Description Run Model Simple model run Configuration To come. Restart Model Run To come."}]}